/*
 * ARMDisassembler.h
 *
 *  Created on: Aug 25, 2014
 *      Author: anon
 */

#ifndef ARMDISASSEMBLER_H_
#define ARMDISASSEMBLER_H_

#include "disassembly/generic/AbstractDisassembler.h"
#include "disassembly/generic/Instruction.h"

#include <vector>
#include <deque>
#include <functional>

namespace Disassembler {
	typedef enum reg_t {
		// Core registers.
		r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11,
		r12, r13, r14, r15,

		// Coprocessor registers.
		cr0, cr1, cr2, cr3, cr4, cr5, cr6, cr7, cr8, cr9,
		cr10, cr11, cr12, cr13, cr14, cr15,

		// Advanced SIMD double-word registers (64bits).
		d0, d1, d2, d3, d4, d5, d6, d7, d8, d9,
		d10, d11, d12, d13, d14, d15, d16, d17,
		d18, d19, d20, d21, d22, d23, d24, d25,
		d26, d27, d28, d29, d30, d31,

		R_REGCNT,
		R_INVLD = -1,
		R_BASE = r0,
		CR_BASE = cr0,
		FP_BASE = d0,

		// Alternative names for general purpose registers.
		FP = r11,
		IP = r12,
		SP = r13,
		LR = r14,
		PC = r15,

		s0 = d0,
		s1, s2, s3, s4, s5, s6, s7, s8, s9,
		s10, s11, s12, s13, s14, s15, s16,
		s17, s18, s19, s20, s21, s22, s23,
		s24, s25, s26, s27, s28, s29, s30,
		s31,

		// Advanced SIMD quad-word registers (128bits).
		q0 = d0,
		q1 = d2,
		q2 = d4,
		q3 = d6,
		q4 = d8,
		q5 = d10,
		q6 = d12,
		q7 = d14,
		q8 = d16,
		q9 = d18,
		q10 = d20,
		q11 = d22,
		q12 = d24,
		q13 = d26,
		q14 = d28,
		q15 = d30,
	} reg_t;

	typedef enum cond_t {
		C_EQ = 0,
		C_NE = 1,
		C_CS = 2,
		C_CC = 3,
		C_MI = 4,
		C_PL = 5,
		C_VS = 6,
		C_VC = 7,
		C_HI = 8,
		C_LS = 9,
		C_GE = 10,
		C_LT = 11,
		C_GT = 12,
		C_LE = 13,
		C_AL = 14,

		C_HS = C_CS,
		C_LO = C_CC,
		C_UNCOND = 15,

		C_CONDCNT,
		C_BASE = C_EQ,
	} cond_t;

	typedef enum shift_type_t {
		S_LSL, S_LSR, S_ASR, S_ROR, S_RRX, S_SHFTTYPCNT, S_BASE = S_LSL,
	} shift_type_t;

	typedef enum option_t {
		O_OSHST = 2,  // b0010
		O_OSH = 3,  // b0011
		O_NSHST = 6,  // b0110
		O_NSH = 7,  // b0111
		O_ISHST = 10, // b1010
		O_ISH = 11, // b1011
		O_ST = 14, // b1110
		O_SY = 15, // b1111

		O_OPTIONCNT,
		O_INVLD = -1,
		O_BASE = 0,
	} option_t;

	typedef enum coproc_t {
		p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15,

		P_PROCCNT, P_INVLD = -1, P_BASE = p0,
	} coproc_t;

	typedef struct ins_t {
			uint32_t insn;

			// TODO: AUTOGENERATED
			// instr_t instr;
			cond_t cond;

			reg_t Rd;
			reg_t Rn;
			reg_t Rm;
			reg_t Ra;
			reg_t Rt;
			reg_t Rt2;
			reg_t RdHi;
			reg_t RdLo;
			reg_t Rs;

			reg_t Vd;
			reg_t Vn;
			reg_t Vm;

			uint32_t imm;

			shift_type_t shift_type;
			uint32_t S, E, P, U, W;
			option_t option;
			uint32_t lsb, msb, width;
			uint32_t register_list;

			coproc_t coproc;
			uint32_t opc1, opc2;
			reg_t CRd, CRn, CRm;

			uint32_t mask, rotate, sat_imm;
			uint32_t msr_mask, it_mask, first_cond;

			uint32_t cmode, Q, size, align, index_align, T, a;
			uint32_t F, len, op, sz, B, simd_type, long_dest, with_zero;
			uint64_t simd_imm;
			double simd_flt;

			// Internal format for generation of human-readable strings.
			const uint8_t *format;
	} ins_t;

	typedef enum ARMVariants {
		ARMv4 = 1 << 0,
		ARMv4T = 1 << 1,
		ARMv5T = 1 << 2,
		ARMv5TE = 1 << 3,
		ARMv5TEJ = 1 << 4,
		ARMv6 = 1 << 5,
		ARMv6K = 1 << 6,
		ARMv6T2 = 1 << 7,
		ARMv7 = 1 << 8,
		ARMv7S = 1 << 9,
		ARMv8 = 1 << 10,
		ARMvAll = 0xffffffff,
		ARMV4T_ABOVE = (ARMv4T | ARMv5T | ARMv5TE | ARMv5TEJ | ARMv6 | ARMv6K | ARMv6T2 | ARMv7 | ARMv7S | ARMv8),
		ARMV5_ABOVE = (ARMv5T | ARMv5TE | ARMv5TEJ | ARMv6 | ARMv6K | ARMv6T2 | ARMv7 | ARMv7S | ARMv8),
		ARMV5TE_ABOVE = (ARMv5TE | ARMv5TEJ | ARMv6 | ARMv6K | ARMv6T2 | ARMv7 | ARMv7S | ARMv8),
		ARMV5J_ABOVE = (ARMv5TEJ | ARMv6 | ARMv6K | ARMv6T2 | ARMv7 | ARMv7S | ARMv8),
		ARMV6_ABOVE = (ARMv6 | ARMv6K | ARMv6T2 | ARMv7 | ARMv7S | ARMv8),
		ARMV6T2_ABOVE = (ARMv6T2 | ARMv7 | ARMv7S | ARMv8),
		ARMV7_ABOVE = (ARMv7 | ARMv7S | ARMv8),
	} ARMVariants;

	typedef enum ARMVFPVersion {
		No_VFP = 0,
		VFPv1 = (1u << 1),
		VFPv2 = (1u << 2),
		VFPv3 = (1u << 3),
		AdvancedSIMD = (1u << 4),
		VFPv1_ABOVE = (VFPv1 | VFPv2 | VFPv3 | AdvancedSIMD),
		VFPv2_ABOVE = (VFPv2 | VFPv3 | AdvancedSIMD),
		VFPv2v3 = (VFPv2 | VFPv3)
	} ARMVFPVersion;

	typedef enum ARMEncoding {
		eEncodingA1,
		eEncodingA2,
		eEncodingA3,
		eEncodingA4,
		eEncodingA5,
		eEncodingT1,
		eEncodingT2,
		eEncodingT3,
		eEncodingT4,
		eEncodingT5
	} ARMEncoding;

	typedef enum ARMInstrSize {
		eSize16, eSize32
	} ARMInstrSize;

	typedef struct ARMOpcode {
			uint32_t mask;
			uint32_t value;
			uint32_t variants;
			uint32_t encoding;
			uint32_t vfp_variants;
			uint32_t size;
			std::function<bool(uint32_t, ARMEncoding)> decoder;
			const char *name;
	} ARMOpcode;

	typedef enum ARMMode {
		eModeInvalid = -1, eModeARM, eModeThumb
	} ARMMode;

	class ARMDisassembler: public AbstractDisassembler {
		private:
			static bool decode_adc_immediate(uint32_t opcode, ARMEncoding encoding);

			static const ARMOpcode arm_opcodes[];

		public:
			ARMDisassembler();
			virtual ~ARMDisassembler();

			virtual std::deque<Instruction> disassemble(std::vector<uint8_t> buffer);
	};

} /* namespace Disassembler */

#endif /* ARMDISASSEMBLER_H_ */

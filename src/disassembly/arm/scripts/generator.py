"""
This script generates both the decoder and the multiplexing tables
used for opcode disassembly.
"""
import argparse
import os
import re
import logging

from ARMv7DecodingSpec import instructions

DEBUG = False

def instruction_decoder_name(instruction):
    """
    Given an instruction with the format specified in ARMv7DecodingSpec.py
    output a unique name that represents that particular instruction decoder.
    """
    # Replace all the bad chars.
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])

    # Append the encoding.
    name += "_" + instruction["encoding"]

    # We may end up with double dashes, remove them.
    name = name.replace("__", "_")
    return "decode_" + name.lower()

def instruction_id_name(instruction):
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])
    name = name.replace("__", "_").lower()
    return name if name[-1] != "_" else name[:-1]
    
def get_value(input):
    r = "0b"
    for e in input.split():
        if not "#" in e:
            r += e

        else:
            r += "0" * int(e.split("#")[1])

    return int(r, 2)

def get_mask(input):
    r = "0b"
    for e in input.split():
        if not "#" in e:
            r += "1" * len(e)
        else:
            r += "0" * int(e.split("#")[1])

    return int(r, 2)

decoder_header_h = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>

#include "ARMDisassembler.h"

using namespace Disassembler;

'''

decoder_header_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>

#include "ARMDisassembler.h"
#include "ARMUtilities.h"
#include "ARMv7Decoder.h"
#include "utilities/Utilities.h"

using namespace Disassembler;

bool ARMv7Decoder::InITBlock() {
    return CurrentInstrSet() == InstrSet_Thumb && m_it_session.InITBlock();
}

bool ARMv7Decoder::LastInITBlock() {
    return CurrentInstrSet() == InstrSet_Thumb && m_it_session.LastInITBlock();
}

InstrSet ARMv7Decoder::CurrentInstrSet() {
    return m_opcode_mode;
}

ARMVariants ARMv7Decoder::ArchVersion() {
    return m_arm_isa;
}

// apsr_t APSR;
// fpscr_t FPSCR;

'''

def get_input_vars(input):
    input_vars = []

    for var in input.split():
        if not "#" in var:
            continue

        name, size = var.split("#")
        size = int(size)

        input_vars.append((name, size))

    return input_vars

def __validate_bit_patterns__(bit_patterns):
    cnt = 0
    for bit_pattern in bit_patterns:
        if not "#" in bit_pattern:
            cnt += len(bit_pattern)
        else:
            cnt += int(bit_pattern.split("#")[1])

    return cnt == 32 or cnt == 16


def __translate_bit_patterns__(bit_patterns):
    # Make sure the input patterns are valid.
    if not __validate_bit_patterns__(bit_patterns):
        raise RuntimeError("Invalid bit patters: %r" % bit_patterns)

    ret = []

    i = 31
    for bit_pattern in bit_patterns:
        # print "Decoding bit pattern: %r" % bit_pattern

        # Skip regular bits.
        if not "#" in bit_pattern:
            # print "  Skipping bits from [%d-%d]" % (i, i - len(bit_pattern) + 1)
            i -= len(bit_pattern)

        else:
            name, size = bit_pattern.split("#")
            size = int(size)

            # print "  Extracting bits into %s from [%d-%d]" % (name, i, i - size + 1)
            if size == 1:
                ret.append("int %5s = get_bit(opcode, %2d);" % (name, i))
            else:
                ret.append("int %5s = get_bits(opcode, %2d, %2d);" % (name, i, i - size + 1))

            i -= size

    return ret

def indent(lines):
    t = ""
    for l in lines.split("\n"):
        t += "        %s\n" % l

    return t

def create_decoders(filename):
    """
    Create the ARMv7Decoder.h and ARMv7Decoder.cpp.
    """
    import ARMv7Parser

    # Create the name of the header.
    header_name = os.path.splitext(filename)[0] + ".h"

    # Create the header file with all the declarations.
    with open(header_name, "w") as fd:
        fd.write(decoder_header_h)

        # Generate the instruction id enum.
        fd.write("typedef enum ARMv7InstructionId {\n")
        
        for instruction_id in sorted(set(map(instruction_id_name, instructions))):
            fd.write("    %s,\n" % instruction_id)
        
        fd.write("} ARMv7InstructionId;\n\n")

        fd.write("class ARMv7Decoder {\n")
        fd.write("    public:\n")
        fd.write("        static ARMv7Decoder create(InstrSet mode, ARMVariants variant);\n")
        fd.write("        ARMInstruction decode(uint32_t opcode);\n\n")

        fd.write("    private:\n")
        fd.write("        ARMVariants ArchVersion();\n")
        fd.write("        bool InITBlock();\n")
        fd.write("        bool LastInITBlock();\n")
        fd.write("        InstrSet CurrentInstrSet();\n\n")
        fd.write("        // Locals:\n")
        fd.write("        ITSession m_it_session;\n")
        fd.write("        InstrSet m_opcode_mode;\n")
        fd.write("        ARMVariants m_arm_isa;\n")
        fd.write("        apsr_t APSR;\n")
        fd.write("        fpscr_t FPSCR;\n\n")
                
        fd.write("        typedef struct ARMOpcode {\n")
        fd.write("                uint32_t mask;\n")
        fd.write("                uint32_t value;\n")
        fd.write("                uint32_t variants;\n")
        fd.write("                uint32_t encoding;\n")
        fd.write("                Disassembler::ARMInstruction (ARMv7Decoder::*decoder)(uint32_t, ARMEncoding);\n")
        fd.write("                const char *name;\n")
        fd.write("        } ARMOpcode;\n\n")
        fd.write("        ARMOpcode *decode_arm(uint32_t opcode);\n")
        fd.write("        ARMOpcode *decode_thumb(uint32_t opcode);\n\n")

        for instruction in instructions:
            fd.write("        ARMInstruction %s(uint32_t opcode, ARMEncoding encoding);\n" % instruction_decoder_name(instruction))

        fd.write("};\n")

    # Create the implementation file.
    with open(filename, "w") as fd:
        fd.write(decoder_header_cpp)

        fd.write("ARMv7Decoder::ARMOpcode *ARMv7Decoder::decode_arm(uint32_t opcode) {\n")
        fd.write("    // Format: (mask, value, version, encoding, decoder_function)\n")
        fd.write("    static ARMOpcode arm_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "T":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = instruction_decoder_name(instruction)
            fd.write("        { 0x%.8x, 0x%.8x, %s, %s, &ARMv7Decoder::%s },\n" % (mask, value, version, encoding, decoder))

        fd.write("    };\n\n")
        fd.write("    static const size_t n_arm_opcodes = sizeof(arm_opcodes) / sizeof(arm_opcodes[0]);\n")
        fd.write("    for (size_t i = 0; i < n_arm_opcodes; ++i) {\n")
        fd.write("        if ((arm_opcodes[i].mask & opcode) == arm_opcodes[i].value && (arm_opcodes[i].variants & m_arm_isa) != 0)\n")
        fd.write("            return &arm_opcodes[i];\n")
        fd.write("    }\n\n")
        fd.write("    return NULL;\n")
        fd.write("}\n\n")

        fd.write("ARMv7Decoder::ARMOpcode *ARMv7Decoder::decode_thumb(uint32_t opcode) {\n")
        fd.write("\n    static ARMOpcode thumb_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "A":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = instruction_decoder_name(instruction)
            fd.write("        { 0x%.8x, 0x%.8x, %s, %s, &ARMv7Decoder::%s },\n" % (mask, value, version, encoding, decoder))

        fd.write("    };\n\n")
        fd.write("    static const size_t n_thumb_opcodes = sizeof(thumb_opcodes) / sizeof(thumb_opcodes[0]);\n")
        fd.write("    for (size_t i = 0; i < n_thumb_opcodes; ++i) {\n")
        fd.write("        if ((thumb_opcodes[i].mask & opcode) == thumb_opcodes[i].value && (thumb_opcodes[i].variants & m_arm_isa) != 0)\n")
        fd.write("            return &thumb_opcodes[i];\n")
        fd.write("    }\n\n")
        fd.write("    return NULL;\n")
        fd.write("}\n\n")

        i = -1
        for instruction in instructions:
            i += 1

            if i == 20: break

            input_vars = get_input_vars(instruction["pattern"])
            decoder = instruction["decoder"]

            if DEBUG:
                fd.write("// Translating: %d -> %s %s %s\n" % (i, instruction["name"], instruction["encoding"], instruction["pattern"]))
                fd.write("// Pseudocode:\n")
                for line in decoder.split("\n"):
                    for line2 in line.split(";"):
                        if not len(line2):
                            continue
                        fd.write("// " + line2.strip() + "\n")

            if i % 50 == 0:
                logging.info("Processing instruction %.4d of %.4d" % (i, len(instructions)))

            fd.write("ARMInstruction ARMv7Decoder::%s(uint32_t opcode, ARMEncoding encoding) {\n" % instruction_decoder_name(instruction))
            ret = __translate_bit_patterns__(instruction["pattern"].split())
            for r in ret:
                fd.write("    %s\n" % r)

            ret = ARMv7Parser.program.parseString(decoder, parseAll=True)
            visitor = ARMv7Parser.CPPTranslatorVisitor(input_vars)

            body = ""
            for ast in ret:
                l = visitor.accept(ast[0])
                body += indent(l)

                if type(ast[0]) == ARMv7Parser.ProcedureCall:
                    body = body[:-1] + ";\n"

            for var in visitor.define_me:
                fd.write("    int %s = 0;\n" % var)

            fd.write("\n")
            fd.write(body)

            # All the variables defined in the body end up in the instruction.
            fd.write("    ARMInstruction ins = ARMInstruction::create();\n")
            fd.write("    ins.id = %s;\n" % instruction_id_name(instruction))
            for var in visitor.define_me:
                fd.write("    ins.%s = %s;\n" % (var, var))

            # Here we hard code some variables that are not defined in the body but need to go into the instruction.
            hard = ["cond", "coproc", "opc1", "CRd", "CRn", "CRm", "opc2", "option", "B", "P", "U", "op", "imm3", "imm6"]
            for var in input_vars:
                if var[0] in hard:
                    fd.write("    ins.%s = %s;\n" % (var[0], var[0]))

            fd.write("\n")

            fd.write("    return ins;\n")
            fd.write("}\n\n")

    return True

to_string_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <string>
#include <cstdlib>
#include <cstdio>

#include "ARMDisassembler.h"
#include "ARMv7Decoder.h"
#include "utilities/Utilities.h"

using namespace Disassembler;

const char *S_str(const ARMInstruction *ins) {
    return ins->setflags ? "S" : "";
}

const char *c_str(const ARMInstruction *ins) {
    return ins->cond != COND_AL ? ARMCondCodeToString((cond_t) ins->cond) : "";
}

const char *B_str(const ARMInstruction *ins) {
    return ins->B ? "B" : "";
}

const char *N_str(const ARMInstruction *ins) {
    return ins->nonzero ? "N" : "";
}

const char *W_str(const ARMInstruction *ins) {
    return ins->is_pldw ? "W" : "";
}

const char *x_str(const ARMInstruction *ins) {
    return ins->n_high ? "T" : "B";
}

const char *y_str(const ARMInstruction *ins) {
    return ins->m_high ? "T" : "B";
}

const char *X_str(const ARMInstruction *ins) {
    return ins->m_swap ? "X" : "";
}

const char *R_str(const ARMInstruction *ins) {
    return ins->round ? "R" : "";
}

const char *mode_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vldm: // VLDM
        case vstm: // VSTM
            if (ins->P == 0 && ins->U == 1)
                return "IA";

            if (ins->P == 1 && ins->U == 0)
                return "DB";

            break;
        default:
            break;
    }

    return "INVALID";
}

const char *op_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vpmax_vpmin_floating_point: // VPMAX, VPMIN (floating-point)
        case vpmax_vpmin_integer: // VPMAX, VPMIN (integer)
            return ins->op ? "MIN" : "MAX";
        case vqdmlal_vqdmlsl: // VQDMLAL, VQDMLSL
            return ins->op ? "MLSL" : "MLAL";
        case vtbl_vtbx: // VTBL, VTBX
            return ins->op ? "X" : "L";

        default:
            break;
    }

    return "INVALID";
}

const char *dt_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vaba_vabal: // VABA, VABAL
        case vabd_vabdl_integer: // VABD, VABDL (integer)
            if (ins->size == 0 && ins->U == 0)
                return "S8";
            else if (ins->size == 0 && ins->U == 0)
                return "S8";
            else if (ins->size == 1 && ins->U == 0)
                return "S16";
            else if (ins->size == 2 && ins->U == 0)
                return "S32";
            else if (ins->size == 0 && ins->U == 1)
                return "U8";
            else if (ins->size == 1 && ins->U == 1)
                return "U16";
            else if (ins->size == 2 && ins->U == 1)
                return "U32";

            break;
        case vaddhn: // VADDHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vmov_scalar_to_arm_core_register: // VMOV (scalar to ARM core register)
            if (ins->U == 0 && get_bit(ins->opc1, 1) == 1)
                return "S8";
            else if (ins->U == 0 && get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "S16";
            else if (ins->U == 1 && get_bit(ins->opc1, 1) == 1)
                return "U8";
            else if (ins->U == 1 && get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "U16";
            else if (ins->U == 0 && get_bit(ins->opc1, 1) == 0 && ins->opc2 == 0)
                return "32";

            break;
        case vmovl: // VMOVL
            if (ins->U == 0 && ins->imm3 == 1)
                return "S8";
            else if (ins->U == 0 && ins->imm3 == 2)
                return "S16";
            else if (ins->U == 0 && ins->imm3 == 3)
                return "S32";
            else if (ins->U == 1 && ins->imm3 == 1)
                return "u8";
            else if (ins->U == 1 && ins->imm3 == 2)
                return "U16";
            else if (ins->U == 1 && ins->imm3 == 3)
                return "U32";

            break;
        case vmovn: // VMOVN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vmul_vmull_by_scalar: // VMUL, VMULL (by scalar)
        case vmul_vmull_integer_and_polynomial: // VMUL, VMULL (integer and polynomial)
        case vpadd_integer: // VPADD (integer)
            switch (ins->size) {
                case 0:
                    return "I8";
                case 1:
                    return "I16";
                case 2:
                    return "I32";
                default:
                    break;
            }

            break;
        case vpmax_vpmin_integer: // VPMAX, VPMIN (integer)
        case vqdmlal_vqdmlsl: // VQDMLAL, VQDMLSL
        case vqdmull: // VQDMULL
            switch (ins->size) {
                case 1:
                    return "S16";
                case 2:
                    return "S32";
                default:
                    break;
            }

            break;
        case vraddhn: // VRADDHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vrsubhn: // VRSUBHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vsubhn: // VSUBHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        default:
            break;
    }

    return "INVALID";
}

const char *U_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            return ins->op == 1 ? "U" : "";
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
            return ins->U == 1 ? "U" : "";

        default:
            break;
    }

    return "INVALID";
}
const char *size_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vmov_arm_core_register_to_scalar: // VMOV (ARM core register to scalar)
            if (get_bit(ins->opc1, 1) == 1)
                return "8";

            else if (get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "16";

            else if (get_bit(ins->opc1, 1) == 0 && ins->opc2 == 0)
                return "32";

            break;
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            if (ins->size == 0)
                return "16";

            else if (ins->size == 1)
                return "32";

            else if (ins->size == 2)
                return "64";

            break;
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
        case vrshrn: // VRSHRN
        case vshll: // VSHLL
        case vshrn: // VSHRN
            if (get_bits(ins->imm6, 5, 3) == 1)
                return "16";

            else if (get_bits(ins->imm6, 5, 4) == 1)
                return "32";

            else if (get_bit(ins->imm6, 5) == 1)
                return "64";

            break;
        default:
            break;
    }

    return "INVALID";
}

const char *type_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            if (ins->op == 1 || ins->op == 2)
                return "S";

            if (ins->op == 3)
                return "U";

            break;
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
            if (ins->U == 0 && ins->op == 1)
                return "S";

            if (ins->U == 1 && ins->op == 0)
                return "S";

            if (ins->U == 1 && ins->op == 1)
                return "U";

            break;
        case vshll: // VSHLL
            if (ins->encoding == eEncodingT2 || ins->encoding == eEncodingA2) {
                if (ins->U == 0)
                    return "S";

                if (ins->U == 1)
                    return "U";
            } else if (ins->encoding == eEncodingT2 || ins->encoding == eEncodingA2) {
                return "I";
            }

            break;

        default:
            break;
    }

    return "INVALID";
}

const char *regular_reg_str(unsigned reg) {
    switch (reg) {
        case 0:
            return "r0";
        case 1:
            return "r1";
        case 2:
            return "r2";
        case 3:
            return "r3";
        case 4:
            return "r4";
        case 5:
            return "r5";
        case 6:
            return "r6";
        case 7:
            return "r7";
        case 8:
            return "r8";
        case 9:
            return "r9";
        case 10:
            return "r10";
        case 11:
            return "r11";
        case 12:
            return "r12";
        case 13:
            return "r13";
        case 14:
            return "r14";
        case 15:
            return "r15";
        default:
            break;
    }

    return "INVALID";
}

const char *coproc_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "p0";
        case 1:
            return "p1";
        case 2:
            return "p2";
        case 3:
            return "p3";
        case 4:
            return "p4";
        case 5:
            return "p5";
        case 6:
            return "p6";
        case 7:
            return "p7";
        case 8:
            return "p8";
        case 9:
            return "p9";
        case 10:
            return "p10";
        case 11:
            return "p11";
        case 12:
            return "p12";
        case 13:
            return "p13";
        case 14:
            return "p14";
        case 15:
            return "p15";
        default:
            break;
    }

    return "INVALID";
}

const char *shift_type_str(unsigned shift) {
    switch (shift) {
        case 0:
            return "LSL";
        case 1:
            return "LSR";
        case 2:
            return "ASR";
        case 3:
            return "ROR";
        case 4:
            return "RRX";
        default:
            break;
    }

    return "INVALID";
}

const char *coproc_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "cr0";
        case 1:
            return "cr1";
        case 2:
            return "cr2";
        case 3:
            return "cr3";
        case 4:
            return "cr4";
        case 5:
            return "cr5";
        case 6:
            return "cr6";
        case 7:
            return "cr7";
        case 8:
            return "cr8";
        case 9:
            return "cr9";
        case 10:
            return "cr10";
        case 11:
            return "cr11";
        case 12:
            return "cr12";
        case 13:
            return "cr13";
        case 14:
            return "cr14";
        case 15:
            return "cr15";
        default:
            break;
    }

    return "INVALID";
}

const char *quad_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "q0";
        case 1:
            return "q1";
        case 2:
            return "q2";
        case 3:
            return "q3";
        case 4:
            return "q4";
        case 5:
            return "q5";
        case 6:
            return "q6";
        case 7:
            return "q7";
        case 8:
            return "q8";
        case 9:
            return "q9";
        case 10:
            return "q10";
        case 11:
            return "q11";
        case 12:
            return "q12";
        case 13:
            return "q13";
        case 14:
            return "q14";
        case 15:
            return "q15";
        default:
            break;
    }

    return "INVALID";
}

const char *double_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "d0";
        case 1:
            return "d1";
        case 2:
            return "d2";
        case 3:
            return "d3";
        case 4:
            return "d4";
        case 5:
            return "d5";
        case 6:
            return "d6";
        case 7:
            return "d7";
        case 8:
            return "d8";
        case 9:
            return "d9";
        case 10:
            return "d10";
        case 11:
            return "d11";
        case 12:
            return "d12";
        case 13:
            return "d13";
        case 14:
            return "d14";
        case 15:
            return "d15";
        case 16:
            return "d16";
        case 17:
            return "d17";
        case 18:
            return "d18";
        case 19:
            return "d19";
        case 20:
            return "d20";
        case 21:
            return "d21";
        case 22:
            return "d22";
        case 23:
            return "d23";
        case 24:
            return "d24";
        case 25:
            return "d25";
        case 26:
            return "d26";
        case 27:
            return "d27";
        case 28:
            return "d28";
        case 29:
            return "d29";
        case 30:
            return "d30";
        case 31:
            return "d31";
        default:
            break;
    }

    return "INVALID";
}

const char *simple_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "s0";
        case 1:
            return "s1";
        case 2:
            return "s2";
        case 3:
            return "s3";
        case 4:
            return "s4";
        case 5:
            return "s5";
        case 6:
            return "s6";
        case 7:
            return "s7";
        case 8:
            return "s8";
        case 9:
            return "s9";
        case 10:
            return "s10";
        case 11:
            return "s11";
        case 12:
            return "s12";
        case 13:
            return "s13";
        case 14:
            return "s14";
        case 15:
            return "s15";
        case 16:
            return "s16";
        case 17:
            return "s17";
        case 18:
            return "s18";
        case 19:
            return "s19";
        case 20:
            return "s20";
        case 21:
            return "s21";
        case 22:
            return "s22";
        case 23:
            return "s23";
        case 24:
            return "s24";
        case 25:
            return "s25";
        case 26:
            return "s26";
        case 27:
            return "s27";
        case 28:
            return "s28";
        case 29:
            return "s29";
        case 30:
            return "s30";
        case 31:
            return "s31";
        default:
            break;
    }

    return "INVALID";
}

const char *option_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case dbg:
            return std::to_string(ins->option).c_str();
        case dmb:
        case dsb:
            if (ins->option == 15)
                return "SY";
            else if (ins->option == 14)
                return "ST";
            else if (ins->option == 11)
                return "ISH";
            else if (ins->option == 10)
                return "ISHST";
            else if (ins->option == 7)
                return "NSH";
            else if (ins->option == 6)
                return "NSHST";
            else if (ins->option == 3)
                return "OSH";
            else if (ins->option == 2)
                return "OSHST";
            break;
        case isb:
            if (ins->option == 15)
                return "SY";
        default:
            break;
    }

    return "INVALID";
}

const char *endian_specifier_str(unsigned endian) {
    return endian ? "BE" : "LE";
}

const char *spec_reg_str() {
    return "APSR";
}

const char *registers_str(unsigned registers) {
    std::string regs;

    for (unsigned i = 0; i < 32; i++) {
        regs += i ? ", " : "";

        if (get_bit(registers, i))
            regs += std::string(regular_reg_str(i));
    }

    return regs.c_str();
}

const char *shift_str(unsigned shift_t, unsigned shift_n) {
    std::string shift = std::string(shift_type_str(shift_t)) + " " + std::to_string(shift_n);
    return shift.c_str();
}

const char *rotation_str(unsigned rotation) {
    switch(rotation) {
        case 0:
            return "";
        case 8:
            return "8";
        case 16:
            return "16";
        case 24:
            return "24";
    }
    
    return "INVALID";
}

'''

to_string_h = '''// Warning! autogenerated file, do what you want.
#include <string>
#include "ARMDisassembler.h"

'''
def create_to_string(filename):
    import ARMv7Parser
    parser = ARMv7Parser.InstructionFormatParser()

    header_name = os.path.splitext(filename)[0] + ".h"

    names = set()

    reg2string = {}
    reg2string["Ra"] = "regular_reg_str(ins->a)"
    reg2string["Rd"] = "regular_reg_str(ins->d)"
    reg2string["RdHi"] = "regular_reg_str(ins->dHi)"
    reg2string["RdLo"] = "regular_reg_str(ins->dLo)"
    reg2string["Rdm"] = "regular_reg_str(ins->d)"
    reg2string["Rdn"] = "regular_reg_str(ins->d)"
    reg2string["Rm"] = "regular_reg_str(ins->m)"
    reg2string["Rn"] = "regular_reg_str(ins->n)"
    reg2string["Rs"] = "regular_reg_str(ins->s)"
    reg2string["Rt"] = "regular_reg_str(ins->t)"
    reg2string["Rt2"] = "regular_reg_str(ins->t2)"
    
    # TODO: Review these. I think we are doing it wrong here.
    reg2string["imm"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm2"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm4"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm5"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm8"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm12"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm16"] = "std::to_string(ins->imm32).c_str()"
    reg2string["imm24"] = "std::to_string(ins->imm32).c_str()"
    reg2string["const"] = "std::to_string(ins->imm32).c_str()"
    reg2string["label"] = "std::to_string(ins->imm32).c_str()"
    
    reg2string["lsb"] = "std::to_string(ins->lsbit).c_str()"
    reg2string["width"] = "std::to_string(32 - ins->lsbit).c_str()"
    
    reg2string["type"] = "shift_type_str(ins->type)"
    reg2string["coproc"] = "coproc_str(ins->coproc)"
    reg2string["opc1"] = "std::to_string(ins->opc1).c_str()"
    reg2string["opc2"] = "std::to_string(ins->opc2).c_str()"
    
    reg2string["CRd"] = "coproc_reg_str(ins->CRd)"
    reg2string["CRn"] = "coproc_reg_str(ins->CRn)"
    reg2string["CRm"] = "coproc_reg_str(ins->CRm)"
    
    reg2string["option"] = "option_str(ins)"
    reg2string["registers"] = "registers_str(ins->registers)"
    reg2string["spec_reg"] = "spec_reg_str()"
    reg2string["endian_specifier"] = "endian_specifier_str(ins->set_bigend)"

    reg2string["Qd"] = "quad_reg_str(ins->d)"
    reg2string["Qn"] = "quad_reg_str(ins->n)"
    reg2string["Qm"] = "quad_reg_str(ins->m)"

    reg2string["Dd"] = "double_reg_str(ins->d)"
    reg2string["Dn"] = "double_reg_str(ins->n)"
    reg2string["Dm"] = "double_reg_str(ins->m)"
    
    reg2string["Sd"] = "simple_reg_str(ins->d)"
    reg2string["Sn"] = "simple_reg_str(ins->n)"
    reg2string["Sm"] = "simple_reg_str(ins->m)"
    
    reg2string["shift"] = "shift_str(ins->shift_t, ins->shift_n)"
    reg2string["rotation"] = "rotation_str(ins->rotation)"
    
    # TODO: Implement these:
    reg2string["list"] = "\"TODO_LIST\""
    reg2string["Dd[x]"] = "\"TODO_LIST\""
    reg2string["Dn[x]"] = "\"TODO_LIST\""
    reg2string["Dm[x]"] = "\"TODO_LIST\""

    # Create the implementation file.
    with open(filename, "w") as fd:
        fd.write(to_string_cpp)

        s = set()

        for instruction in instructions:
            if "CUSTOM" == instruction["format"].split()[0] or ":" in instruction["format"]:
                continue

            # Parse the toString format.
            r = parser.parseString(instruction["format"])
            
            # We divide the instruction in two pices, the name and the arguments.
            op_name = r[0]
            op_args = ARMv7Parser.MandatoryToken("")
            if len(r) == 2:
                op_args = r[1]

            # Write the header with the common structures.
            fd.write("std::string %s_to_string(const ARMInstruction *ins) {\n" % instruction_decoder_name(instruction))
            fd.write("    char op_name[64], op_args[64];\n")
            fd.write("    // DEBUG: %s\n" % instruction["format"])
            fd.write("    int ret = snprintf(op_name, sizeof(op_name),\n")
            fd.write("            \"%s%s\"" % (op_name.name[0], "%s" * (len(op_name.name) - 1)))

            # Skip the last comma if the name has no variable pieces.
            if len(op_name.name[1:]) != 0:
                fd.write(",")
            fd.write("\n")

            # For each of the name's variables.
            for i, val in enumerate(op_name.name[1:]):
                if type(val) is ARMv7Parser.OptionalToken:
                    assert len(val.name) == 1
                    fd.write("            %s_str(ins)" % str(val.name[0]))
                    
                    # Whenever we change the ARMv7DecodingSpec.py we need to re-enble this and fix stuff.
                    # if not str(val) in ["<c>", "{S}"]:
                    #    print val, "case %s:" % instruction_id_name(instruction), "//", instruction["name"]

                elif type(val) is ARMv7Parser.MandatoryToken:
                    fd.write("            %s_str(ins)" % str(val.name))
                    
                    # Whenever we change the ARMv7DecodingSpec.py we need to re-enble this and fix stuff.
                    # if not str(val) in ["<c>", "{S}"]:
                    #    print val, "case %s:" % instruction_id_name(instruction), "//", instruction["name"]

                else:
                    fd.write("            \"%s\"" % val)

                if i != len(op_name.name[1:]) - 1:
                    fd.write(",")

                fd.write("\n")

            fd.write("    );\n\n")
            fd.write("    assert(ret >= 0);\n")

            # Skip the rest if there are no arguments to the instruction.
            if not len(op_args.name):
                fd.write("    return std::string(op_name);\n")
                fd.write("}\n\n")
                continue

            fd.write("    ret = snprintf(op_args, sizeof(op_args),\n")                

            format_string = ""
            vars = []
            for i, val in enumerate(op_args.name):
                if type(val) is ARMv7Parser.MandatoryToken:
                    if val.pound:
                        format_string += val.pound
                                        
                    # Add the format string for the sign if needed.
                    if val.sign == "+/-":
                        format_string += "%s"
                        vars.append("ins->add ? \"\" : \"-\"")
                        
                    else:
                        format_string += val.sign
                              
                    format_string += "%s"  
                    vars.append(reg2string[val.name])
                    
                elif type(val) is ARMv7Parser.OptionalToken:
                    for optional in val.name:
                        # If the token is the write back optional emit the corresponding code.
                        if type(optional) == type(""):
                            # The only string that is optional given an ins is the writeback sign.
                            if optional == "!":
                                format_string += "%s"
                                vars.append("ins->wback ? \"!\" : \"\"")
                            
                            else:
                                format_string += optional                            
                        else:
                            if optional.pound == "#":
                                format_string += "#"
                                
                            if optional.sign == "-":
                                format_string += "-"
                            
                            elif optional.sign == "+/-":
                                format_string += "%s"
                                vars.append("ins->add ? \"\" : \"-\"")
                            
                            format_string += "%s"
                            vars.append(reg2string[optional.name])
                                                
                else:
                    format_string += val
                                
            fd.write("            \"%s\",\n" % format_string)
            
            for i, var in enumerate(vars):
                fd.write("            %s" % var)
                if i < len(vars) - 1:
                    fd.write(",")
                    
                fd.write("\n")
            
            fd.write("    );\n\n")
            fd.write("    assert(ret >= 0);\n")
            fd.write("    return std::string(op_name) + std::string(op_args);\n")
            fd.write("}\n\n")

    # Create the header file.
    with open(header_name, "w") as fd:
        fd.write(to_string_h)

        for instruction in instructions:
            if "CUSTOM" == instruction["format"].split()[0] or ":" in instruction["format"]:
                continue

            fd.write("std::string %s_to_string(const ARMInstruction *ins);\n" % instruction_decoder_name(instruction))

    return True


def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(description='Generator.')
    parser.add_argument("--gendir", default="../gen", help="Directory where the generated files will be placed.")
    parser.add_argument("--table_name", default="ARMv7DecodingTable.cpp", help="File name of the decoding table.")
    parser.add_argument("--decoder_name", default="ARMv7Decoder.cpp", help="File name of the decoder.")
    parser.add_argument("--to_string_name", default="ARMv7toString.cpp", help="File name of the toString implementation.")
    parser.add_argument("--debug", default=False)

    args = parser.parse_args()

    logging.info("Generating decoding tables and routines ...")

    DEBUG = args.debug
    gen_dir = os.path.abspath(args.gendir)
    decoder_name = os.path.join(gen_dir, args.decoder_name)
    to_string_name = os.path.join(gen_dir, args.to_string_name)

    if not os.path.exists(gen_dir):
        logging.info("Directory '%s' does not exist, creating it ..." % gen_dir)
        os.makedirs(gen_dir)

    logging.info("Placing all the generated files in '%s'." % gen_dir)

    if os.path.exists(decoder_name):
        os.remove(decoder_name)

    if os.path.exists(to_string_name):
        os.remove(to_string_name)

    logging.info("Creating decoder at        '%s'." % decoder_name)
    logging.info("Creating toString at       '%s'." % to_string_name)

    if not create_decoders(decoder_name):
        logging.error("Could not create the decoders.")
        return False

    if not create_to_string(to_string_name):
        logging.error("Could not create to_string stubs.")
        return False

    logging.info("Finished creating autogenerated stubs.")
    return True

if __name__ == '__main__':
    main()

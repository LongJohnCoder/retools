"""
This script generates both the decoder and the multiplexing tables
used for opcode disassembly.
"""
import argparse
import os
import re
import logging

from ARMv7DecodingSpec import instructions

DEBUG = False

def instruction_to_name(instruction):
    """
    Given an instruction with the format specified in ARMv7DecodingSpec.py
    output a unique name that represents that particular instruction decoder.
    """
    # Replace all the bad chars.
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])
        
    # Append the encoding.
    name += "_" + instruction["encoding"]
    
    # We may end up with double dashes, remove them.
    name = name.replace("__", "_")
    
    #t = instruction["name"].replace(" ", "_").replace("(", "_").replace(")", "_").replace("-", "_").replace(",", "_").replace("/", "_").replace("#", "_")
    #t = t + "_" + instruction["encoding"].lower()
    return "decode_" + name.lower()

decoding_table_header = \
'''// Warning! autogenerated file, do what you want.
#include "ARMDisassembler.h"
#include "ARMv7Decoder.h"

using namespace Disassembler;
'''
def create_decoding_table(filename):
    def get_value(input):
        r = "0b"
        for e in input.split():
            if not "#" in e:
                r += e
            
            else:
                r += "0" * int(e.split("#")[1])
                
        return int(r, 2)
    
    def get_mask(input):
        r = "0b"
        for e in input.split():
            if not "#" in e:
                r += "1" * len(e)
            else:
                r += "0" * int(e.split("#")[1])
                
        return int(r, 2)    
            
    with open(filename, "w") as fd:
        fd.write(decoding_table_header)

        fd.write("\n// Format: (mask, value, version, encoding, decoder_function)")
        fd.write("\nconst ARMOpcode ARMDisassembler::arm_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "T":
                continue
            
            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = "ARMv7Decoder::" + instruction_to_name(instruction)
            fd.write("  { 0x%.8x, 0x%.8x, %s, %s, %s },\n" % (mask, value, version, encoding, decoder))
        
        fd.write("};\n")

        fd.write("\nconst ARMOpcode ARMDisassembler::thumb_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "A":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = "ARMv7Decoder::" + instruction_to_name(instruction)
            fd.write("  { 0x%.8x, 0x%.8x, %s, %s, %s },\n" % (mask, value, version, encoding, decoder))
        
        fd.write("};\n")


    return True

decoder_header_h = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>

#include "ARMDisassembler.h"

using namespace Disassembler;
'''

decoder_header_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>

#include "ARMDisassembler.h"
#include "utilities/Utilities.h"

using namespace Disassembler;
'''

def get_input_vars(input):
    input_vars = []

    for var in input.split():
        if not "#" in var:
            continue

        name, size = var.split("#")
        size = int(size)

        input_vars.append((name, size))

    return input_vars

def __validate_bit_patterns__(bit_patterns):
    cnt = 0
    for bit_pattern in bit_patterns:
        if not "#" in bit_pattern:
            cnt += len(bit_pattern)
        else:
            cnt += int(bit_pattern.split("#")[1])

    return cnt == 32 or cnt == 16


def __translate_bit_patterns__(bit_patterns):
    # Make sure the input patterns are valid.
    if not __validate_bit_patterns__(bit_patterns):
        raise RuntimeError("Invalid bit patters: %r" % bit_patterns)

    ret = []

    i = 31
    for bit_pattern in bit_patterns:
        # print "Decoding bit pattern: %r" % bit_pattern

        # Skip regular bits.
        if not "#" in bit_pattern:
            # print "  Skipping bits from [%d-%d]" % (i, i - len(bit_pattern) + 1)
            i -= len(bit_pattern)

        else:
            name, size = bit_pattern.split("#")
            size = int(size)

            # print "  Extracting bits into %s from [%d-%d]" % (name, i, i - size + 1)
            if size == 1:
                ret.append("int %5s = get_bit(opcode, %2d);" % (name, i))
            else:
                ret.append("int %5s = get_bits(opcode, %2d, %2d);" % (name, i, i - size + 1))

            i -= size

    return ret

def indent(lines):
    t = ""
    for l in lines.split("\n"):
        t += "        %s\n" % l

    return t

def create_decoders(filename):
    import ARMv7Parser
    
    # Create the name of the header.
    header_name = os.path.splitext(filename)[0] + ".h"
    
    # Create the header file with all the declarations.
    with open(header_name, "w") as fd:
        fd.write(decoder_header_h)

        fd.write("\nnamespace ARMv7Decoder {\n")
        for instruction in instructions:
            fd.write("    Instruction %s(uint32_t opcode, ARMEncoding encoding);\n" % instruction_to_name(instruction))
    
        fd.write("};\n")

    # Create the implementation file.
    with open(filename, "w") as fd:
        fd.write(decoder_header_cpp)

        fd.write("\nnamespace ARMv7Decoder {\n")

        i = -1
        for instruction in instructions:
            i += 1
            input_vars = get_input_vars(instruction["pattern"])
            decoder = instruction["decoder"]
    
            if DEBUG:
                fd.write("    // Translating: %d -> %s %s %s\n" % (i, instruction["name"], instruction["encoding"], instruction["pattern"]))
                fd.write("    // Pseudocode:\n")
                for line in decoder.split("\n"):
                    for line2 in line.split(";"):
                        if not len(line2):
                            continue
                        fd.write("    // " + line2.strip() + "\n")
    
            logging.info("Processing instruction %d of %d" % (i, len(instructions)))
            fd.write("    Instruction %s(uint32_t opcode, ARMEncoding encoding) {\n" % instruction_to_name(instruction))        
            ret = __translate_bit_patterns__(instruction["pattern"].split())
            for r in ret:
                fd.write("        %s\n" % r)
            
            ret = ARMv7Parser.program.parseString(decoder, parseAll=True)
            visitor = ARMv7Parser.CPPTranslatorVisitor(input_vars)
    
            body = ""
            for ast in ret:
                l = visitor.accept(ast[0])
                body += indent(l)
                
                if type(ast[0]) == ARMv7Parser.ProcedureCall:
                    body = body[:-1] + ";\n"
    
            for var in visitor.define_me:
                fd.write("        int %s = 0;\n" % var)
            
            fd.write("\n")
            fd.write(body)
            
            fd.write("        Instruction ins;\n")
            fd.write("        return ins;\n")
            fd.write("    }\n\n")
            
            if i == 10:
                break
                        
        fd.write("};\n")
    
    return True

def main():
    logging.basicConfig(level=logging.INFO)
    
    parser = argparse.ArgumentParser(description='Generator.')
    parser.add_argument("--gendir", default="../gen", help="Directory where the generated files will be placed.")
    parser.add_argument("--table_name", default="ARMv7DecodingTable.cpp", help="File name of the decoding table.")
    parser.add_argument("--decoder_name", default="ARMv7Decoder.cpp", help="File name of the decoder.")
    parser.add_argument("--debug", default=False)
    
    args = parser.parse_args()

    DEBUG = args.debug    
    gen_dir = os.path.abspath(args.gendir)
    table_name = os.path.join(gen_dir, args.table_name)
    decoder_name = os.path.join(gen_dir, args.decoder_name)
    
    if not os.path.exists(gen_dir):
        logging.info("Directory '%s' does not exist, creating it ..." % gen_dir)
        os.makedirs(gen_dir)
        
    logging.info("Placing all the generated files in '%s'." % gen_dir)
        
    if os.path.exists(table_name):
        os.remove(table_name)
    
    if os.path.exists(decoder_name):
        os.remove(decoder_name)
    
    logging.info("Creating decoding table at '%s'." % table_name)
    logging.info("Creating decoder at '%s'." % decoder_name)
    
    if not create_decoding_table(table_name):
        logging.error("Could not create the decoding table.")
        return False
    
    if not create_decoders(decoder_name):
        logging.error("Could not create the decoders.")
        return False
    
    logging.info("Finished creating autogenerated stubs.")
    return True

if __name__ == '__main__':
    main()
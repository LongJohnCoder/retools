"""
This script generates both the decoder and the multiplexing tables
used for opcode disassembly.
"""
import argparse
import os
import re
import logging

from ARMv7DecodingSpec import instructions

DEBUG = False

def instruction_decoder_name(instruction):
    """
    Given an instruction with the format specified in ARMv7DecodingSpec.py
    output a unique name that represents that particular instruction decoder.
    """
    # Replace all the bad chars.
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])

    # Append the encoding.
    name += "_" + instruction["encoding"]

    # We may end up with double dashes, remove them.
    name = name.replace("__", "_")
    return "decode_" + name.lower()

def instruction_id_name(instruction):
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])
    name = name.replace("__", "_").lower()
    return name if name[-1] != "_" else name[:-1]

def get_size(input):
    s = 0
    for e in input.split():
        if not "#" in e:
            s += len(e)

        else:
            s += int(e.split("#")[1])

    return "eSize32" if s == 32 else "eSize16"

def get_value(input):
    r = "0b"
    for e in input.split():
        if not "#" in e:
            r += e

        else:
            r += "0" * int(e.split("#")[1])

    return int(r, 2)

def get_mask(input):
    r = "0b"
    for e in input.split():
        if not "#" in e:
            r += "1" * len(e)
        else:
            r += "0" * int(e.split("#")[1])

    return int(r, 2)

decoder_header_h = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>

#include "disassembly/arm/ARMDisassembler.h"

'''

decoder_header_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>

#include "disassembly/arm/ARMDisassembler.h"
#include "disassembly/arm/ARMUtilities.h"
#include "disassembly/arm/gen/ARMDecodingTable.h"
#include "disassembly/arm/gen/ARMtoString.h"
#include "disassembly/arm/gen/ARMtoStringCustom.h"
#include "utilities/Utilities.h"

using namespace Disassembler;

bool ARMDecoder::InITBlock() {
    return CurrentInstrSet() == InstrSet_Thumb && m_it_session.InITBlock();
}

bool ARMDecoder::LastInITBlock() {
    return CurrentInstrSet() == InstrSet_Thumb && m_it_session.LastInITBlock();
}

ARMMode ARMDecoder::CurrentInstrSet() {
    return m_opcode_mode;
}

bool ARMDecoder::CurrentModeIsHyp() {
    return m_hyp_mode;
}

ARMVariants ARMDecoder::ArchVersion() {
    return m_arm_isa;
}

'''

def get_input_vars(input):
    input_vars = []

    for var in input.split():
        if not "#" in var:
            continue

        name, size = var.split("#")
        size = int(size)

        input_vars.append((name, size))

    return input_vars

def __validate_bit_patterns__(bit_patterns):
    cnt = 0
    for bit_pattern in bit_patterns:
        if not "#" in bit_pattern:
            cnt += len(bit_pattern)
        else:
            cnt += int(bit_pattern.split("#")[1])

    return cnt == 32 or cnt == 16


def __translate_bit_patterns__(bit_patterns):
    # Make sure the input patterns are valid.
    if not __validate_bit_patterns__(bit_patterns):
        raise RuntimeError("Invalid bit patters: %r" % bit_patterns)

    ret = []

    i = 31
    for bit_pattern in bit_patterns:
        # print "Decoding bit pattern: %r" % bit_pattern

        # Skip regular bits.
        if not "#" in bit_pattern:
            # print "  Skipping bits from [%d-%d]" % (i, i - len(bit_pattern) + 1)
            i -= len(bit_pattern)

        else:
            name, size = bit_pattern.split("#")
            size = int(size)

            # print "  Extracting bits into %s from [%d-%d]" % (name, i, i - size + 1)
            if size == 1:
                ret.append("int %5s = get_bit(opcode, %2d);" % (name, i))
            else:
                ret.append("int %5s = get_bits(opcode, %2d, %2d);" % (name, i, i - size + 1))

            i -= size

    return ret

def indent(lines):
    t = ""
    for l in lines.split("\n"):
        t += "    %s\n" % l

    return t

def create_decoders(decoder_name_h, decoder_name_cpp):
    """
    Create the ARMDecoder.h and ARMDecoder.cpp.
    """
    import ARMv7Parser

    # Create the header file with all the declarations.
    with open(decoder_name_h, "w") as fd:
        fd.write(decoder_header_h)

        # Generate the instruction id enum.
        fd.write("typedef enum ARMInstructionId {\n")

        for instruction_id in sorted(set(map(instruction_id_name, instructions))):
            fd.write("    %s,\n" % instruction_id)

        fd.write("} ARMInstructionId;\n")
        fd.write("\n")
        fd.write("class ARMDecoder;\n")
        fd.write("typedef struct ARMOpcode {\n")
        fd.write("        uint32_t mask;\n")
        fd.write("        uint32_t value;\n")
        fd.write("        uint32_t variants;\n")
        fd.write("        Disassembler::ARMInstrSize ins_size;\n")
        fd.write("        Disassembler::ARMEncoding encoding;\n")
        fd.write("        Disassembler::ARMInstruction (ARMDecoder::*decoder)(uint32_t, Disassembler::ARMInstrSize ins_size, Disassembler::ARMEncoding);\n")
        fd.write("        const char *name;\n")
        fd.write("} ARMOpcode;\n")
        fd.write("\n")
        fd.write("extern ARMOpcode arm_opcodes[];\n")
        fd.write("extern ARMOpcode thumb_opcodes[];\n")
        fd.write("extern const size_t n_arm_opcodes;\n")
        fd.write("extern const size_t n_thumb_opcodes;\n")
        fd.write("\n")
        fd.write("class ARMDecoder {\n")
        fd.write("    public:\n")
        fd.write("        ARMDecoder(Disassembler::ARMVariants variant) :\n")
        fd.write("                m_opcode_mode(Disassembler::ARMMode_Invalid), m_arm_isa(variant) {\n")
        fd.write("        }\n")
        fd.write("\n")
        fd.write("        Disassembler::ARMInstruction decode(uint32_t op_code, Disassembler::ARMMode mode) {\n")
        fd.write("            ARMOpcode *opcode = (mode == Disassembler::ARMMode_ARM) ? decode_arm(op_code) : decode_thumb(op_code);\n")
        fd.write("            m_opcode_mode = mode;\n");
        fd.write("            return (this->*opcode->decoder)(op_code, opcode->ins_size, opcode->encoding);\n")
        fd.write("        }\n")
        fd.write("\n")
        fd.write("    private:\n")
        fd.write("        bool IsZero(unsigned i) { return i == 0; };\n")
        fd.write("        bool InITBlock();\n")
        fd.write("        bool LastInITBlock();\n")
        fd.write("        bool CurrentModeIsHyp();\n")
        fd.write("        Disassembler::ARMMode CurrentInstrSet();\n")
        fd.write("        Disassembler::ARMVariants ArchVersion();\n")
        fd.write("\n")
        fd.write("        // Fields:\n")
        fd.write("        bool m_hyp_mode;\n")
        fd.write("        Disassembler::ITSession m_it_session;\n")
        fd.write("        Disassembler::ARMMode m_opcode_mode;\n")
        fd.write("        Disassembler::ARMVariants m_arm_isa;\n")
        fd.write("        Disassembler::apsr_t APSR;\n")
        fd.write("        Disassembler::fpscr_t FPSCR;\n")
        fd.write("\n")
        fd.write("        ARMOpcode *decode_arm(uint32_t opcode);\n")
        fd.write("        ARMOpcode *decode_thumb(uint32_t opcode);\n")
        fd.write("\n")
        fd.write("    public:\n")

        for instruction in instructions:
            fd.write("        Disassembler::ARMInstruction %s(uint32_t opcode, Disassembler::ARMInstrSize ins_size, Disassembler::ARMEncoding encoding);\n" % instruction_decoder_name(instruction))

        fd.write("        Disassembler::ARMInstruction decode_unknown(uint32_t opcode, Disassembler::ARMInstrSize ins_size, Disassembler::ARMEncoding encoding);\n")
        fd.write("};\n")

    # Create the implementation file.
    with open(decoder_name_cpp, "w") as fd:
        fd.write(decoder_header_cpp)

        fd.write("// Format: (mask, value, version, encoding, decoder_function, name)\n")
        fd.write("ARMOpcode arm_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "T":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = instruction_decoder_name(instruction)
            size = get_size(instruction["pattern"])
            name = instruction["name"]
            fd.write("    { 0x%.8x, 0x%.8x, %s, %s, %s, &ARMDecoder::%s, \"%s\"},\n" % (mask, value, version, size, encoding, decoder, name))

        fd.write("    {0x00000000, 0x00000000, ARMvAll, eSize32, eEncodingA1, &ARMDecoder::decode_unknown, \"UNKNOWN\"}\n")

        fd.write("};\n")
        fd.write("\n")
        fd.write("const size_t n_arm_opcodes = sizeof(arm_opcodes) / sizeof(arm_opcodes[0]);\n")
        fd.write("ARMOpcode *ARMDecoder::decode_arm(uint32_t opcode) {\n")
        fd.write("    for (size_t i = 0; i < n_arm_opcodes; ++i) {\n")
        fd.write("        if ((arm_opcodes[i].mask & opcode) == arm_opcodes[i].value && (arm_opcodes[i].variants & m_arm_isa) != 0)\n")
        fd.write("            return &arm_opcodes[i];\n")
        fd.write("    }\n\n")
        fd.write("    return NULL;\n")
        fd.write("}\n")
        fd.write("\n")
        fd.write("ARMOpcode thumb_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "A":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = instruction_decoder_name(instruction)
            size = get_size(instruction["pattern"])
            name = instruction["name"]
            fd.write("    { 0x%.8x, 0x%.8x, %s, %s, %s, &ARMDecoder::%s, \"%s\"},\n" % (mask, value, version, size, encoding, decoder, name))

        fd.write("    {0x00000000, 0x00000000, ARMvAll, eSize32, eEncodingA1, &ARMDecoder::decode_unknown, \"UNKNOWN\"}\n")
        fd.write("};\n")
        fd.write("\n")

        fd.write("ARMInstruction ARMDecoder::decode_unknown(uint32_t opcode, Disassembler::ARMInstrSize ins_size, ARMEncoding encoding) {\n")
        fd.write("    return UnknownInstruction();\n")
        fd.write("}\n")
        fd.write("\n")

        fd.write("const size_t n_thumb_opcodes = sizeof(thumb_opcodes) / sizeof(thumb_opcodes[0]);\n")
        fd.write("ARMOpcode *ARMDecoder::decode_thumb(uint32_t opcode) {\n")
        fd.write("    for (size_t i = 0; i < n_thumb_opcodes; ++i) {\n")
        fd.write("        if ((thumb_opcodes[i].mask & opcode) == thumb_opcodes[i].value && (thumb_opcodes[i].variants & m_arm_isa) != 0)\n")
        fd.write("            return &thumb_opcodes[i];\n")
        fd.write("    }\n\n")
        fd.write("    return NULL;\n")
        fd.write("}\n\n")

        i = -1
        for instruction in instructions:
            i += 1

            input_vars = get_input_vars(instruction["pattern"])
            decoder = instruction["decoder"]

            if DEBUG:
                fd.write("// Translating: %d -> %s %s %s\n" % (i, instruction["name"], instruction["encoding"], instruction["pattern"]))
                fd.write("// Pseudocode:\n")
                for line in decoder.split("\n"):
                    for line2 in line.split(";"):
                        if not len(line2):
                            continue
                        fd.write("// " + line2.strip() + "\n")

            if i % 50 == 0:
                logging.info("Processing instruction %.4d of %.4d" % (i, len(instructions)))

            decoder_name = instruction_decoder_name(instruction)
            fd.write("ARMInstruction ARMDecoder::%s(uint32_t opcode, Disassembler::ARMInstrSize ins_size, ARMEncoding encoding) {\n" % decoder_name)
            ret = __translate_bit_patterns__(instruction["pattern"].split())
            for r in ret:
                fd.write("    %s\n" % r)

            ret = ARMv7Parser.program.parseString(decoder, parseAll=True)
            visitor = ARMv7Parser.CPPTranslatorVisitor(input_vars, decoder_name, instruction)

            body = ""
            for ast in ret:
                l = visitor.accept(ast[0])
                body += indent(l)

                if type(ast[0]) == ARMv7Parser.ProcedureCall:
                    body = body[:-1] + ";\n"

            for var in visitor.define_me:
                fd.write("    int %s = 0;\n" % var)

            fd.write("\n")
            fd.write(body)

            # All the variables defined in the body end up in the instruction.
            fd.write("    ARMInstruction ins = ARMInstruction::create();\n")
            fd.write("    ins.ins_size = ins_size;\n")
            fd.write("    ins.id = %s;\n" % instruction_id_name(instruction))
            fd.write("    ins.m_to_string = %s_to_string;\n" % instruction_decoder_name(instruction))
            for var in visitor.define_me:
                fd.write("    ins.%s = %s;\n" % (var, var))

            # Here we hard code some variables that are not defined in the body but need to go into the instruction.
            hard = ["cond", "coproc", "opc1", "CRd", "CRn", "CRm", "opc2", "option", "D", "W", "B", "P", "U", "op", "imm3", "imm6"]
            for var in input_vars:
                if var[0] in hard:
                    fd.write("    ins.%s = %s;\n" % (var[0], var[0]))

            fd.write("\n")

            fd.write("    return ins;\n")
            fd.write("}\n\n")

    return True

to_string_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <string>
#include <cstdlib>
#include <cstdio>

#include "disassembly/arm/ARMDisassembler.h"
#include "disassembly/arm/gen/ARMDecodingTable.h"
#include "utilities/Utilities.h"

using namespace Disassembler;

std::string effect_str(const ARMInstruction *ins) {
    return ins->enable ? "IE" : "ID";
}

std::string amode_str(const ARMInstruction *ins) {
    if (ins->P == 0 && ins->U == 0) return "DA";
    else if (ins->P == 1 && ins->U == 0) return "DB";
    else if (ins->P == 0 && ins->U == 1) return "IA";
    else if (ins->P == 1 && ins->U == 1) return "IB";
    return "INVALID";
}

std::string IA_str(const ARMInstruction *ins) {
    return "IA";
}

std::string S_str(const ARMInstruction *ins) {
    return ins->setflags ? "S" : "";
}

std::string c_str(const ARMInstruction *ins) {
    return ins->cond != COND_AL ? ARMCondCodeToString((cond_t) ins->cond) : "";
}

std::string B_str(const ARMInstruction *ins) {
    return ins->B ? "B" : "";
}

std::string N_str(const ARMInstruction *ins) {
    return ins->nonzero ? "N" : "";
}

std::string W_str(const ARMInstruction *ins) {
    return ins->is_pldw ? "W" : "";
}

std::string x_str(const ARMInstruction *ins) {
    return ins->n_high ? "T" : "B";
}

std::string y_str(const ARMInstruction *ins) {
    return ins->m_high ? "T" : "B";
}

std::string X_str(const ARMInstruction *ins) {
    return ins->m_swap ? "X" : "";
}

std::string R_str(const ARMInstruction *ins) {
    return ins->round ? "R" : "";
}

std::string mode_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vldm: // VLDM
        case vstm: // VSTM
            if (ins->P == 0 && ins->U == 1)
                return "IA";

            if (ins->P == 1 && ins->U == 0)
                return "DB";

            break;
        default:
            break;
    }

    return "INVALID";
}

std::string op_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vpmax_vpmin_floating_point: // VPMAX, VPMIN (floating-point)
        case vpmax_vpmin_integer: // VPMAX, VPMIN (integer)
            return ins->op ? "MIN" : "MAX";
        case vqdmlal_vqdmlsl: // VQDMLAL, VQDMLSL
            return ins->op ? "MLSL" : "MLAL";
        case vtbl_vtbx: // VTBL, VTBX
            return ins->op ? "X" : "L";

        default:
            break;
    }

    return "INVALID";
}

std::string dt_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vaba_vabal: // VABA, VABAL
        case vabd_vabdl_integer: // VABD, VABDL (integer)
            if (ins->size == 0 && ins->U == 0)
                return "S8";
            else if (ins->size == 0 && ins->U == 0)
                return "S8";
            else if (ins->size == 1 && ins->U == 0)
                return "S16";
            else if (ins->size == 2 && ins->U == 0)
                return "S32";
            else if (ins->size == 0 && ins->U == 1)
                return "U8";
            else if (ins->size == 1 && ins->U == 1)
                return "U16";
            else if (ins->size == 2 && ins->U == 1)
                return "U32";

            break;
        case vaddhn: // VADDHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vmov_scalar_to_arm_core_register: // VMOV (scalar to ARM core register)
            if (ins->U == 0 && get_bit(ins->opc1, 1) == 1)
                return "S8";
            else if (ins->U == 0 && get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "S16";
            else if (ins->U == 1 && get_bit(ins->opc1, 1) == 1)
                return "U8";
            else if (ins->U == 1 && get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "U16";
            else if (ins->U == 0 && get_bit(ins->opc1, 1) == 0 && ins->opc2 == 0)
                return "32";

            break;
        case vmovl: // VMOVL
            if (ins->U == 0 && ins->imm3 == 1)
                return "S8";
            else if (ins->U == 0 && ins->imm3 == 2)
                return "S16";
            else if (ins->U == 0 && ins->imm3 == 3)
                return "S32";
            else if (ins->U == 1 && ins->imm3 == 1)
                return "u8";
            else if (ins->U == 1 && ins->imm3 == 2)
                return "U16";
            else if (ins->U == 1 && ins->imm3 == 3)
                return "U32";

            break;
        case vmovn: // VMOVN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vmul_vmull_by_scalar: // VMUL, VMULL (by scalar)
        case vmul_vmull_integer_and_polynomial: // VMUL, VMULL (integer and polynomial)
        case vpadd_integer: // VPADD (integer)
            switch (ins->size) {
                case 0:
                    return "I8";
                case 1:
                    return "I16";
                case 2:
                    return "I32";
                default:
                    break;
            }

            break;
        case vpmax_vpmin_integer: // VPMAX, VPMIN (integer)
        case vqdmlal_vqdmlsl: // VQDMLAL, VQDMLSL
        case vqdmull: // VQDMULL
            switch (ins->size) {
                case 1:
                    return "S16";
                case 2:
                    return "S32";
                default:
                    break;
            }

            break;
        case vraddhn: // VRADDHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vrsubhn: // VRSUBHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vsubhn: // VSUBHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        default:
            break;
    }

    return "INVALID";
}

std::string U_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            return ins->op == 1 ? "U" : "";
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
            return ins->U == 1 ? "U" : "";

        default:
            break;
    }

    return "INVALID";
}
std::string size_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vmov_arm_core_register_to_scalar: // VMOV (ARM core register to scalar)
            if (get_bit(ins->opc1, 1) == 1)
                return "8";

            else if (get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "16";

            else if (get_bit(ins->opc1, 1) == 0 && ins->opc2 == 0)
                return "32";

            break;
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            if (ins->size == 0)
                return "16";

            else if (ins->size == 1)
                return "32";

            else if (ins->size == 2)
                return "64";

            break;
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
        case vrshrn: // VRSHRN
        case vshll: // VSHLL
        case vshrn: // VSHRN
            if (get_bits(ins->imm6, 5, 3) == 1)
                return "16";

            else if (get_bits(ins->imm6, 5, 4) == 1)
                return "32";

            else if (get_bit(ins->imm6, 5) == 1)
                return "64";

            break;
        default:
            break;
    }

    return "INVALID";
}

std::string type_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            if (ins->op == 1 || ins->op == 2)
                return "S";

            if (ins->op == 3)
                return "U";

            break;
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
            if (ins->U == 0 && ins->op == 1)
                return "S";

            if (ins->U == 1 && ins->op == 0)
                return "S";

            if (ins->U == 1 && ins->op == 1)
                return "U";

            break;
        case vshll: // VSHLL
            if (ins->encoding == eEncodingT2 || ins->encoding == eEncodingA2) {
                if (ins->U == 0)
                    return "S";

                if (ins->U == 1)
                    return "U";
            } else if (ins->encoding == eEncodingT2 || ins->encoding == eEncodingA2) {
                return "I";
            }

            break;

        default:
            break;
    }

    return "INVALID";
}

std::string regular_reg_str(unsigned reg) {
    switch (reg) {
        case 0:
            return "r0";
        case 1:
            return "r1";
        case 2:
            return "r2";
        case 3:
            return "r3";
        case 4:
            return "r4";
        case 5:
            return "r5";
        case 6:
            return "r6";
        case 7:
            return "r7";
        case 8:
            return "r8";
        case 9:
            return "r9";
        case 10:
            return "r10";
        case 11:
            return "r11";
        case 12:
            return "r12";
        case 13:
            return "sp";
        case 14:
            return "lr";
        case 15:
            return "pc";
        default:
            break;
    }

    return "INVALID";
}

std::string coproc_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "p0";
        case 1:
            return "p1";
        case 2:
            return "p2";
        case 3:
            return "p3";
        case 4:
            return "p4";
        case 5:
            return "p5";
        case 6:
            return "p6";
        case 7:
            return "p7";
        case 8:
            return "p8";
        case 9:
            return "p9";
        case 10:
            return "p10";
        case 11:
            return "p11";
        case 12:
            return "p12";
        case 13:
            return "p13";
        case 14:
            return "p14";
        case 15:
            return "p15";
        default:
            break;
    }

    return "INVALID";
}

std::string shift_type_str(unsigned shift) {
    switch (shift) {
        case 0:
            return "LSL";
        case 1:
            return "LSR";
        case 2:
            return "ASR";
        case 3:
            return "ROR";
        case 4:
            return "RRX";
        default:
            break;
    }

    return "INVALID";
}

std::string coproc_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "c0";
        case 1:
            return "c1";
        case 2:
            return "c2";
        case 3:
            return "c3";
        case 4:
            return "c4";
        case 5:
            return "c5";
        case 6:
            return "c6";
        case 7:
            return "c7";
        case 8:
            return "c8";
        case 9:
            return "c9";
        case 10:
            return "c10";
        case 11:
            return "c11";
        case 12:
            return "c12";
        case 13:
            return "c13";
        case 14:
            return "c14";
        case 15:
            return "c15";
        default:
            break;
    }

    return "INVALID";
}

std::string quad_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "q0";
        case 1:
            return "q1";
        case 2:
            return "q2";
        case 3:
            return "q3";
        case 4:
            return "q4";
        case 5:
            return "q5";
        case 6:
            return "q6";
        case 7:
            return "q7";
        case 8:
            return "q8";
        case 9:
            return "q9";
        case 10:
            return "q10";
        case 11:
            return "q11";
        case 12:
            return "q12";
        case 13:
            return "q13";
        case 14:
            return "q14";
        case 15:
            return "q15";
        default:
            break;
    }

    return "INVALID";
}

std::string double_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "d0";
        case 1:
            return "d1";
        case 2:
            return "d2";
        case 3:
            return "d3";
        case 4:
            return "d4";
        case 5:
            return "d5";
        case 6:
            return "d6";
        case 7:
            return "d7";
        case 8:
            return "d8";
        case 9:
            return "d9";
        case 10:
            return "d10";
        case 11:
            return "d11";
        case 12:
            return "d12";
        case 13:
            return "d13";
        case 14:
            return "d14";
        case 15:
            return "d15";
        case 16:
            return "d16";
        case 17:
            return "d17";
        case 18:
            return "d18";
        case 19:
            return "d19";
        case 20:
            return "d20";
        case 21:
            return "d21";
        case 22:
            return "d22";
        case 23:
            return "d23";
        case 24:
            return "d24";
        case 25:
            return "d25";
        case 26:
            return "d26";
        case 27:
            return "d27";
        case 28:
            return "d28";
        case 29:
            return "d29";
        case 30:
            return "d30";
        case 31:
            return "d31";
        default:
            break;
    }

    return "INVALID";
}

std::string simple_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "s0";
        case 1:
            return "s1";
        case 2:
            return "s2";
        case 3:
            return "s3";
        case 4:
            return "s4";
        case 5:
            return "s5";
        case 6:
            return "s6";
        case 7:
            return "s7";
        case 8:
            return "s8";
        case 9:
            return "s9";
        case 10:
            return "s10";
        case 11:
            return "s11";
        case 12:
            return "s12";
        case 13:
            return "s13";
        case 14:
            return "s14";
        case 15:
            return "s15";
        case 16:
            return "s16";
        case 17:
            return "s17";
        case 18:
            return "s18";
        case 19:
            return "s19";
        case 20:
            return "s20";
        case 21:
            return "s21";
        case 22:
            return "s22";
        case 23:
            return "s23";
        case 24:
            return "s24";
        case 25:
            return "s25";
        case 26:
            return "s26";
        case 27:
            return "s27";
        case 28:
            return "s28";
        case 29:
            return "s29";
        case 30:
            return "s30";
        case 31:
            return "s31";
        default:
            break;
    }

    return "INVALID";
}

std::string option_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case dbg:
            return integer_to_string(ins->option);
        case dmb:
        case dsb:
            if (ins->option == 15)
                return "SY";
            else if (ins->option == 14)
                return "ST";
            else if (ins->option == 11)
                return "ISH";
            else if (ins->option == 10)
                return "ISHST";
            else if (ins->option == 7)
                return "NSH";
            else if (ins->option == 6)
                return "NSHST";
            else if (ins->option == 3)
                return "OSH";
            else if (ins->option == 2)
                return "OSHST";
            break;
        case isb:
            if (ins->option == 15)
                return "SY";
            break;
        case ldc_ldc2_immediate:
        case ldc_ldc2_literal:
            return "{" + std::to_string(ins->imm32) + "}";
        default:
            break;
    }

    return "INVALID";
}

std::string endian_specifier_str(unsigned endian) {
    return endian ? "BE" : "LE";
}

std::string spec_reg_str() {
    return "APSR";
}

std::string registers_str(unsigned registers) {
    std::string regs;
    bool f = false;
    for (unsigned i = 0; i < 32; i++) {
        if (get_bit(registers, i)) {
            regs += i && f ? ", " : "";
            f = true;
            regs += std::string(regular_reg_str(i));
        }
    }

    return "{" + regs + "}";
}

std::string shift_str(unsigned shift_t, unsigned shift_n) {
    if (shift_t == Disassembler::SRType_RRX && shift_n == 1)
        return std::string(shift_type_str(shift_t));

    std::string shift = std::string(shift_type_str(shift_t)) + " #" + integer_to_string(shift_n);
    return shift;
}

std::string rotation_str(unsigned rotation) {
    switch(rotation) {
        case 0:
            return "";
        case 8:
            return "ROR #8";
        case 16:
            return "ROR #16";
        case 24:
            return "ROR #24";
    }

    return "INVALID";
}

'''

to_string_h = '''// Warning! autogenerated file, do what you want.
#include <string>
#include "disassembly/arm/ARMDisassembler.h"

std::string S_str(const Disassembler::ARMInstruction *ins);
std::string c_str(const Disassembler::ARMInstruction *ins);
std::string B_str(const Disassembler::ARMInstruction *ins);
std::string N_str(const Disassembler::ARMInstruction *ins);
std::string W_str(const Disassembler::ARMInstruction *ins);
std::string x_str(const Disassembler::ARMInstruction *ins);
std::string y_str(const Disassembler::ARMInstruction *ins);
std::string X_str(const Disassembler::ARMInstruction *ins);
std::string R_str(const Disassembler::ARMInstruction *ins);
std::string mode_str(const Disassembler::ARMInstruction *ins);
std::string op_str(const Disassembler::ARMInstruction *ins);
std::string dt_str(const Disassembler::ARMInstruction *ins);
std::string U_str(const Disassembler::ARMInstruction *ins);
std::string size_str(const Disassembler::ARMInstruction *ins);
std::string type_str(const Disassembler::ARMInstruction *ins);
std::string regular_reg_str(unsigned reg);
std::string coproc_str(unsigned coproc);
std::string shift_type_str(unsigned shift);
std::string coproc_reg_str(unsigned coproc);
std::string quad_reg_str(unsigned coproc);
std::string double_reg_str(unsigned coproc);
std::string simple_reg_str(unsigned coproc);
std::string option_str(const Disassembler::ARMInstruction *ins);
std::string endian_specifier_str(unsigned endian);
std::string spec_reg_str();
std::string registers_str(unsigned registers);
std::string shift_str(unsigned shift_t, unsigned shift_n);
std::string rotation_str(unsigned rotation);

'''
def create_to_string(to_string_name_h, to_string_name_cpp):
    import ARMv7Parser
    parser = ARMv7Parser.InstructionFormatParser()
    names = set()

    reg2string = {}
    reg2string["Ra"] = "regular_reg_str(ins->a).c_str()"
    reg2string["Rd"] = "regular_reg_str(ins->d).c_str()"
    reg2string["RdHi"] = "regular_reg_str(ins->dHi).c_str()"
    reg2string["RdLo"] = "regular_reg_str(ins->dLo).c_str()"
    reg2string["Rdm"] = "regular_reg_str(ins->d).c_str()"
    reg2string["Rdn"] = "regular_reg_str(ins->d).c_str()"
    reg2string["Rm"] = "regular_reg_str(ins->m).c_str()"
    reg2string["Rn"] = "regular_reg_str(ins->n).c_str()"
    reg2string["Rs"] = "regular_reg_str(ins->s).c_str()"
    reg2string["Rt"] = "regular_reg_str(ins->t).c_str()"
    reg2string["Rt2"] = "regular_reg_str(ins->t2).c_str()"

    # TODO: Review these. I think we are doing it wrong here.
    reg2string["imm"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm2"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm3"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm4"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm5"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm8"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm12"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm16"] = "integer_to_string(ins->imm16).c_str()"
    reg2string["imm24"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm32"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["shift_n"] = "integer_to_string(ins->shift_n).c_str()"
    reg2string["saturate_to"] = "integer_to_string(ins->saturate_to).c_str()"
    reg2string["const"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["label"] = "integer_to_string(ins->imm32 + ((ins->ins_size == eSize16) ? 4 : 8)).c_str()"

    reg2string["lsb"] = "integer_to_string(ins->lsbit).c_str()"
    reg2string["width"] = "integer_to_string(ins->msbit - ins->lsbit + 1).c_str()"
    reg2string["widthminus1"] = "integer_to_string(ins->widthminus1 + 1).c_str()"

    reg2string["type"] = "shift_type_str(ins->shift_t).c_str()"
    reg2string["coproc"] = "coproc_str(ins->coproc).c_str()"
    reg2string["opc1"] = "integer_to_string(ins->opc1).c_str()"
    reg2string["opc2"] = "integer_to_string(ins->opc2).c_str()"

    reg2string["CRd"] = "coproc_reg_str(ins->CRd).c_str()"
    reg2string["CRn"] = "coproc_reg_str(ins->CRn).c_str()"
    reg2string["CRm"] = "coproc_reg_str(ins->CRm).c_str()"

    reg2string["option"] = "option_str(ins).c_str()"
    reg2string["registers"] = "registers_str(ins->registers).c_str()"
    reg2string["spec_reg"] = "spec_reg_str().c_str()"
    reg2string["endian_specifier"] = "endian_specifier_str(ins->set_bigend).c_str()"

    reg2string["Qd"] = "quad_reg_str(ins->d).c_str()"
    reg2string["Qn"] = "quad_reg_str(ins->n).c_str()"
    reg2string["Qm"] = "quad_reg_str(ins->m).c_str()"

    reg2string["Dd"] = "double_reg_str(ins->d).c_str()"
    reg2string["Dn"] = "double_reg_str(ins->n).c_str()"
    reg2string["Dm"] = "double_reg_str(ins->m).c_str()"

    reg2string["Sd"] = "simple_reg_str(ins->d).c_str()"
    reg2string["Sn"] = "simple_reg_str(ins->n).c_str()"
    reg2string["Sm"] = "simple_reg_str(ins->m).c_str()"

    reg2string["shift"] = "shift_str(ins->shift_t, ins->shift_n).c_str()"
    reg2string["rotation"] = "rotation_str(ins->rotation).c_str()"

    # TODO: Implement these:
    reg2string["list"] = "\"TODO_LIST\""
    reg2string["Dd[x]"] = "\"TODO_Dd[x]\""
    reg2string["Dn[x]"] = "\"TODO_Dn[x]\""
    reg2string["Dm[x]"] = "\"TODO_Dm[x]\""
    reg2string["iflags"] = "\"TODO_iflags\""
    reg2string["mode"] = "\"TODO_mode\""
    reg2string["registers_with_pc"] = "\"TODO_registers_with_pc\""
    reg2string["registers_without_pc"] = "\"TODO_registers_without_pc\""
    reg2string["banked_reg"] = "\"TODO_banked_reg\""

    # Create the implementation file.
    with open(to_string_name_cpp, "w") as fd:
        fd.write(to_string_cpp)

        s = set()

        for instruction in instructions:
            # Skip the custom ones as they are handled in 'create_to_string_custom'.
            if "CUSTOM" == instruction["format"]:
                continue

            # TODO: Handle the case when an instruction is inside an IT block.
            format = instruction["format"]
            if ":" in format:
                format = format.split(":")[0]

            # Parse the toString format.
            r = parser.parseString(format)

            # We divide the instruction in two pices, the name and the arguments.
            op_name = r[0]
            op_args = ARMv7Parser.MandatoryToken("")
            if len(r) == 2:
                op_args = r[1]

            # Write the header with the common structures.
            fd.write("std::string %s_to_string(const ARMInstruction *ins) {\n" % instruction_decoder_name(instruction))
            fd.write("    char op_name[64], op_args[64];\n")
            fd.write("    // DEBUG: %s\n" % format)
            fd.write("    int ret = snprintf(op_name, sizeof(op_name),\n")
            fd.write("            \"%s%s\"" % (op_name.name[0], "%s" * (len(op_name.name) - 1)))

            # Skip the last comma if the name has no variable pieces.
            if len(op_name.name[1:]) != 0:
                fd.write(",")
            fd.write("\n")

            # For each of the name's variables.
            for i, val in enumerate(op_name.name[1:]):
                if type(val) is ARMv7Parser.OptionalToken:
                    assert len(val.name) == 1
                    fd.write("            %s_str(ins).c_str()" % str(val.name[0]))

                    # Whenever we change the ARMv7DecodingSpec.py we need to re-enble this and fix stuff.
                    # if not str(val) in ["<c>", "{S}"]:
                    #    print val, "case %s:" % instruction_id_name(instruction), "//", instruction["name"]

                elif type(val) is ARMv7Parser.MandatoryToken:
                    fd.write("            %s_str(ins).c_str()" % str(val.name))

                    # Whenever we change the ARMv7DecodingSpec.py we need to re-enble this and fix stuff.
                    # if not str(val) in ["<c>", "{S}"]:
                    #    print val, "case %s:" % instruction_id_name(instruction), "//", instruction["name"]

                else:
                    fd.write("            \"%s\"" % val)

                if i != len(op_name.name[1:]) - 1:
                    fd.write(",")

                fd.write("\n")

            fd.write("    );\n\n")
            fd.write("    assert(ret >= 0);\n")

            # Skip the rest if there are no arguments to the instruction.
            if not len(op_args.name):
                fd.write("    return std::string(op_name);\n")
                fd.write("}\n\n")
                continue

            fd.write("    ret = snprintf(op_args, sizeof(op_args),\n")

            format_string = ""
            vars = []
            for i, val in enumerate(op_args.name):
                if type(val) is ARMv7Parser.MandatoryToken:
                    if val.pound:
                        format_string += val.pound

                    # Add the format string for the sign if needed.
                    if val.sign == "+/-":
                        format_string += "%s"
                        vars.append("ins->add ? \"\" : \"-\"")

                    else:
                        format_string += val.sign

                    format_string += "%s"
                    vars.append(reg2string[val.name])

                elif type(val) is ARMv7Parser.OptionalToken:
                    for optional in val.name:
                        # If the token is the write back optional emit the corresponding code.
                        if type(optional) == type(""):
                            # The only string that is optional given an ins is the writeback sign.
                            if optional == "!":
                                format_string += "%s"
                                vars.append("ins->wback ? \"!\" : \"\"")

                            else:
                                format_string += optional
                        else:
                            if optional.pound == "#":
                                format_string += "#"

                            if optional.sign == "-":
                                format_string += "-"

                            elif optional.sign == "+/-":
                                format_string += "%s"
                                vars.append("ins->add ? \"\" : \"-\"")

                            format_string += "%s"
                            vars.append(reg2string[optional.name])

                else:
                    format_string += val

            fd.write("            \"%s\",\n" % format_string)

            for i, var in enumerate(vars):
                fd.write("            %s" % var)
                if i < len(vars) - 1:
                    fd.write(",")

                fd.write("\n")

            fd.write("    );\n\n")
            fd.write("    assert(ret >= 0);\n")
            fd.write("    return std::string(op_name) + std::string(op_args);\n")
            fd.write("}\n\n")

    # Create the header file.
    with open(to_string_name_h, "w") as fd:
        fd.write(to_string_h)

        for instruction in instructions:
            if "CUSTOM" == instruction["format"].split()[0]:
                continue

            fd.write("std::string %s_to_string(const Disassembler::ARMInstruction *ins);\n" % instruction_decoder_name(instruction))

    return True

to_string_custom_h = '''// Warning! autogenerated file, do what you want.
#include <string>
#include "disassembly/arm/ARMDisassembler.h"

'''

to_string_custom_cpp = '''// Warning! autogenerated file, do what you want.
#include <string>
#include <cstdlib>
#include <cstdio>

#include "disassembly/arm/ARMDisassembler.h"
#include "disassembly/arm/gen/ARMDecodingTable.h"
#include "disassembly/arm/gen/ARMtoString.h"
#include "disassembly/arm/gen/ARMtoStringCustom.h"
#include "utilities/Utilities.h"

using namespace Disassembler;

'''
def create_to_string_custom(to_string_custom_name_h, to_string_custom_name_cpp):
    # Create the header file.
    with open(to_string_custom_name_h, "w") as fd:
        fd.write(to_string_custom_h)

        for instruction in filter(lambda x: x["format"] == "CUSTOM", instructions):
            fd.write("std::string %s_to_string(const Disassembler::ARMInstruction *ins);\n" % instruction_decoder_name(instruction))

    # Create the implementation file.
    with open(to_string_custom_name_cpp, "w") as fd:
        fd.write(to_string_custom_cpp)

        s = set()

        for instruction in filter(lambda x: x["format"] == "CUSTOM", instructions):
            fd.write("// Instruction: %s\n// Encoding: %s\n" % (instruction["name"], instruction["encoding"]))
            fd.write("std::string %s_to_string(const Disassembler::ARMInstruction *ins) {\n" % instruction_decoder_name(instruction))
            fd.write("    char buffer[64];\n")
            fd.write("    int ret = snprintf(buffer, sizeof(buffer), \"TODO_%s_%s\");\n" % (instruction_id_name(instruction), instruction["encoding"]))
            fd.write("    assert(ret >= 0);\n")
            fd.write("\n")
            fd.write("    return std::string(buffer);\n")
            fd.write("}\n")
            fd.write("\n")

    return True

def backup_file(path):
    import time
    import shutil
    backup_name = "%s_%s.bak" % (path, time.strftime("%Y%m%d"))
    shutil.copyfile(path, backup_name)
    return backup_name

def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(description='Generator.')
    parser.add_argument("--gendir", default="../gen", help="Directory where the generated files will be placed.")
    parser.add_argument("--gen_custom_to_str", action='store_true', help="Generate ARMtoStringCustom[.h|.cpp] stubs")
    parser.add_argument("--gen_to_str", action='store_true', help="Generate ARMtoString[.h|.cpp] stubs")
    parser.add_argument("--gen_decoder", action='store_true', help="Generate ARMDecodingTable[.h|.cpp]")
    parser.add_argument("--debug", action='store_true', help="Enable debugging information, just for developers.")

    args = parser.parse_args()

    DEBUG = args.debug
    gen_custom_to_string = args.gen_custom_to_str
    gen_to_string = args.gen_to_str
    gen_decoder = args.gen_decoder

    if not any([gen_custom_to_string, gen_to_string, gen_decoder]):
        logging.warn("Nothing to generate, please choose one option")
        parser.print_help()
        return

    # Filenames and path's.
    gen_dir = os.path.abspath(args.gendir)
    decoder_name_h = os.path.join(gen_dir, "ARMDecodingTable.h")
    decoder_name_cpp = os.path.join(gen_dir, "ARMDecodingTable.cpp")
    to_string_name_h = os.path.join(gen_dir, "ARMtoString.h")
    to_string_name_cpp = os.path.join(gen_dir, "ARMtoString.cpp")
    to_string_custom_name_h = os.path.join(gen_dir, "ARMtoStringCustom.h")
    to_string_custom_name_cpp = os.path.join(gen_dir, "ARMtoStringCustom.cpp")

    if not os.path.exists(gen_dir):
        logging.info("Directory '%s' does not exist, creating it ..." % gen_dir)
        os.makedirs(gen_dir)

    logging.info("Placing all the generated files in '%s'." % gen_dir)

    # We've chosen to regenerate the custom to_string placeholders.
    if gen_custom_to_string:
        if os.path.exists(to_string_custom_name_h):
            backup_name = backup_file(to_string_custom_name_h)
            logging.info("File (%s) exists, I'll backup it to %s." % (to_string_custom_name_h, backup_name))
            os.remove(to_string_custom_name_h)

        if os.path.exists(to_string_custom_name_cpp):
            backup_name = backup_file(to_string_custom_name_cpp)
            logging.info("File (%s) exists, I'll backup it to %s." % (to_string_custom_name_cpp, backup_name))
            os.remove(to_string_custom_name_cpp)

        logging.info("Creating ARMtoStringCustom.h at '%s'." % to_string_custom_name_h)
        logging.info("Creating ARMtoStringCustom.cpp at '%s'." % to_string_custom_name_cpp)
        if not create_to_string_custom(to_string_custom_name_h, to_string_custom_name_cpp):
            logging.error("Could not create custom to_string stubs.")
            return False


    # We've chosen to regenerate the decoders.
    if gen_decoder:
        if os.path.exists(decoder_name_h):
            os.remove(decoder_name_h)

        if os.path.exists(decoder_name_cpp):
            os.remove(decoder_name_cpp)

        logging.info("Creating decoders at '%s'." % decoder_name_h)
        logging.info("Creating decoders at '%s'." % decoder_name_cpp)
        if not create_decoders(decoder_name_h, decoder_name_cpp):
            logging.error("Could not create the decoders.")
            return False

    # Regenerate the to_string methods.
    if gen_to_string:
        if os.path.exists(to_string_name_h):
            os.remove(to_string_name_h)

        if os.path.exists(to_string_name_cpp):
            os.remove(to_string_name_cpp)

        logging.info("Creating to_string at '%s'." % to_string_name_h)
        logging.info("Creating to_string at '%s'." % to_string_name_cpp)
        if not create_to_string(to_string_name_h, to_string_name_cpp):
            logging.error("Could not create to_string stubs.")
            return False

    logging.info("Finished creating autogenerated stubs.")
    return True

if __name__ == '__main__':
    main()

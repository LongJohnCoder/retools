"""
This script generates both the decoder and the multiplexing tables
used for opcode disassembly.
"""
import argparse
import os
import re
import logging

from ARMv7DecodingSpec import instructions

DEBUG = False

def instruction_decoder_name(instruction):
    """
    Given an instruction with the format specified in ARMv7DecodingSpec.py
    output a unique name that represents that particular instruction decoder.
    """
    # Replace all the bad chars.
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])

    # Append the encoding.
    name += "_" + instruction["encoding"]

    # We may end up with double dashes, remove them.
    name = name.replace("__", "_")
    return "decode_" + name.lower()

def instruction_id_name(instruction):
    name = re.sub('[\s\(\)\-\,\/\#]', '_', instruction["name"])
    name = name.replace("__", "_").lower()
    return name if name[-1] != "_" else name[:-1]

def get_size(input):
    s = 0
    for e in input.split():
        if not "#" in e:
            s += len(e)

        else:
            s += int(e.split("#")[1])

    return "eSize32" if s == 32 else "eSize16"

def get_value(input):
    r = "0b"
    for e in input.split():
        if not "#" in e:
            r += e

        else:
            r += "0" * int(e.split("#")[1])

    return int(r, 2)

def get_mask(input):
    r = ""
    for e in input.split():
        if not "#" in e:
            r += "1" * len(e)
        else:
            r += "0" * int(e.split("#")[1])

    # If we are a 16 bit instruction we need to pad it with 0xffff
    if len(r) == 16:
        r = "1111111111111111" + r

    r = "0b" + r

    return int(r, 2)

decoder_header_h = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>
#include <memory>

#include "arm/ARMDisassembler.h"

'''

decoder_header_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <cstdint>
#include <memory>

#include "arm/ARMDisassembler.h"
#include "arm/ARMUtilities.h"
#include "arm/gen/ARMDecodingTable.h"
#include "arm/gen/ARMtoString.h"
#include "arm/gen/ARMtoStringCustom.h"
#include "Utilities.h"

using namespace Disassembler;
using namespace std;

bool ARMDecoder::InITBlock() {
    return CurrentInstrSet() == InstrSet_Thumb && m_it_session.InITBlock();
}

bool ARMDecoder::LastInITBlock() {
    return CurrentInstrSet() == InstrSet_Thumb && m_it_session.LastInITBlock();
}

ARMMode ARMDecoder::CurrentInstrSet() {
    return m_opcode_mode;
}

bool ARMDecoder::CurrentModeIsHyp() {
    return m_hyp_mode;
}

ARMVariants ARMDecoder::ArchVersion() {
    return m_arm_isa;
}

'''

def get_input_vars(input):
    input_vars = []

    for var in input.split():
        if not "#" in var:
            continue

        name, size = var.split("#")
        size = int(size)

        input_vars.append((name, size))

    return input_vars

def __get_bit_pattern_size__(bit_patterns):
    cnt = 0
    for bit_pattern in bit_patterns:
        if not "#" in bit_pattern:
            cnt += len(bit_pattern)
        else:
            cnt += int(bit_pattern.split("#")[1])

    return cnt

def __validate_bit_patterns__(bit_patterns):
    cnt = __get_bit_pattern_size__(bit_patterns)
    return cnt == 32 or cnt == 16

def __translate_bit_patterns__(bit_patterns):
    # Make sure the input patterns are valid.
    if not __validate_bit_patterns__(bit_patterns):
        raise RuntimeError("Invalid bit patters: %r" % bit_patterns)

    ret = []

    # Returns 16 or 32.
    i = __get_bit_pattern_size__(bit_patterns) - 1
    for bit_pattern in bit_patterns:
        # print "Decoding bit pattern: %r" % bit_pattern

        # Skip regular bits.
        if not "#" in bit_pattern:
            # print "  Skipping bits from [%d-%d]" % (i, i - len(bit_pattern) + 1)
            i -= len(bit_pattern)

        else:
            name, size = bit_pattern.split("#")
            size = int(size)

            # print "  Extracting bits into %s from [%d-%d]" % (name, i, i - size + 1)
            if size == 1:
                ret.append("int %5s = get_bit(opcode, %2d);" % (name, i))
            else:
                ret.append("int %5s = get_bits(opcode, %2d, %2d);" % (name, i, i - size + 1))

            i -= size

    return ret

def indent(lines):
    t = ""
    for l in lines.split("\n"):
        t += "    %s\n" % l

    return t

def create_decoders(decoder_name_h, decoder_name_cpp):
    """
    Create the ARMDecoder.h and ARMDecoder.cpp.
    """
    import ARMv7Parser

    # Create the header file with all the declarations.
    with open(decoder_name_h, "w") as fd:
        fd.write(decoder_header_h)

        # Generate the instruction id enum.
        fd.write("typedef enum ARMInstructionId {\n")

        for instruction_id in sorted(set(map(instruction_id_name, instructions))):
            fd.write("    %s,\n" % instruction_id)

        fd.write("} ARMInstructionId;\n")
        fd.write("\n")
        fd.write("class ARMDecoder;\n")
        fd.write("typedef struct ARMOpcode {\n")
        fd.write("        uint32_t mask;\n")
        fd.write("        uint32_t value;\n")
        fd.write("        uint32_t variants;\n")
        fd.write("        Disassembler::ARMInstrSize ins_size;\n")
        fd.write("        Disassembler::ARMEncoding encoding;\n")
        fd.write("        std::shared_ptr<Disassembler::ARMInstruction> (ARMDecoder::*decoder)(uint32_t, Disassembler::ARMInstrSize ins_size, Disassembler::ARMEncoding);\n")
        fd.write("        const char *name;\n")
        fd.write("} ARMOpcode;\n")
        fd.write("\n")
        fd.write("extern ARMOpcode arm_opcodes[];\n")
        fd.write("extern ARMOpcode thumb_opcodes[];\n")
        fd.write("extern const size_t n_arm_opcodes;\n")
        fd.write("extern const size_t n_thumb_opcodes;\n")
        fd.write("\n")
        fd.write("class ARMDecoder {\n")
        fd.write("    public:\n")
        fd.write("        ARMDecoder(Disassembler::ARMVariants variant) :\n")
        fd.write("                m_hyp_mode(false), m_opcode_mode(Disassembler::ARMMode_Invalid), m_arm_isa(variant) {\n")
        fd.write("            // Initialize the default FP state.\n")
        fd.write("            FPSCR.LEN = 0;\n")
        fd.write("            FPSCR.STRIDE = 0;\n")
        fd.write("            // Initialize the default carry flag state.\n")
        fd.write("            APSR.C = 0;\n")
        fd.write("        }\n")
        fd.write("\n")
        fd.write("        std::shared_ptr<Disassembler::ARMInstruction> decode(uint32_t op_code, Disassembler::ARMMode mode) {\n")
        fd.write("            m_opcode_mode = mode;\n")
        fd.write("            return (mode == Disassembler::ARMMode_ARM) ? decode_arm(op_code) : decode_thumb(op_code);\n")
        fd.write("        }\n")
        fd.write("\n")
        fd.write("    private:\n")
        fd.write("        bool IsZero(unsigned i) { return i == 0; };\n")
        fd.write("        bool InITBlock();\n")
        fd.write("        bool LastInITBlock();\n")
        fd.write("        bool CurrentModeIsHyp();\n")
        fd.write("        Disassembler::ARMMode CurrentInstrSet();\n")
        fd.write("        Disassembler::ARMVariants ArchVersion();\n")
        fd.write("\n")
        fd.write("        // Fields:\n")
        fd.write("        bool m_hyp_mode;\n")
        fd.write("        Disassembler::ITSession m_it_session;\n")
        fd.write("        Disassembler::ARMMode m_opcode_mode;\n")
        fd.write("        Disassembler::ARMVariants m_arm_isa;\n")
        fd.write("        Disassembler::apsr_t APSR;\n")
        fd.write("        Disassembler::fpscr_t FPSCR;\n")
        fd.write("\n")
        fd.write("        std::shared_ptr<Disassembler::ARMInstruction> decode_arm(uint32_t opcode);\n")
        fd.write("        std::shared_ptr<Disassembler::ARMInstruction> decode_thumb(uint32_t opcode);\n")
        fd.write("\n")
        fd.write("    public:\n")

        for instruction in instructions:
            fd.write("        std::shared_ptr<Disassembler::ARMInstruction> %s(uint32_t opcode, Disassembler::ARMInstrSize ins_size, Disassembler::ARMEncoding encoding);\n" % instruction_decoder_name(instruction))

        fd.write("        std::shared_ptr<Disassembler::ARMInstruction> decode_unknown(uint32_t opcode, Disassembler::ARMInstrSize ins_size, Disassembler::ARMEncoding encoding);\n")
        fd.write("};\n")

    # Create the implementation file.
    with open(decoder_name_cpp, "w") as fd:
        fd.write(decoder_header_cpp)

        fd.write("// Format: (mask, value, version, encoding, decoder_function, name)\n")
        fd.write("ARMOpcode arm_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "T":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = instruction_decoder_name(instruction)
            size = get_size(instruction["pattern"])
            name = instruction["name"]
            fd.write("    { 0x%.8x, 0x%.8x, %s, %s, %s, &ARMDecoder::%s, \"%s\"},\n" % (mask, value, version, size, encoding, decoder, name))

        fd.write("    { 0x00000000, 0x00000000, ARMvAll, eSize32, eEncodingA1, &ARMDecoder::decode_unknown, \"UNKNOWN\"}\n")

        fd.write("};\n")
        fd.write("\n")
        fd.write("const size_t n_arm_opcodes = sizeof(arm_opcodes) / sizeof(arm_opcodes[0]);\n")
        fd.write("shared_ptr<ARMInstruction> ARMDecoder::decode_arm(uint32_t op_code) {\n")
        fd.write("    for (size_t i = 0; i < n_arm_opcodes; ++i) {\n")
        fd.write("        if ((arm_opcodes[i].mask & op_code) == arm_opcodes[i].value && (arm_opcodes[i].variants & m_arm_isa) != 0) {\n")
        fd.write("            ARMOpcode *opcode = &arm_opcodes[i];\n")
        fd.write("            shared_ptr<ARMInstruction> ins = (this->*opcode->decoder)(op_code, opcode->ins_size, opcode->encoding);\n")
        fd.write("\n")
        fd.write("            // Skip instruction when there is a SEE command.\n")
        fd.write("            if (!ins->m_skip) {\n")
        fd.write("                return ins;\n")
        fd.write("            }\n")
        fd.write("        }\n")
        fd.write("    }\n")
        fd.write("\n")
        fd.write("    return shared_ptr<ARMInstruction>(new UnknownInstruction());\n")
        fd.write("}\n\n")

        fd.write("ARMOpcode thumb_opcodes[] = {\n")
        for instruction in instructions:
            if instruction["encoding"][0] == "A":
                continue

            encoding = "eEncoding%s" % instruction["encoding"]
            value = get_value(instruction["pattern"])
            mask = get_mask(instruction["pattern"])
            version = " | ".join(instruction["version"].split(", "))
            decoder = instruction_decoder_name(instruction)
            size = get_size(instruction["pattern"])
            name = instruction["name"]
            fd.write("    { 0x%.8x, 0x%.8x, %s, %s, %s, &ARMDecoder::%s, \"%s\"},\n" % (mask, value, version, size, encoding, decoder, name))

        fd.write("    {0x00000000, 0x00000000, ARMvAll, eSize32, eEncodingA1, &ARMDecoder::decode_unknown, \"UNKNOWN\"}\n")
        fd.write("};\n")
        fd.write("\n")

        fd.write("shared_ptr<ARMInstruction> ARMDecoder::decode_unknown(uint32_t opcode, ARMInstrSize ins_size, ARMEncoding encoding) {\n")
        fd.write("    return shared_ptr<ARMInstruction>(new UnknownInstruction());\n")
        fd.write("}\n")
        fd.write("\n")

        fd.write("const size_t n_thumb_opcodes = sizeof(thumb_opcodes) / sizeof(thumb_opcodes[0]);\n")
        fd.write("shared_ptr<ARMInstruction> ARMDecoder::decode_thumb(uint32_t op_code) {\n")
        fd.write("    for (size_t i = 0; i < n_thumb_opcodes; ++i) {\n")
        fd.write("        if ((thumb_opcodes[i].mask & op_code) == thumb_opcodes[i].value && (thumb_opcodes[i].variants & m_arm_isa) != 0) {\n")
        fd.write("            ARMOpcode *opcode = &thumb_opcodes[i];\n")
        fd.write("            shared_ptr<ARMInstruction> ins = (this->*opcode->decoder)(op_code, opcode->ins_size, opcode->encoding);\n")
        fd.write("\n")
        fd.write("            // Skip instruction when there is a SEE command.\n")        
        fd.write("            if (!ins->m_skip) {\n")
        fd.write("                return ins;\n")
        fd.write("            }\n")
        fd.write("        }\n")
        fd.write("    }\n")
        fd.write("\n")
        fd.write("    return shared_ptr<ARMInstruction>(new UnknownInstruction());\n")
        fd.write("}\n\n")

        i = -1
        for instruction in instructions:
            i += 1

            input_vars = get_input_vars(instruction["pattern"])
            decoder = instruction["decoder"]

            if DEBUG:
                fd.write("// Translating: %d -> %s %s %s\n" % (i, instruction["name"], instruction["encoding"], instruction["pattern"]))
                fd.write("// Pseudocode:\n")
                for line in decoder.split("\n"):
                    for line2 in line.split(";"):
                        if not len(line2):
                            continue
                        fd.write("// " + line2.strip() + "\n")

            if i % 50 == 0:
                logging.info("Processing instruction %.4d of %.4d" % (i, len(instructions)))

            decoder_name = instruction_decoder_name(instruction)
            fd.write("shared_ptr<ARMInstruction> ARMDecoder::%s(uint32_t opcode, ARMInstrSize ins_size, ARMEncoding encoding) {\n" % decoder_name)
            ret = __translate_bit_patterns__(instruction["pattern"].split())
            for r in ret:
                fd.write("    %s\n" % r)

            fd.write("#ifdef DEBUG_DECODER\n")
            fd.write("    std::cout << \"opcode=\" << std::hex << opcode << \" decoder=%s\" << std::endl;\n" % decoder_name)

            # Get the names of the decoded variables.
            decoded_vars = map(lambda y: y.split("#")[0], filter(lambda x: x.count("#"), instruction["pattern"].split()))
            fd.write("    std::cout << ")
            for decoded_var in decoded_vars:
                fd.write('''"%s=" << %s << " " << ''' % (decoded_var, decoded_var))
            fd.write("std::endl;\n")
            fd.write("#endif\n")

            ret = ARMv7Parser.program.parseString(decoder, parseAll=True)
            visitor = ARMv7Parser.CPPTranslatorVisitor(input_vars, decoder_name, instruction)

            body = ""
            for ast in ret:
                l = visitor.accept(ast[0])
                body += indent(l)

                if type(ast[0]) == ARMv7Parser.ProcedureCall:
                    body = body[:-1] + ";\n"

            for var in visitor.define_me:
                type_ = "int"
                if var == "imm64":
                    type_ = "uint64_t"

                fd.write("    %s %s = 0;\n" % (type_, var))

            fd.write("\n")
            fd.write(body)

            # All the variables defined in the body end up in the instruction.
            fd.write("    shared_ptr<ARMInstruction> ins = ARMInstruction::create();\n")
            fd.write("    ins->opcode = opcode;\n")
            fd.write("    ins->ins_size = ins_size;\n")
            fd.write("    ins->id = %s;\n" % instruction_id_name(instruction))
            fd.write("    ins->m_to_string = %s_to_string;\n" % instruction_decoder_name(instruction))
            fd.write("    ins->m_decoded_by = \"ARMDecoder::%s\";\n" % instruction_decoder_name(instruction))

            for var in visitor.define_me:
                fd.write("    ins->%s = %s;\n" % (var, var))

            # Here we hard code some variables that are not defined in the body but need to go into the instruction.
            hard = ["cond", "coproc", "opc1", "CRd", "CRn", "CRm",
                "opc2", "option", "D", "W", "B", "P", "U", "op", "imm3", "imm6",
                "mode", "opcode_", "mask", "firstcond", "Q", "size", "E", "T", "imm4",
                "type", "reg", "cmode"]

            fd.write("    ins->encoding = encoding;\n")
            for var in input_vars:
                if var[0] in hard:
                    fd.write("    ins->%s = %s;\n" % (var[0], var[0]))

            fd.write("\n")

            fd.write("    return ins;\n")
            fd.write("}\n\n")

    return True

to_string_cpp = \
'''// Warning! autogenerated file, do what you want.
#include <string>
#include <cstdlib>
#include <cstdio>

#include "arm/ARMUtilities.h"
#include "arm/ARMDisassembler.h"
#include "arm/gen/ARMDecodingTable.h"
#include "Utilities.h"

using namespace Disassembler;
using namespace std;

string banked_reg(const ARMInstruction *ins) {
    string tmp = "UNPREDICTABLE";
    if (ins->read_spsr == 0) {
        switch(ins->SYSm) {
            case 0: // 0b0
                tmp = "R8_usr";
                break;
            case 1: // 0b1
                tmp = "R9_usr";
                break;
            case 2: // 0b10
                tmp = "R10_usr";
                break;
            case 3: // 0b11
                tmp = "R11_usr";
                break;
            case 4: // 0b100
                tmp = "R12_usr";
                break;
            case 5: // 0b101
                tmp = "SP_usr";
                break;
            case 6: // 0b110
                tmp = "LR_usr";
                break;                
            case 8: // 0b1000
                tmp = "R8_fiq";
                break;
            case 9: // 0b1001
                tmp = "R9_fiq";
                break;
            case 10: // 0b1010
                tmp = "R10_fiq";
                break;
            case 11: // 0b1011
                tmp = "R11_fiq";
                break;
            case 12: // 0b1100
                tmp = "R12_fiq";
                break;
            case 13: // 0b1101
                tmp = "SP_fiq";
                break;
            case 14: // 0b1110
                tmp = "LR_fiq";
                break;
            case 16: // 0b10000
                tmp = "LR_irq";
                break;
            case 17: // 0b10001
                tmp = "SP_irq";
                break;
            case 18: // 0b10010
                tmp = "LR_svc";
                break;
            case 19: // 0b10011
                tmp = "SP_svc";
                break;
            case 20: // 0b10100
                tmp = "LR_abt";
                break;
            case 21: // 0b10101
                tmp = "SP_abt";
                break;
            case 22: // 0b10110
                tmp = "LR_und";
                break;
            case 23: // 0b10111
                tmp = "SP_und";
                break;
            case 28: // 0b11100
                tmp = "LR_mon";
                break;
            case 29: // 0b11101
                tmp = "SP_mon";
                break;
            case 30: // 0b11110
                tmp = "ELR_hyp";
                break;
            case 31: // 0b11111
                tmp = "SP_hyp";
                break;
            default:
                tmp = "UNPREDICTABLE";
                break;
        }
    } else {
        switch(ins->SYSm) {
                case 14: // 0b01110
                    tmp = "SPSR_fiq";
                    break;
                case 16: // 0b10000
                    tmp = "SPSR_irq";
                    break;
                case 18: // 0b10010
                    tmp = "SPSR_svc";
                    break;
                case 20: // 0b10100
                    tmp = "SPSR_abt";
                    break;
                case 22: // 0b10110
                    tmp = "SPSR_und";
                    break;
                case 28: // 0b11100
                    tmp = "SPSR_mon";
                    break;
                case 30: // 0b11110
                    tmp = "SPSR_hyp";
                    break;
                default:
                    tmp = "UNPREDICTABLE";
                    break;
        }
    }

    return tmp;
}

string effect_str(const ARMInstruction *ins) {
    if (ins->enable) 
        return "IE";
        
    if (ins->disable) 
        return "ID";
        
    return "";
}

string align_str(const ARMInstruction *ins) {
    switch(ins->id) {
        case vst4_multiple_4_element_structures:
        case vst3_multiple_3_element_structures:
        case vst1_multiple_single_elements:
        case vst2_multiple_2_element_structures:    
        case vld1_multiple_single_elements:         // VLD1 (multiple single elements)
        case vld2_multiple_2_element_structures:    // VLD2 (multiple 2-element structures)
        case vld4_multiple_4_element_structures:    // VLD4 (multiple 4-element structures)
            switch(get_bits(ins->opcode, 5, 4)) { // align
                case 0:  return "";
                case 1:  return ":0x40";
                case 2:  return ":0x80";
                case 3:  return ":0x100";
                default: return "";
            }

        case vld1_single_element_to_one_lane:   // VLD1 (single element to one lane)
        case vld1_single_element_to_all_lanes:  // VLD1 (single element to all lanes)
            switch(ins->size) {
                case 1:  return get_bit(ins->opcode, 4) ? ":0x10" : "";  // a
                case 2:  return get_bit(ins->opcode, 4) ? ":0x20" : "";  // a
                default: return  "";
            }

        case vst2_single_2_element_structure_from_one_lane:
        case vst1_single_element_from_one_lane:
        case vld2_single_2_element_structure_to_one_lane:   // VLD2 (single 2-element structure to one lane)
            switch(ins->alignment) {
                case 2:  return ":0x10";
                case 4:  return ":0x20";
                case 8:  return ":0x40";
                default: return  "";
            }

        case vld2_single_2_element_structure_to_all_lanes:  // VLD2 (single 2-element structure to all lanes)
            switch(ins->size) {
                case 0:  return get_bit(ins->opcode, 4) ? ":0x10" : "";
                case 1:  return get_bit(ins->opcode, 4) ? ":0x20" : "";
                case 2:  return get_bit(ins->opcode, 4) ? ":0x40" : "";
                default: return  "";
            }

        case vld3_multiple_3_element_structures:    // VLD3 (multiple 3-element structures)
            switch(get_bits(ins->opcode, 5, 4)) {
                case 1:   return ":0x40";
                default: return  "";
            }

        case vst4_single_4_element_structure_from_one_lane:
        case vld4_single_4_element_structure_to_one_lane:   // VLD4 (single 4-element structure to one lane)
            switch(ins->alignment) {
                case 2:  return ":0x10";
                case 4:  return ":0x20";
                case 8:  return ":0x40";
                case 16: return ":0x80";
                default: return  "";
            }

        case vld4_single_4_element_structure_to_all_lanes:  // VLD4 (single 4-element structure to all lanes)
            switch(ins->size) {
                case 0:  return get_bit(ins->opcode, 4) ? ":0x20" : "";
                case 1:  return get_bit(ins->opcode, 4) ? ":0x40" : "";
                case 2:  return get_bit(ins->opcode, 4) ? ":0x40" : "";
                case 3:  return get_bit(ins->opcode, 4) ? ":0x80" : "";
                default: return  "";
            }

        default:
            break;
    }

    return "missing_id_align_str";
}

string range(unsigned i, unsigned n, const string &pre) {
    if (n == 0) {
        return pre + to_string(i);
    }

    string tmp = "";
    while (i < n - 1) {
        tmp += pre + to_string(i) + ", ";
        i++;
    }

    tmp += pre + to_string(i);

    return tmp;
}

string list_str(const ARMInstruction *ins) {
    switch(ins->id) {
        case vldm: {
            // Get the value of imm8.
            unsigned n = ins->imm32 >> 2;
            if (!ins->single_regs) {
                n /= 2;
            }

            return "{" + range(ins->d, ins->d + n, ins->single_regs ? "S" : "D") + "}";
        }

        case vld3_multiple_3_element_structures:
            switch(ins->type) {
                case 4:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 1) +
                        ", D" + to_string(ins->d + 2) +
                        "}";
                case 5:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 2) +
                        ", D" + to_string(ins->d + 4) +
                        "}";
                default:
                    return "INVALID:" + to_string(ins->type);
            }
            break;

        case vst3_single_3_element_structure_from_one_lane:
        case vld3_single_3_element_structure_to_one_lane:
            return "{D" + to_string(ins->d) + "["  + to_string(ins->index) + "], " +
                    "D" + to_string(ins->d + ins->inc) + "["  + to_string(ins->index) + "], " +
                    "D" + to_string(ins->d + ins->inc * 2) + "["  + to_string(ins->index) + "]" + "}";

        case vld3_single_3_element_structure_to_all_lanes:
            return "{D" + to_string(ins->d) + "[], " +
                    "D" + to_string(ins->d + ins->inc) + "[], " +
                    "D" + to_string(ins->d + ins->inc * 2) + "[]" + "}";

        case vld4_multiple_4_element_structures:
            return "{D" + to_string(ins->d) + ", " +
                    "D" + to_string(ins->d + ins->inc) + ", " +
                    "D" + to_string(ins->d + ins->inc * 2) + ", " +
                    "D" + to_string(ins->d + ins->inc * 3) + "}";

        case vst4_single_4_element_structure_from_one_lane:
        case vld4_single_4_element_structure_to_one_lane:
            return "{D" + to_string(ins->d) + "["  + to_string(ins->index) + "], " +
                    "D" + to_string(ins->d + ins->inc) + "["  + to_string(ins->index) + "], " +
                    "D" + to_string(ins->d + ins->inc * 2) + "["  + to_string(ins->index) + "], " +
                    "D" + to_string(ins->d + ins->inc * 3) + "["  + to_string(ins->index) + "]" + "}";

        case vld4_single_4_element_structure_to_all_lanes:
            return "{D" + to_string(ins->d) + "[], " +
                    "D" + to_string(ins->d + ins->inc) + "[], " +
                    "D" + to_string(ins->d + ins->inc * 2) + "[], " +
                    "D" + to_string(ins->d + ins->inc * 3) + "[]" + "}";

        case vld2_single_2_element_structure_to_all_lanes:
            return "{D" + to_string(ins->d) + "[], D" + to_string(ins->d + ins->inc) + "[]}";

        case vst2_single_2_element_structure_from_one_lane:
        case vld2_single_2_element_structure_to_one_lane:
            return "{D" + to_string(ins->d) + "["  + to_string(ins->index) + "], D" + to_string(ins->d + ins->inc) + "["  + to_string(ins->index) + "]}";

        case vld1_single_element_to_all_lanes:
            if (!ins->T) {
                return "{D" + to_string(ins->d) + "[]}";
            }
            return "{D" + to_string(ins->d) + "[], D" + to_string(ins->d + 1) + "[]}";

        case vst1_single_element_from_one_lane:
        case vld1_single_element_to_one_lane:
            return "{D" + to_string(ins->d) + "["  + to_string(ins->index) + "]}";

        case vld2_multiple_2_element_structures:
        case vld1_multiple_single_elements:
        case vst1_multiple_single_elements:
        case vst4_multiple_4_element_structures:
        case vst2_multiple_2_element_structures:
        case vst3_multiple_3_element_structures:
            switch(ins->type) {
                case 1:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 2) +
                        ", D" + to_string(ins->d + 4) +
                        ", D" + to_string(ins->d + 6) +
                        "}";                
                case 5:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 2) +
                        ", D" + to_string(ins->d + 4) +
                        "}";                
                case 8:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 1) +
                        "}";
                case 9:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 2) +
                        "}";
                case 3:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 1) +
                        ", D" + to_string(ins->d + 2) +
                        ", D" + to_string(ins->d + 3) +
                        "}";
                case 7:
                    return "{D" + to_string(ins->d) + "}";
                case 10:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 1) +
                        "}";
                case 4:
                case 6:                
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 1) +
                        ", D" + to_string(ins->d + 2) +
                        "}";
                case 0:
                case 2:
                    return "{D" + to_string(ins->d) +
                        ", D" + to_string(ins->d + 1) +
                        ", D" + to_string(ins->d + 2) +
                        ", D" + to_string(ins->d + 3) +
                        "}";
                default:
                    return "INVALID" + to_string(ins->type);
            }
            break;
        case vtbl_vtbx:
            switch(ins->length - 1) {
                case 0:
                    return "{D" + to_string(ins->n) + "}";
                case 1:
                    return "{D" + to_string(ins->n) +
                        ", D" + to_string(ins->n + 1) + "}";
                case 2:
                    return "{D" + to_string(ins->n) +
                    ", D" + to_string(ins->n + 1) +
                    ", D" + to_string(ins->n + 2) + "}";
                case 3:
                    return "{D" + to_string(ins->n) +
                    ", D" + to_string(ins->n + 1) +
                    ", D" + to_string(ins->n + 2) +
                    ", D" + to_string(ins->n + 3) + "}";
                default:
                    return "INVALID";
            }
    }

    unsigned first_reg = first_reg = ins->d;
    unsigned n_regs = ins->imm32 >> 2;
    string reg_type = "S";

    if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
        n_regs /= 2;
        reg_type = "D";
    }

    string acum;
    for(unsigned i = first_reg; i < first_reg + n_regs; ++i) {
        acum += reg_type + to_string(i);
        if (i != (first_reg + n_regs - 1))
            acum += ", ";
    }

    return "{" + acum + "}";
}

string amode_str(const ARMInstruction *ins) {
    if (ins->P == 0 && ins->U == 0) return "DA";
    else if (ins->P == 1 && ins->U == 0) return "DB";
    else if (ins->P == 0 && ins->U == 1) return "IA";
    else if (ins->P == 1 && ins->U == 1) return "IB";
    return "INVALID";
}

string IA_str(const ARMInstruction *ins) {
    return ins->increment ? "IA" : "DB";
}

string iflags_str(const ARMInstruction *ins) {
    string out;
    if (ins->affectA) out += "A";
    if (ins->affectI) out += "I";
    if (ins->affectF) out += "F";
    return out;
}

string S_str(const ARMInstruction *ins) {
    return ins->setflags ? "S" : "";
}

bool is_conditional_thumb(const ARMInstruction *ins) {
    switch (ins->id) {
    case b:
    case cbnz_cbz:
        return true;
    }

    return false;
}

string c_str(const ARMInstruction *ins) {
    if (EncodingIsThumb(ins->encoding) && !is_conditional_thumb(ins))
        return "";

    return ins->cond != COND_AL ? ARMCondCodeToString((cond_t) ins->cond) : "";
}

string B_str(const ARMInstruction *ins) {
    return ins->B ? "B" : "";
}

string N_str(const ARMInstruction *ins) {
    return ins->nonzero ? "N" : "";
}

string W_str(const ARMInstruction *ins) {
    return ins->is_pldw ? "W" : "";
}

string x_str(const ARMInstruction *ins) {
    return ins->n_high ? "T" : "B";
}

string y_str(const ARMInstruction *ins) {
    return ins->m_high ? "T" : "B";
}

string X_str(const ARMInstruction *ins) {
    return ins->m_swap ? "X" : "";
}

string R_str(const ARMInstruction *ins) {
    return ins->round ? "R" : "";
}

string mode_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vldm: // VLDM
        case vstm: // VSTM
            if (ins->P == 0 && ins->U == 1)
                return "IA";

            if (ins->P == 1 && ins->U == 0)
                return "DB";

            break;
        default:
            break;
    }

    return "INVALID";
}

string op_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vpmax_vpmin_floating_point: // VPMAX, VPMIN (floating-point)
        case vpmax_vpmin_integer: // VPMAX, VPMIN (integer)
            return ins->op ? "MIN" : "MAX";
        case vqdmlal_vqdmlsl: // VQDMLAL, VQDMLSL
            return ins->op ? "MLSL" : "MLAL";
        case vtbl_vtbx: // VTBL, VTBX
            return ins->op ? "TBX" : "TBL";

        default:
            break;
    }

    return "INVALID";
}

string dt_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vrsqrte:
            return ((ins->floating_point) ? "F" : "U") + to_string(ins->esize);

        case vrhadd:
            return (ins->unsigned_ ? "U" : "S") + to_string(ins->esize);

        case vrecpe:
            return (ins->floating_point) ? "F32" : "U32";

        case vpadal:
        case vpaddl:
            return (ins->unsigned_ ? "U" : "S") + to_string(ins->esize);

        case vmla_vmlal_vmls_vmlsl_integer:
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                switch (ins->size) {
                    case 0: return "I8";
                    case 1: return "I16";
                    case 2: return "I32";
                    default: return "INVALID";
                }
            }

            if (ins->U) {
                switch (ins->size) {
                    case 0: return "U8";
                    case 1: return "U16";
                    case 2: return "U32";
                    default: return "INVALID";
                }
            } else {
                switch (ins->size) {
                    case 0: return "S8";
                    case 1: return "S16";
                    case 2: return "S32";
                    default: return "INVALID";
                }
            }
        case vmla_vmlal_vmls_vmlsl_by_scalar:
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                return (ins->floating_point ? "F" : "I") + string(ins->size == 1 ? "16" : "32");
            }

            return (ins->unsigned_ ? "U" : "S") + string(ins->size == 1 ? "16" : "32");

        case vmax_vmin_integer:
        case vhadd_vhsub:
        case vsubl_vsubw:
            if (ins->U) {
                switch (ins->size) {
                    case 0: return "U8";
                    case 1: return "U16";
                    case 2: return "U32";
                    default: return "INVALID";
                }
            } else {
                switch (ins->size) {
                    case 0: return "S8";
                    case 1: return "S16";
                    case 2: return "S32";
                    default: return "INVALID";
                }
            }
        case vclz:
            switch (ins->size) {
                case 0: return "I8";
                case 1: return "I16";
                case 2: return "I32";
                default: return "INVALID";
            }
        case vcls:
        case vqabs:
            switch (ins->size) {
                case 0: return "S8";
                case 1: return "S16";
                case 2: return "S32";
                default: return "INVALID";
            }
        case vqadd:
            return (ins->unsigned_ ? "U" : "S") + to_string(ins->esize);

        case vceq_immediate_0:
            return (ins->floating_point ? "F" : "I") + to_string(ins->esize);
        case vcgt_immediate_0:
        case vcle_immediate_0:
        case vclt_immediate_0:
        case vcge_immediate_0:
            return (ins->floating_point ? "F" : "S") + to_string(ins->esize);

        case vcgt_register:
        case vcge_register:
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                return (ins->U ? "U" : "S") + to_string(ins->esize);
            }

            return "F32";

        case vceq_register: // VCEQ (register)
            return (ins->int_operation ? "I" : "F") + to_string(ins->esize);

        case vbic_immediate:
        case vmov_immediate:
        case vmvn_immediate:
        case vorr_immediate:
            if (ins->cmode <= 7 || (ins->cmode >= 12 && ins->cmode <= 13))
                return "I32";

            else if (ins->cmode >= 8 && ins->cmode <= 11)
                return "I16";

            else if (ins->op == 0 && ins->cmode == 14)
                return "I8";

            else if (ins->cmode == 15)
                return "F32";

            else
                return "I64";

        case vaddl_vaddw:
            if      (ins->U == 0 && ins->size == 0) return "S8";
            else if (ins->U == 0 && ins->size == 1) return "S16";
            else if (ins->U == 0 && ins->size == 2) return "S32";
            else if (ins->U == 1 && ins->size == 0) return "U8";
            else if (ins->U == 1 && ins->size == 1) return "U16";
            else if (ins->U == 1 && ins->size == 2) return "U32";
            else return "INVALID";
        case vsub_integer:
        case vadd: // VADD (integer)
            switch (ins->size) {
                case 0: return "I8";
                case 1: return "I16";
                case 2: return "I32";
                case 3: return "I64";
                default: return "INVALID";
            }
        case vaba_vabal: // VABA, VABAL
        case vabd_vabdl_integer: // VABD, VABDL (integer)
        case vpmax_vpmin_integer: // VPMAX, VPMIN (integer)
                 if (ins->size == 0 && ins->U == 0) return "S8";
            else if (ins->size == 1 && ins->U == 0) return "S16";
            else if (ins->size == 2 && ins->U == 0) return "S32";
            else if (ins->size == 0 && ins->U == 1) return "U8";
            else if (ins->size == 1 && ins->U == 1) return "U16";
            else if (ins->size == 2 && ins->U == 1) return "U32";

            break;
        case vneg:
        case vabs: // VABS
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                return (ins->floating_point ? "F" : "S") + to_string(ins->esize);
            }
            return ins->dp_operation ? "F64" : "F32";
        case vaddhn: // VADDHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vmov_scalar_to_arm_core_register: // VMOV (scalar to ARM core register)
            if (ins->U == 0 && get_bit(ins->opc1, 1) == 1)
                return "S8";
            else if (ins->U == 0 && get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "S16";
            else if (ins->U == 1 && get_bit(ins->opc1, 1) == 1)
                return "U8";
            else if (ins->U == 1 && get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "U16";
            else if (ins->U == 0 && get_bit(ins->opc1, 1) == 0 && ins->opc2 == 0)
                return "32";

            break;
        case vmovl: // VMOVL
            return (ins->unsigned_ ? "U" : "S") + to_string(ins->esize);

        case vmovn: // VMOVN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vmul_vmull_by_scalar: // VMUL, VMULL (by scalar)
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                return (ins->floating_point ? "F" : "I") + to_string(ins->esize);
            }

            return (ins->unsigned_ ? "U" : "S") + to_string(ins->esize);

        case vmul_vmull_integer_and_polynomial: // VMUL, VMULL (integer and polynomial)
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                return (ins->polynomial ? "P" : "I") + to_string(ins->esize);
            }

            return (ins->polynomial ? "P" : (ins->unsigned_ ? "U" : "S")) + to_string(ins->esize);

        case vpadd_integer: // VPADD (integer)
            switch (ins->size) {
                case 0:
                    return "I8";
                case 1:
                    return "I16";
                case 2:
                    return "I32";
                default:
                    break;
            }

            break;
        case vqneg:
            switch (ins->size) {
                case 0:
                    return "S8";
                case 1:
                    return "S16";
                case 2:
                    return "S32";
                default:
                    break;
            }
            break;
        case vqdmlal_vqdmlsl: // VQDMLAL, VQDMLSL
        case vqdmull: // VQDMULL
        case vqdmulh:
        case vqrdmulh:
            switch (ins->size) {
                case 1:
                    return "S16";
                case 2:
                    return "S32";
                default:
                    break;
            }

            break;
        case vraddhn: // VRADDHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vrsubhn: // VRSUBHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        case vsubhn: // VSUBHN
            switch (ins->size) {
                case 0:
                    return "I16";
                case 1:
                    return "I32";
                case 2:
                    return "I64";
                default:
                    break;
            }

            break;
        default:
            break;
    }

    return "INVALID";
}

string U_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            return ins->op == 1 ? "U" : "";
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
            return ins->U == 1 ? "U" : "";

        default:
            break;
    }

    return "INVALID";
}

string size_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vst3_single_3_element_structure_from_one_lane:
        case vst2_single_2_element_structure_from_one_lane:
        case vst1_single_element_from_one_lane:
        case vst1_multiple_single_elements:
        case vst2_multiple_2_element_structures:
        case vst3_multiple_3_element_structures:
        case vst4_multiple_4_element_structures:
        case vst4_single_4_element_structure_from_one_lane:
        case vsri:
        case vsra:
        case vsli:
        case vshr:
        case vshl_immediate:
        case vshl_register:
        case vrsra:
        case vrshl:
        case vrshr:
        case vrev16_vrev32_vrev64:
        case vqsub:
        case vqshl_vqshlu_immediate:
            return to_string(ins->esize);

        case vld1_single_element_to_one_lane:
        case vld1_single_element_to_all_lanes:
        case vld2_multiple_2_element_structures:
        case vld2_single_2_element_structure_to_one_lane:
        case vld2_single_2_element_structure_to_all_lanes:
        case vld3_multiple_3_element_structures:
        case vld3_single_3_element_structure_to_one_lane:
        case vld3_single_3_element_structure_to_all_lanes:
        case vld4_multiple_4_element_structures:
        case vld4_single_4_element_structure_to_one_lane:
        case vld4_single_4_element_structure_to_all_lanes:
        case vtrn:
        case vtst:
        case vuzp:
        case vzip:
            switch(ins->size) {
                case 0: return "8";
                case 1: return "16";
                case 2: return "32";
                case 3: return "32";
                default: return "INVALID";
            }

        case vld1_multiple_single_elements:
        case vqrshl:
        case vqshl_register:
            switch(ins->size) {
                case 0: return "8";
                case 1: return "16";
                case 2: return "32";
                case 3: return "64";
                default: return "INVALID";
            }
        case vmov_arm_core_register_to_scalar: // VMOV (ARM core register to scalar)
            if (get_bit(ins->opc1, 1) == 1)
                return "8";

            else if (get_bit(ins->opc1, 1) == 0 && get_bit(ins->opc2, 0) == 1)
                return "16";

            else if (get_bit(ins->opc1, 1) == 0 && ins->opc2 == 0)
                return "32";

            break;
        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            if (ins->size == 0)
                return "16";

            else if (ins->size == 1)
                return "32";

            else if (ins->size == 2)
                return "64";

            break;
        case vshll: // VSHLL
            return to_string(ins->esize);
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
        case vrshrn: // VRSHRN
        case vshrn: // VSHRN
            if (get_bits(ins->imm6, 5, 3) == 1) return "16";
            else if (get_bits(ins->imm6, 5, 4) == 1) return "32";
            else if (get_bit(ins->imm6, 5) == 1) return "64";
            break;
        default:
            break;
    }

    return "INVALID";
}

string type_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case vqshl_vqshlu_immediate:
            return ins->src_unsigned ? "U" : "S";

        case vsra:
        case vshr:
        case vshl_register:
        case vrsra:
        case vrshr:
        case vqsub:
        case vqshl_register:
        case vqrshl:
        case vrshl:
            return ins->U ? "U" : "S";

        case vqmovn_vqmovun: // VQMOVN, VQMOVUN
            if (ins->op == 1 || ins->op == 2)
                return "S";

            if (ins->op == 3)
                return "U";

            break;
        case vqrshrn_vqrshrun: // VQRSHRN, VQRSHRUN
        case vqshrn_vqshrun: // VQSHRN, VQSHRUN
            if (ins->U == 0 && ins->op == 1)
                return "S";

            if (ins->U == 1 && ins->op == 0)
                return "S";

            if (ins->U == 1 && ins->op == 1)
                return "U";

            break;
        case vshll: // VSHLL
            if (ins->encoding == eEncodingT1 || ins->encoding == eEncodingA1) {
                if (ins->U == 0)
                    return "S";

                if (ins->U == 1)
                    return "U";
            } else if (ins->encoding == eEncodingT2 || ins->encoding == eEncodingA2) {
                return "I";
            }

            break;

        default:
            break;
    }

    return "INVALID";
}

string regular_reg_str(unsigned reg) {
    switch (reg) {
        case 0:
            return "r0";
        case 1:
            return "r1";
        case 2:
            return "r2";
        case 3:
            return "r3";
        case 4:
            return "r4";
        case 5:
            return "r5";
        case 6:
            return "r6";
        case 7:
            return "r7";
        case 8:
            return "r8";
        case 9:
            return "r9";
        case 10:
            return "r10";
        case 11:
            return "r11";
        case 12:
            return "r12";
        case 13:
            return "sp";
        case 14:
            return "lr";
        case 15:
            return "pc";
        default:
            break;
    }

    return "INVALID";
}

string coproc_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "p0";
        case 1:
            return "p1";
        case 2:
            return "p2";
        case 3:
            return "p3";
        case 4:
            return "p4";
        case 5:
            return "p5";
        case 6:
            return "p6";
        case 7:
            return "p7";
        case 8:
            return "p8";
        case 9:
            return "p9";
        case 10:
            return "p10";
        case 11:
            return "p11";
        case 12:
            return "p12";
        case 13:
            return "p13";
        case 14:
            return "p14";
        case 15:
            return "p15";
        default:
            break;
    }

    return "INVALID";
}

string shift_type_str(unsigned shift) {
    switch (shift) {
        case 0:
            return "LSL";
        case 1:
            return "LSR";
        case 2:
            return "ASR";
        case 3:
            return "ROR";
        case 4:
            return "RRX";
        default:
            break;
    }

    return "INVALID";
}

string coproc_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "c0";
        case 1:
            return "c1";
        case 2:
            return "c2";
        case 3:
            return "c3";
        case 4:
            return "c4";
        case 5:
            return "c5";
        case 6:
            return "c6";
        case 7:
            return "c7";
        case 8:
            return "c8";
        case 9:
            return "c9";
        case 10:
            return "c10";
        case 11:
            return "c11";
        case 12:
            return "c12";
        case 13:
            return "c13";
        case 14:
            return "c14";
        case 15:
            return "c15";
        default:
            break;
    }

    return "INVALID";
}

string quad_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "q0";
        case 1:
            return "q1";
        case 2:
            return "q2";
        case 3:
            return "q3";
        case 4:
            return "q4";
        case 5:
            return "q5";
        case 6:
            return "q6";
        case 7:
            return "q7";
        case 8:
            return "q8";
        case 9:
            return "q9";
        case 10:
            return "q10";
        case 11:
            return "q11";
        case 12:
            return "q12";
        case 13:
            return "q13";
        case 14:
            return "q14";
        case 15:
            return "q15";
        default:
            break;
    }

    return "INVALID";
}

string double_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "d0";
        case 1:
            return "d1";
        case 2:
            return "d2";
        case 3:
            return "d3";
        case 4:
            return "d4";
        case 5:
            return "d5";
        case 6:
            return "d6";
        case 7:
            return "d7";
        case 8:
            return "d8";
        case 9:
            return "d9";
        case 10:
            return "d10";
        case 11:
            return "d11";
        case 12:
            return "d12";
        case 13:
            return "d13";
        case 14:
            return "d14";
        case 15:
            return "d15";
        case 16:
            return "d16";
        case 17:
            return "d17";
        case 18:
            return "d18";
        case 19:
            return "d19";
        case 20:
            return "d20";
        case 21:
            return "d21";
        case 22:
            return "d22";
        case 23:
            return "d23";
        case 24:
            return "d24";
        case 25:
            return "d25";
        case 26:
            return "d26";
        case 27:
            return "d27";
        case 28:
            return "d28";
        case 29:
            return "d29";
        case 30:
            return "d30";
        case 31:
            return "d31";
        default:
            break;
    }

    return "INVALID";
}

string simple_reg_str(unsigned coproc) {
    switch (coproc) {
        case 0:
            return "s0";
        case 1:
            return "s1";
        case 2:
            return "s2";
        case 3:
            return "s3";
        case 4:
            return "s4";
        case 5:
            return "s5";
        case 6:
            return "s6";
        case 7:
            return "s7";
        case 8:
            return "s8";
        case 9:
            return "s9";
        case 10:
            return "s10";
        case 11:
            return "s11";
        case 12:
            return "s12";
        case 13:
            return "s13";
        case 14:
            return "s14";
        case 15:
            return "s15";
        case 16:
            return "s16";
        case 17:
            return "s17";
        case 18:
            return "s18";
        case 19:
            return "s19";
        case 20:
            return "s20";
        case 21:
            return "s21";
        case 22:
            return "s22";
        case 23:
            return "s23";
        case 24:
            return "s24";
        case 25:
            return "s25";
        case 26:
            return "s26";
        case 27:
            return "s27";
        case 28:
            return "s28";
        case 29:
            return "s29";
        case 30:
            return "s30";
        case 31:
            return "s31";
        default:
            break;
    }

    return "INVALID";
}

string option_str(const ARMInstruction *ins) {
    switch (ins->id) {
        case dbg:
            return integer_to_string(ins->option, ins->option >= 10);
        case dmb:
        case dsb:
            if (ins->option == 15)
                return "SY";
            else if (ins->option == 14)
                return "ST";
            else if (ins->option == 11)
                return "ISH";
            else if (ins->option == 10)
                return "ISHST";
            else if (ins->option == 7)
                return "NSH";
            else if (ins->option == 6)
                return "NSHST";
            else if (ins->option == 3)
                return "OSH";
            else if (ins->option == 2)
                return "OSHST";
            else
                return "#" + integer_to_string(ins->option, ins->option >= 10);
            break;
        case isb:
            if (ins->option == 15)
                return "SY";
            else
                return "#" + integer_to_string(ins->option, true);
            break;
        case stc_stc2:
        case ldc_ldc2_immediate:
        case ldc_ldc2_literal:
            // HACK: In this case ins->imm32 >> 2 == ins->imm8
            return "{" + integer_to_string(ins->imm32 >> 2, (ins->imm32 >> 2) >= 10) + "}";
        default:
            break;
    }

    return "INVALID";
}

string endian_specifier_str(unsigned endian) {
    return endian ? "BE" : "LE";
}

string spec_reg_str(const ARMInstruction *ins) {
    string t;

    switch(ins->id) {
        case vmrs:
            switch(ins->reg) {
                case 0: return "FPSID";
                case 1: return "FPSCR";
                case 6: return "MVFR1";
                case 7: return "MVFR0";
                case 8: return "FPEXC";
                default: return "VFP_CUSTOM_REG_" + to_string(ins->reg);
            }
            break;
        case vmsr:
            switch(ins->reg) {
                case 0: return "FPSID";
                case 1: return "FPSCR";
                case 8: return "FPEXC";
                default: return "VFP_CUSTOM_REG_" + to_string(ins->reg);
            }
            break;
        case mrs:
            return ins->read_spsr ? "SPSR" : "APSR";

        case mrs_banked_register:
            return "BANKED_REG";

        case msr_immediate:
        case msr_register:
            t = ins->write_spsr ? "SPSR_" : "CPSR_";

            if (!ins->write_spsr && ins->mask == 8) return "APSR_nzcvq";
            if (!ins->write_spsr && ins->mask == 4) return "APSR_g";
            if (!ins->write_spsr && ins->mask == 12) return "APSR_nzcvqg";

            if (ins->mask & (1 << 3)) t += "f";
            if (ins->mask & (1 << 2)) t += "s";
            if (ins->mask & (1 << 1)) t += "x";
            if (ins->mask & (1 << 0)) t += "c";
            return t;

        default:
            break;
    }

    return "INVALID";
}

string registers_str(unsigned registers) {
    string regs;
    bool f = false;
    for (unsigned i = 0; i < 32; i++) {
        if (get_bit(registers, i)) {
            regs += i && f ? ", " : "";
            f = true;
            regs += string(regular_reg_str(i));
        }
    }

    return "{" + regs + "}";
}

string shift_str(unsigned shift_t, unsigned shift_n) {
    if (shift_t == Disassembler::SRType_RRX && shift_n == 1)
        return string(shift_type_str(shift_t));

    string shift = string(shift_type_str(shift_t)) + " #" + integer_to_string(shift_n, false);
    return shift;
}

string rotation_str(unsigned rotation) {
    switch(rotation) {
        case 0:
            return "";
        case 8:
            return "ROR #8";
        case 16:
            return "ROR #16";
        case 24:
            return "ROR #24";
    }

    return "INVALID";
}

string R0_R14_APSR_nzcv(const ARMInstruction *ins) {
    return ins->t == 15 ? string("apsr_nzcv") : regular_reg_str(ins->t);
}

'''

to_string_h = '''// Warning! autogenerated file, do what you want.
#include <string>
#include "arm/ARMDisassembler.h"

bool is_conditional_thumb(const Disassembler::ARMInstruction *ins);
std::string B_str(const Disassembler::ARMInstruction *ins);
std::string IA_str(const Disassembler::ARMInstruction *ins);
std::string N_str(const Disassembler::ARMInstruction *ins);
std::string R_str(const Disassembler::ARMInstruction *ins);
std::string S_str(const Disassembler::ARMInstruction *ins);
std::string U_str(const Disassembler::ARMInstruction *ins);
std::string W_str(const Disassembler::ARMInstruction *ins);
std::string X_str(const Disassembler::ARMInstruction *ins);
std::string align_str(const Disassembler::ARMInstruction *ins);
std::string amode_str(const Disassembler::ARMInstruction *ins);
std::string banked_reg(const Disassembler::ARMInstruction *ins);
std::string c_str(const Disassembler::ARMInstruction *ins);
std::string coproc_reg_str(unsigned coproc);
std::string coproc_str(unsigned coproc);
std::string double_reg_str(unsigned coproc);
std::string dt_str(const Disassembler::ARMInstruction *ins);
std::string effect_str(const Disassembler::ARMInstruction *ins);
std::string endian_specifier_str(unsigned endian);
std::string iflags_str(const Disassembler::ARMInstruction *ins);
std::string list_str(const Disassembler::ARMInstruction *ins);
std::string mode_str(const Disassembler::ARMInstruction *ins);
std::string op_str(const Disassembler::ARMInstruction *ins);
std::string option_str(const Disassembler::ARMInstruction *ins);
std::string quad_reg_str(unsigned coproc);
std::string registers_str(unsigned registers);
std::string regular_reg_str(unsigned reg);
std::string rotation_str(unsigned rotation);
std::string shift_str(unsigned shift_t, unsigned shift_n);
std::string shift_type_str(unsigned shift);
std::string simple_reg_str(unsigned coproc);
std::string size_str(const Disassembler::ARMInstruction *ins);
std::string spec_reg_str(const Disassembler::ARMInstruction *ins);
std::string type_str(const Disassembler::ARMInstruction *ins);
std::string x_str(const Disassembler::ARMInstruction *ins);
std::string y_str(const Disassembler::ARMInstruction *ins);
'''
def create_to_string(to_string_name_h, to_string_name_cpp):
    import ARMv7Parser
    parser = ARMv7Parser.InstructionFormatParser()
    names = set()

    reg2string = {}
    reg2string["Ra"] = "regular_reg_str(ins->a).c_str()"
    reg2string["Rd"] = "regular_reg_str(ins->d).c_str()"
    reg2string["RdHi"] = "regular_reg_str(ins->dHi).c_str()"
    reg2string["RdLo"] = "regular_reg_str(ins->dLo).c_str()"
    reg2string["Rdm"] = "regular_reg_str(ins->d).c_str()"
    reg2string["Rdn"] = "regular_reg_str(ins->d).c_str()"
    reg2string["Rm"] = "regular_reg_str(ins->m).c_str()"
    reg2string["Rn"] = "regular_reg_str(ins->n).c_str()"
    reg2string["Rs"] = "regular_reg_str(ins->s).c_str()"
    reg2string["Rt"] = "regular_reg_str(ins->t).c_str()"
    reg2string["Rt2"] = "regular_reg_str(ins->t2).c_str()"

    reg2string["imm"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm6"] = "integer_to_string(ins->imm32).c_str()"
    reg2string["imm32"] = "integer_to_string(ins->imm32).c_str()"

    reg2string["shift_n"] = "integer_to_string(ins->shift_n, ins->shift_n >= 10).c_str()"
    reg2string["saturate_to"] = "integer_to_string(ins->saturate_to, false).c_str()"
    reg2string["label"] = "integer_to_string(ins->imm32 + (EncodingIsThumb(ins->encoding) ? 4 : 8)).c_str()"

    reg2string["lsb"] = "integer_to_string(ins->lsbit, ins->lsbit >= 10).c_str()"
    reg2string["width"] = "integer_to_string(ins->msbit - ins->lsbit + 1, ins->msbit - ins->lsbit + 1 >= 10).c_str()"
    reg2string["widthminus1"] = "integer_to_string(ins->widthminus1 + 1, ins->widthminus1 + 1 >= 10).c_str()"

    reg2string["type"] = "shift_type_str(ins->shift_t).c_str()"
    reg2string["coproc"] = "coproc_str(ins->coproc).c_str()"
    reg2string["opc1"] = "integer_to_string(ins->opc1, ins->opc1 >= 10).c_str()"
    reg2string["opc2"] = "integer_to_string(ins->opc2, ins->opc2 >= 10).c_str()"

    reg2string["CRd"] = "coproc_reg_str(ins->CRd).c_str()"
    reg2string["CRn"] = "coproc_reg_str(ins->CRn).c_str()"
    reg2string["CRm"] = "coproc_reg_str(ins->CRm).c_str()"

    reg2string["option"] = "option_str(ins).c_str()"
    reg2string["registers"] = "registers_str(ins->registers).c_str()"
    reg2string["spec_reg"] = "spec_reg_str(ins).c_str()"
    reg2string["endian_specifier"] = "endian_specifier_str(ins->set_bigend).c_str()"

    reg2string["Qd"] = "quad_reg_str(ins->d >> 1).c_str()"
    reg2string["Qn"] = "quad_reg_str(ins->n >> 1).c_str()"
    reg2string["Qm"] = "quad_reg_str(ins->m >> 1).c_str()"

    reg2string["Dd"] = "double_reg_str(ins->d).c_str()"
    reg2string["Dn"] = "double_reg_str(ins->n).c_str()"
    reg2string["Dm"] = "double_reg_str(ins->m).c_str()"

    reg2string["Sd"] = "simple_reg_str(ins->d).c_str()"
    reg2string["Sn"] = "simple_reg_str(ins->n).c_str()"
    reg2string["Sm"] = "simple_reg_str(ins->m).c_str()"

    reg2string["shift"] = "shift_str(ins->shift_t, ins->shift_n).c_str()"
    reg2string["rotation"] = "rotation_str(ins->rotation).c_str()"

    reg2string["list"] = "list_str(ins).c_str()"

    reg2string["Dd[x]"] = "(double_reg_str(ins->d) + \"[\" + to_string(ins->index) + \"]\").c_str()"
    reg2string["Dn[x]"] = "(double_reg_str(ins->n) + \"[\" + to_string(ins->index) + \"]\").c_str()"
    reg2string["Dm[x]"] = "(double_reg_str(ins->m) + \"[\" + to_string(ins->index) + \"]\").c_str()"

    # reg2string["Dd[x]"] = "\"TODO_Dd[x]\""
    # reg2string["Dn[x]"] = "\"TODO_Dn[x]\""
    # reg2string["Dm[x]"] = "\"TODO_Dm[x]\""

    reg2string["iflags"] = "iflags_str(ins).c_str()"
    reg2string["shift_amount"] = "integer_to_string(ins->shift_amount, true).c_str()"
    reg2string["mode"] = "integer_to_string(ins->mode, false).c_str()"
    reg2string["registers_with_pc"] = "registers_str(ins->registers | (1 << 15)).c_str()"
    reg2string["registers_without_pc"] = "registers_str(ins->registers & ((1 << 15) - 1)).c_str()"

    reg2string["R0_R14_APSR_nzcv"] = "R0_R14_APSR_nzcv(ins).c_str()"

    reg2string["banked_reg"] = "banked_reg(ins).c_str()"

    # Create the implementation file.
    with open(to_string_name_cpp, "w") as fd:
        fd.write(to_string_cpp)

        s = set()

        for instruction in instructions:
            # Skip the custom ones as they are handled in 'create_to_string_custom'.
            if "CUSTOM" == instruction["format"]:
                continue

            # TODO: Handle the case when an instruction is inside an IT block.
            format = instruction["format"]
            if ":" in format:
                format = format.split(":")[0]

            # Parse the toString format.
            r = parser.parseString(format)

            # We divide the instruction in two pices, the name and the arguments.
            op_name = r[0]
            op_args = ARMv7Parser.MandatoryToken("")
            if len(r) == 2:
                op_args = r[1]

            # Write the header with the common structures.
            fd.write("string %s_to_string(const ARMInstruction *ins) {\n" % instruction_decoder_name(instruction))
            fd.write("    // DEBUG: %s\n" % format)
            fd.write("    char op_name[256], op_args[256];\n")
            fd.write("    snprintf(op_name, sizeof(op_name),\n")
            fd.write("            \"%s%s\"" % (op_name.name[0], "%s" * (len(op_name.name) - 1)))

            # Skip the last comma if the name has no variable pieces.
            if len(op_name.name[1:]) != 0:
                fd.write(",")
            fd.write("\n")

            # For each of the name's variables.
            for i, val in enumerate(op_name.name[1:]):
                if type(val) is ARMv7Parser.OptionalToken:
                    assert len(val.name) == 1
                    fd.write("            %s_str(ins).c_str()" % str(val.name[0]))

                    # Whenever we change the ARMv7DecodingSpec.py we need to re-enble this and fix stuff.
                    # if not str(val) in ["<c>", "{S}"]:
                    #    print val, "case %s:" % instruction_id_name(instruction), "//", instruction["name"]

                elif type(val) is ARMv7Parser.MandatoryToken:
                    fd.write("            %s_str(ins).c_str()" % str(val.name))

                    # Whenever we change the ARMv7DecodingSpec.py we need to re-enble this and fix stuff.
                    # if not str(val) in ["<c>", "{S}"]:
                    #    print val, "case %s:" % instruction_id_name(instruction), "//", instruction["name"]

                else:
                    fd.write("            \"%s\"" % val)

                if i != len(op_name.name[1:]) - 1:
                    fd.write(",")

                fd.write("\n")

            fd.write("    );\n\n")

            # Skip the rest if there are no arguments to the instruction.
            if not len(op_args.name):
                fd.write("    return string(op_name);\n")
                fd.write("}\n\n")
                continue

            fd.write("    snprintf(op_args, sizeof(op_args),\n")

            format_string = ""
            vars = []
            for i, val in enumerate(op_args.name):
                if type(val) is ARMv7Parser.MandatoryToken:
                    if val.pound:
                        format_string += val.pound

                    # Add the format string for the sign if needed.
                    if val.sign == "+/-":
                        format_string += "%s"
                        vars.append("ins->add ? \"\" : \"-\"")

                    else:
                        format_string += val.sign

                    format_string += "%s"
                    vars.append(reg2string[val.name])

                elif type(val) is ARMv7Parser.OptionalToken:
                    for optional in val.name:
                        # If the token is the write back optional emit the corresponding code.
                        if type(optional) == type(""):
                            # The only string that is optional given an ins is the writeback sign.
                            if optional == "!":
                                format_string += "%s"
                                vars.append("ins->wback ? \"!\" : \"\"")

                            else:
                                format_string += optional
                        else:
                            if optional.pound == "#":
                                format_string += "#"

                            if optional.sign == "-":
                                format_string += "-"

                            elif optional.sign == "+/-":
                                format_string += "%s"
                                vars.append("ins->add ? \"\" : \"-\"")

                            format_string += "%s"
                            vars.append(reg2string[optional.name])

                else:
                    format_string += val

            fd.write("            \"%s\",\n" % format_string)

            for i, var in enumerate(vars):
                fd.write("            %s" % var)
                if i < len(vars) - 1:
                    fd.write(",")

                fd.write("\n")

            fd.write("    );\n\n")
            fd.write("    return string(op_name) + string(op_args);\n")
            fd.write("}\n\n")

    # Create the header file.
    with open(to_string_name_h, "w") as fd:
        fd.write(to_string_h)

        for instruction in instructions:
            if "CUSTOM" == instruction["format"].split()[0]:
                continue

            fd.write("std::string %s_to_string(const Disassembler::ARMInstruction *ins);\n" % instruction_decoder_name(instruction))

    return True

to_string_custom_h = '''// Warning! autogenerated file, do what you want.
#include <string>
#include "arm/ARMDisassembler.h"

'''

to_string_custom_cpp = '''// Warning! autogenerated file, do what you want.
#include <string>
#include <cstdlib>
#include <cstdio>

#include "arm/ARMDisassembler.h"
#include "arm/ARMUtilities.h"
#include "arm/gen/ARMDecodingTable.h"
#include "arm/gen/ARMtoString.h"
#include "arm/gen/ARMtoStringCustom.h"
#include "Utilities.h"

using namespace Disassembler;

'''
def create_to_string_custom(to_string_custom_name_h, to_string_custom_name_cpp):
    # Create the header file.
    with open(to_string_custom_name_h, "w") as fd:
        fd.write(to_string_custom_h)

        for instruction in filter(lambda x: x["format"] == "CUSTOM", instructions):
            fd.write("std::string %s_to_string(const Disassembler::ARMInstruction *ins);\n" % instruction_decoder_name(instruction))

    # Create the implementation file.
    with open(to_string_custom_name_cpp, "w") as fd:
        fd.write(to_string_custom_cpp)

        s = set()

        for instruction in filter(lambda x: x["format"] == "CUSTOM", instructions):
            fd.write("// Instruction: %s\n// Encoding: %s\n" % (instruction["name"], instruction["encoding"]))
            fd.write("std::string %s_to_string(const Disassembler::ARMInstruction *ins) {\n" % instruction_decoder_name(instruction))
            fd.write("    char buffer[64];\n")
            fd.write("    snprintf(buffer, sizeof(buffer), \"TODO_%s_%s\");\n" % (instruction_id_name(instruction), instruction["encoding"]))
            fd.write("\n")
            fd.write("    return std::string(buffer);\n")
            fd.write("}\n")
            fd.write("\n")

    return True

def backup_file(path):
    import time
    import shutil
    backup_name = "%s_%s.bak" % (path, time.strftime("%Y%m%d"))
    shutil.copyfile(path, backup_name)
    return backup_name

def main():
    logging.basicConfig(level=logging.INFO)

    parser = argparse.ArgumentParser(description='Generator.')
    parser.add_argument("--gendir", default="../gen", help="Directory where the generated files will be placed.")
    parser.add_argument("--gen_custom_to_str", action='store_true', help="Generate ARMtoStringCustom[.h|.cpp] stubs")
    parser.add_argument("--gen_to_str", action='store_true', help="Generate ARMtoString[.h|.cpp] stubs")
    parser.add_argument("--gen_decoder", action='store_true', help="Generate ARMDecodingTable[.h|.cpp]")
    parser.add_argument("--debug", action='store_true', help="Enable debugging information, just for developers.")

    args = parser.parse_args()

    DEBUG = args.debug
    gen_custom_to_string = args.gen_custom_to_str
    gen_to_string = args.gen_to_str
    gen_decoder = args.gen_decoder

    if not any([gen_custom_to_string, gen_to_string, gen_decoder]):
        logging.warn("Nothing to generate, please choose one option")
        parser.print_help()
        return

    # Filenames and path's.
    gen_dir = os.path.abspath(args.gendir)
    decoder_name_h = os.path.join(gen_dir, "ARMDecodingTable.h")
    decoder_name_cpp = os.path.join(gen_dir, "ARMDecodingTable.cpp")
    to_string_name_h = os.path.join(gen_dir, "ARMtoString.h")
    to_string_name_cpp = os.path.join(gen_dir, "ARMtoString.cpp")
    to_string_custom_name_h = os.path.join(gen_dir, "ARMtoStringCustom.h")
    to_string_custom_name_cpp = os.path.join(gen_dir, "ARMtoStringCustom.cpp")

    if not os.path.exists(gen_dir):
        logging.info("Directory '%s' does not exist, creating it ..." % gen_dir)
        os.makedirs(gen_dir)

    logging.info("Placing all the generated files in '%s'." % gen_dir)

    # We've chosen to regenerate the custom to_string placeholders.
    if gen_custom_to_string:
        if os.path.exists(to_string_custom_name_h):
            backup_name = backup_file(to_string_custom_name_h)
            logging.info("File (%s) exists, I'll backup it to %s." % (to_string_custom_name_h, backup_name))
            os.remove(to_string_custom_name_h)

        if os.path.exists(to_string_custom_name_cpp):
            backup_name = backup_file(to_string_custom_name_cpp)
            logging.info("File (%s) exists, I'll backup it to %s." % (to_string_custom_name_cpp, backup_name))
            os.remove(to_string_custom_name_cpp)

        logging.info("Creating ARMtoStringCustom.h at '%s'." % to_string_custom_name_h)
        logging.info("Creating ARMtoStringCustom.cpp at '%s'." % to_string_custom_name_cpp)
        if not create_to_string_custom(to_string_custom_name_h, to_string_custom_name_cpp):
            logging.error("Could not create custom to_string stubs.")
            return False


    # We've chosen to regenerate the decoders.
    if gen_decoder:
        if os.path.exists(decoder_name_h):
            os.remove(decoder_name_h)

        if os.path.exists(decoder_name_cpp):
            os.remove(decoder_name_cpp)

        logging.info("Creating decoders at '%s'." % decoder_name_h)
        logging.info("Creating decoders at '%s'." % decoder_name_cpp)
        if not create_decoders(decoder_name_h, decoder_name_cpp):
            logging.error("Could not create the decoders.")
            return False

    # Regenerate the to_string methods.
    if gen_to_string:
        if os.path.exists(to_string_name_h):
            os.remove(to_string_name_h)

        if os.path.exists(to_string_name_cpp):
            os.remove(to_string_name_cpp)

        logging.info("Creating to_string at '%s'." % to_string_name_h)
        logging.info("Creating to_string at '%s'." % to_string_name_cpp)
        if not create_to_string(to_string_name_h, to_string_name_cpp):
            logging.error("Could not create to_string stubs.")
            return False

    logging.info("Finished creating autogenerated stubs.")
    return True

if __name__ == '__main__':
    main()

[
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ABS <V><d>, <V><n>"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100000101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ABS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Absolute value (vector)", 
    "name": "ABS", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    endif\n    Elem[result, e, esize] = element<esize-1:0>;                \nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADC <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADC <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010000 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add with Carry", 
    "name": "ADC", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\nif sub_op then    operand2 = NOT(operand2);\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\nif setflags then    PSTATE.<N,Z,C,V> = nzcv;\n        X[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADCS <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADCS <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0111010000 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add with Carry, setting flags", 
    "name": "ADCS", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\nif sub_op then\n    operand2 = NOT(operand2);\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADD <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADD <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          }
        ], 
        "pattern": "sf#1 Rm#5 0001011001 option#3 imm3#3 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (extended register)", 
    "name": "ADD (extended register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADD <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADD <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0010001 imm12#12 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (immediate)", 
    "name": "ADD (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADD <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADD <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0001011 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (shifted register)", 
    "name": "ADD (shifted register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADD <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 100001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (vector)", 
    "name": "ADD (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add returning High Narrow", 
    "name": "ADDHN, ADDHN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = ReduceOp_ADD;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADDP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 110001101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add Pair of elements (scalar)", 
    "name": "ADDP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 101111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add Pairwise (vector)", 
    "name": "ADDP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[concat, 2*e, esize];\n    element2 = Elem[concat, (2*e)+1, esize];\n    Elem[result, e, esize] = element1 + element2;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADDS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADDS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          }
        ], 
        "pattern": "sf#1 Rm#5 0101011001 option#3 imm3#3 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (extended register), setting flags", 
    "name": "ADDS (extended register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADDS <Wd>, <Wn|WSP>, #<imm>{, <shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADDS <Xd>, <Xn|SP>, #<imm>{, <shift>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0110001 imm12#12 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (immediate), setting flags", 
    "name": "ADDS (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ADDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ADDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0101011 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add (shifted register), setting flags", 
    "name": "ADDS (shifted register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = ReduceOp_ADD;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADDV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 110001101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Add across Vector", 
    "name": "ADDV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADR <Xd>, <label>"
          }
        ], 
        "pattern": "immlo#2 0 immhi#19 10000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Form PC-relative address", 
    "name": "ADR", 
    "operation": "bits(64) base = PC[];\nif page then\n    base<11:0> = Zeros(12);\nendif\nX[d] = base + imm;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\nboolean page = (op == '1');\nbits(64) imm;\nif page then\n    imm = SignExtend(immhi:immlo:Zeros(12), 64);\nelse\n    imm = SignExtend(immhi:immlo, 64);\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ADRP <Xd>, <label>"
          }
        ], 
        "pattern": "immlo#2 1 immhi#19 10000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Form PC-relative address to 4KB page", 
    "name": "ADRP", 
    "operation": "bits(64) base = PC[];\nif page then\n    base<11:0> = Zeros(12);\nendif\nX[d] = base + imm;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "AESD <Vd>.16B, <Vn>.16B"
          }
        ], 
        "pattern": "Rn#5 0100111000101000010110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "AES single round decryption", 
    "name": "AESD", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "AESE <Vd>.16B, <Vn>.16B"
          }
        ], 
        "pattern": "Rn#5 0100111000101000010010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "AES single round encryption", 
    "name": "AESE", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nresult = operand1 EOR operand2;\nif decrypt then\n    result = AESInvSubBytes(AESInvShiftRows(result));\nelse\n    result = AESSubBytes(AESShiftRows(result));\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "AESIMC <Vd>.16B, <Vn>.16B"
          }
        ], 
        "pattern": "Rn#5 0100111000101000011110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "AES inverse mix columns", 
    "name": "AESIMC", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean decrypt = (D == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "AESMC <Vd>.16B, <Vn>.16B"
          }
        ], 
        "pattern": "Rn#5 0100111000101000011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "AES mix columns", 
    "name": "AESMC", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand = V[n];\nbits(128) result;\nif decrypt then\n    result = AESInvMixColumns(operand);\nelse\n    result = AESMixColumns(operand);\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "AND <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110001 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise AND (vector)", 
    "name": "AND (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "AND <Wd|WSP>, <Wn>, #<imm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "AND <Xd|SP>, <Xn>, #<imm>"
          }
        ], 
        "pattern": "sf#1 N#1 00100100 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise AND (immediate)", 
    "name": "AND (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "AND <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "AND <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0001010 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise AND (shifted register)", 
    "name": "AND (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "ANDS <Wd>, <Wn>, #<imm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ANDS <Xd>, <Xn>, #<imm>"
          }
        ], 
        "pattern": "sf#1 N#1 11100100 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise AND (immediate), setting flags", 
    "name": "ANDS (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ANDS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ANDS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1101010 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise AND (shifted register), setting flags", 
    "name": "ANDS (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ASRV <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ASRV <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 Rn#5 001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Arithmetic Shift Right Variable", 
    "name": "ASRV", 
    "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "AUTDA <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "AUTDZA <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Authenticate Data address, using key A", 
    "name": "AUTDA, AUTDZA", 
    "operation": "if source_is_sp then\n    X[d] = AuthDA(X[d], SP[]);\nelse\n    X[d] = AuthDA(X[d], X[n]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "AUTDB <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "AUTDZB <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Authenticate Data address, using key B", 
    "name": "AUTDB, AUTDZB", 
    "operation": "if source_is_sp then\n    X[d] = AuthDB(X[d], SP[]);\nelse\n    X[d] = AuthDB(X[d], X[n]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "AUTIA <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "AUTIZA <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 100 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "CRm", 
            "==", 
            "00x1"
          ], 
          [
            "op2", 
            "==", 
            "10x"
          ]
        ], 
        "decoder_pre": "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\ncase CRm:op2 of\n    when '0011100' \n        d = 30;\n        n = 31;\n    when '0011101' \n        d = 30;\n        source_is_sp = TRUE;\n    when '0001100' \n        d = 17;\n        n = 16;\n    when '0001000' SEE \"PACIA\";\n    when '0001010' SEE \"PACIB\";\n    when '0001110' SEE \"AUTIB\";\n    when '001100x' SEE \"PACIA\";\n    when '001101x' SEE \"PACIB\";\n    when '001111x' SEE \"AUTIB\";\n    when '0000111' SEE \"XPACLRI\";\n    otherwise SEE \"HINT\";\nendcase\n", 
        "encodings": [
          {
            "condition": "CRm == 0001 && op2 == 100", 
            "format": "AUTIA1716"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 101", 
            "format": "AUTIASP"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 100", 
            "format": "AUTIAZ"
          }
        ], 
        "pattern": "CRm#4 11010101000000110010 op2#3 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Authenticate Instruction address, using key A", 
    "name": "AUTIA, AUTIA1716, AUTIASP, AUTIAZ, AUTIZA", 
    "operation": "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthIA(X[d], SP[]);\n    else\n        X[d] = AuthIA(X[d], X[n]);\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "AUTIB <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "AUTIZB <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "CRm", 
            "==", 
            "00x1"
          ], 
          [
            "op2", 
            "==", 
            "11x"
          ]
        ], 
        "decoder_pre": "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\ncase CRm:op2 of\n    when '0011110' \n        d = 30;\n        n = 31;\n    when '0011111' \n        d = 30;\n        source_is_sp = TRUE;\n    when '0001110' \n        d = 17;\n        n = 16;\n    when '0001000' SEE \"PACIA\";\n    when '0001010' SEE \"PACIB\";\n    when '0001100' SEE \"AUTIA\";\n    when '001100x' SEE \"PACIA\";\n    when '001101x' SEE \"PACIB\";\n    when '001110x' SEE \"AUTIA\";\n    when '0000111' SEE \"XPACLRI\";\nendcase\n", 
        "encodings": [
          {
            "condition": "CRm == 0001 && op2 == 110", 
            "format": "AUTIB1716"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 111", 
            "format": "AUTIBSP"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 110", 
            "format": "AUTIBZ"
          }
        ], 
        "pattern": "CRm#4 11010101000000110010 op2#3 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Authenticate Instruction address, using key B", 
    "name": "AUTIB, AUTIB1716, AUTIBSP, AUTIBZ, AUTIZB", 
    "operation": "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AuthIB(X[d], SP[]);\n    else\n        X[d] = AuthIB(X[d], X[n]);\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(64) offset = SignExtend(imm19:'00', 64);\nbits(4) condition = cond;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "B.<cond> <label>"
          }
        ], 
        "pattern": "imm19#19 01010100 cond#4 0", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch conditionally", 
    "name": "B.cond", 
    "operation": "if ConditionHolds(condition) then\n    BranchTo(PC[] + offset, BranchType_JMP);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;\nbits(64) offset = SignExtend(imm26:'00', 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "B <label>"
          }
        ], 
        "pattern": "imm26#26 000101", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch", 
    "name": "B", 
    "operation": "if branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(PC[] + offset, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BCAX <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
          }
        ], 
        "pattern": "Rm#5 11001110001 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bit Clear and XOR", 
    "name": "BCAX", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR (Vm AND NOT(Va));\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    \n    when '01' inzero = FALSE; extend = FALSE;   \n    when '10' inzero = TRUE;  extend = FALSE;   \n    when '11' UnallocatedEncoding();\nendcase\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "BFM <Wd>, <Wn>, #<immr>, #<imms>"
          }, 
          {
            "condition": "sf == 1 && N == 1", 
            "format": "BFM <Xd>, <Xn>, #<immr>, #<imms>"
          }
        ], 
        "pattern": "sf#1 N#1 01100110 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitfield Move", 
    "name": "BFM", 
    "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "cmode", 
            "==", 
            "xxx1"
          ]
        ], 
        "decoder_pre": "integer rd = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\nendcase\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);\n", 
        "encodings": [
          {
            "condition": "cmode == 10x1", 
            "format": "BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }, 
          {
            "condition": "cmode == 0xx1", 
            "format": "BIC <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }
        ], 
        "pattern": "Q#1 0 a#1 10111100000 b#1 c#1 cmode#4 d#1 01 e#1 f#1 g#1 h#1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise bit Clear (vector, immediate)", 
    "name": "BIC (vector, immediate)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\nendcase\nV[rd] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BIC <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110011 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise bit Clear (vector, register)", 
    "name": "BIC (vector, register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "BIC <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "BIC <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0001010 Rm#5 1 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Bit Clear (shifted register)", 
    "name": "BIC (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "BICS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "BICS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1101010 Rm#5 1 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Bit Clear (shifted register), setting flags", 
    "name": "BICS (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nVBitOp op;\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BIF <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110111 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Insert if False", 
    "name": "BIF", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\nendcase\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nVBitOp op;\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BIT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110101 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Insert if True", 
    "name": "BIT", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\nendcase\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "BranchType branch_type = if op == '1' then BranchType_CALL else BranchType_JMP;\nbits(64) offset = SignExtend(imm26:'00', 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BL <label>"
          }
        ], 
        "pattern": "imm26#26 100101", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch with Link", 
    "name": "BL", 
    "operation": "if branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(PC[] + offset, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\nendif\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\nendcase\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n    endif\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;\n    endif\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BLR <Xn>"
          }
        ], 
        "pattern": "Rn#5 1101011000111111000000 00000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch with Link to Register", 
    "name": "BLR", 
    "operation": "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n    endif\nendif\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\nendif\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\nendcase\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n    endif\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;\n    endif\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0 && M == 0 && Rm == 11111", 
            "format": "BLRAAZ <Xn>"
          }, 
          {
            "condition": "Z == 1 && M == 0", 
            "format": "BLRAA <Xn>, <Xm|SP>"
          }, 
          {
            "condition": "Z == 0 && M == 1 && Rm == 11111", 
            "format": "BLRABZ <Xn>"
          }, 
          {
            "condition": "Z == 1 && M == 1", 
            "format": "BLRAB <Xn>, <Xm|SP>"
          }
        ], 
        "pattern": "Z#1 1101011 M#1 0011111100001 Rn#5 Rm#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch with Link to Register, with pointer authentication", 
    "name": "BLRAA, BLRAAZ, BLRAB, BLRABZ", 
    "operation": "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n    endif\nendif\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\nendif\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\nendcase\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n    endif\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;\n    endif\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BR <Xn>"
          }
        ], 
        "pattern": "Rn#5 1101011000011111000000 00000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch to Register", 
    "name": "BR", 
    "operation": "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n    endif\nendif\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\nendif\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\nendcase\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n    endif\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;\n    endif\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0 && M == 0 && Rm == 11111", 
            "format": "BRAAZ <Xn>"
          }, 
          {
            "condition": "Z == 1 && M == 0", 
            "format": "BRAA <Xn>, <Xm|SP>"
          }, 
          {
            "condition": "Z == 0 && M == 1 && Rm == 11111", 
            "format": "BRABZ <Xn>"
          }, 
          {
            "condition": "Z == 1 && M == 1", 
            "format": "BRAB <Xn>, <Xm|SP>"
          }
        ], 
        "pattern": "Z#1 1101011 M#1 0001111100001 Rn#5 Rm#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Branch to Register, with pointer authentication", 
    "name": "BRAA, BRAAZ, BRAB, BRABZ", 
    "operation": "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n    endif\nendif\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(16) comment = imm16;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BRK #<imm>"
          }
        ], 
        "pattern": "imm16#16 11010100001 00000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Breakpoint instruction", 
    "name": "BRK", 
    "operation": "AArch64.SoftwareBreakpoint(comment);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nVBitOp op;\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "BSL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110011 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Select", 
    "name": "BSL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\nendcase\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "size == 10 && L == 1 && o0 == 0", 
            "format": "CASA <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 10 && L == 1 && o0 == 1", 
            "format": "CASAL <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 10 && L == 0 && o0 == 0", 
            "format": "CAS <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 10 && L == 0 && o0 == 1", 
            "format": "CASL <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11 && L == 1 && o0 == 0", 
            "format": "CASA <Xs>, <Xt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11 && L == 1 && o0 == 1", 
            "format": "CASAL <Xs>, <Xt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11 && L == 0 && o0 == 0", 
            "format": "CAS <Xs>, <Xt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11 && L == 0 && o0 == 1", 
            "format": "CASL <Xs>, <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 L#1 0010001 Rs#5 1 o0#1 Rn#5 11111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare and Swap word or doubleword in memory", 
    "name": "CAS, CASA, CASAL, CASL", 
    "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\nendif\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    Mem[address, datasize DIV 8, stacctype] = newvalue;\nendif\nX[s] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "L == 1 && o0 == 0", 
            "format": "CASAB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "L == 1 && o0 == 1", 
            "format": "CASALB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "L == 0 && o0 == 0", 
            "format": "CASB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "L == 0 && o0 == 1", 
            "format": "CASLB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "L#1 000010001 Rs#5 1 o0#1 Rn#5 11111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare and Swap byte in memory", 
    "name": "CASB, CASAB, CASALB, CASLB", 
    "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\nendif\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    Mem[address, datasize DIV 8, stacctype] = newvalue;\nendif\nX[s] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "L == 1 && o0 == 0", 
            "format": "CASAH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "L == 1 && o0 == 1", 
            "format": "CASALH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "L == 0 && o0 == 0", 
            "format": "CASH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "L == 0 && o0 == 1", 
            "format": "CASLH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "L#1 010010001 Rs#5 1 o0#1 Rn#5 11111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare and Swap halfword in memory", 
    "name": "CASH, CASAH, CASALH, CASLH", 
    "operation": "bits(64) address;\nbits(datasize) comparevalue;\nbits(datasize) newvalue;\nbits(datasize) data;\ncomparevalue = X[s];\nnewvalue = X[t];\nif n == 31 then \n    CheckSPAlignment(); \n    address = SP[];\nelse \n    address = X[n];\nendif\ndata = Mem[address, datasize DIV 8, ldacctype];\nif data == comparevalue then  \n    Mem[address, datasize DIV 8, stacctype] = newvalue;\nendif\nX[s] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\nif Rs<0> == '1' then UnallocatedEncoding();\nif Rt<0> == '1' then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);\ninteger datasize = 32 << UInt(sz);\ninteger regsize = datasize;\nAccType ldacctype = if L == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if o0 == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "sz == 0 && L == 1 && o0 == 0", 
            "format": "CASPA <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 0 && L == 1 && o0 == 1", 
            "format": "CASPAL <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 0 && L == 0 && o0 == 0", 
            "format": "CASP <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 0 && L == 0 && o0 == 1", 
            "format": "CASPL <Ws>, <W(s+1)>, <Wt>, <W(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1 && L == 1 && o0 == 0", 
            "format": "CASPA <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1 && L == 1 && o0 == 1", 
            "format": "CASPAL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1 && L == 0 && o0 == 0", 
            "format": "CASP <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1 && L == 0 && o0 == 1", 
            "format": "CASPL <Xs>, <X(s+1)>, <Xt>, <X(t+1)>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "sz#1 0 L#1 0010000 Rs#5 1 o0#1 Rn#5 11111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare and Swap Pair of words or doublewords in memory", 
    "name": "CASP, CASPA, CASPAL, CASPL", 
    "operation": "bits(64) address;\nbits(2*datasize) comparevalue;\nbits(2*datasize) newvalue;\nbits(2*datasize) data;\nbits(datasize) s1 = X[s];\nbits(datasize) s2 = X[s+1];\nbits(datasize) t1 = X[t];\nbits(datasize) t2 = X[t+1];\ncomparevalue = if BigEndian() then s1:s2 else s2:s1;\nnewvalue     = if BigEndian() then t1:t2 else t2:t1;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, (2 * datasize) DIV 8, ldacctype];\nif data == comparevalue then\n    Mem[address, (2 * datasize) DIV 8, stacctype] = newvalue;\nendif\nif BigEndian() then\n    X[s]   = ZeroExtend(data<2*datasize-1:datasize>, regsize);\n    X[s+1] = ZeroExtend(data<datasize-1:0>, regsize);\nelse\n    X[s]   = ZeroExtend(data<datasize-1:0>, regsize);\n    X[s+1] = ZeroExtend(data<2*datasize-1:datasize>, regsize);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CBNZ <Wt>, <label>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CBNZ <Xt>, <label>"
          }
        ], 
        "pattern": "sf#1 imm19#19 0110101 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare and Branch on Nonzero", 
    "name": "CBNZ", 
    "operation": "bits(datasize) operand1 = X[t];\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_JMP);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean iszero = (op == '0');\nbits(64) offset = SignExtend(imm19:'00', 64);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CBZ <Wt>, <label>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CBZ <Xt>, <label>"
          }
        ], 
        "pattern": "sf#1 imm19#19 0110100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare and Branch on Zero", 
    "name": "CBZ", 
    "operation": "bits(datasize) operand1 = X[t];\nif IsZero(operand1) == iszero then\n    BranchTo(PC[] + offset, BranchType_JMP);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CCMN <Wn>, #<imm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CCMN <Xn>, #<imm>, #<nzcv>, <cond>"
          }
        ], 
        "pattern": "sf#1 imm5#5 0111010010 cond#4 Rn#5 10 nzcv#4 0", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Compare Negative (immediate)", 
    "name": "CCMN (immediate)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    endif\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nendif\nPSTATE.<N,Z,C,V> = flags;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CCMN <Wn>, <Wm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CCMN <Xn>, <Xm>, #<nzcv>, <cond>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0111010010 cond#4 Rn#5 00 nzcv#4 0", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Compare Negative (register)", 
    "name": "CCMN (register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    endif\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nendif\nPSTATE.<N,Z,C,V> = flags;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\nbits(datasize) imm = ZeroExtend(imm5, datasize);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CCMP <Wn>, #<imm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CCMP <Xn>, #<imm>, #<nzcv>, <cond>"
          }
        ], 
        "pattern": "sf#1 imm5#5 1111010010 cond#4 Rn#5 10 nzcv#4 0", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Compare (immediate)", 
    "name": "CCMP (immediate)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\nbit carry_in = '0';\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    endif\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nendif\nPSTATE.<N,Z,C,V> = flags;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CCMP <Wn>, <Wm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CCMP <Xn>, <Xm>, #<nzcv>, <cond>"
          }
        ], 
        "pattern": "sf#1 Rm#5 1111010010 cond#4 Rn#5 00 nzcv#4 0", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Compare (register)", 
    "name": "CCMP (register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbit carry_in = '0';\nif ConditionHolds(condition) then\n    if sub_op then\n        operand2 = NOT(operand2);\n        carry_in = '1';\n    endif\n    (-, flags) = AddWithCarry(operand1, operand2, carry_in);\nendif\nPSTATE.<N,Z,C,V> = flags;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "", 
        "encodings": [
          {
            "condition": "", 
            "format": "CLREX {#<imm>}"
          }
        ], 
        "pattern": "CRm#4 11010101000000110011 01011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Clear Exclusive", 
    "name": "CLREX", 
    "operation": "ClearExclusiveLocal(ProcessorID());\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CLS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000010010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Count Leading Sign bits (vector)", 
    "name": "CLS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    endif\n    Elem[result, e, esize] = count<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CLS <Wd>, <Wn>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CLS <Xd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 Rn#5 101101011000000000101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Count leading sign bits", 
    "name": "CLS", 
    "operation": "integer result;\nbits(datasize) operand1 = X[n];\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\nendif\nX[d] = result<datasize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCountOp countop = if U == '1' then CountOp_CLZ else CountOp_CLS;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CLZ <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000010010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Count Leading Zero bits (vector)", 
    "name": "CLZ (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger count;\nfor e = 0 to elements-1\n    if countop == CountOp_CLS then\n        count = CountLeadingSignBits(Elem[operand, e, esize]);\n    else\n        count = CountLeadingZeroBits(Elem[operand, e, esize]);\n    endif\n    Elem[result, e, esize] = count<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nCountOp opcode = if op == '0' then CountOp_CLZ else CountOp_CLS;\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CLZ <Wd>, <Wn>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CLZ <Xd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 Rn#5 101101011000000000100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Count leading zero bits", 
    "name": "CLZ", 
    "operation": "integer result;\nbits(datasize) operand1 = X[n];\nif opcode == CountOp_CLZ then\n    result = CountLeadingZeroBits(operand1);\nelse\n    result = CountLeadingSignBits(operand1);\nendif\nX[d] = result<datasize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMEQ <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 100011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean and_test = (U == '0');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 100011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare bitwise Equal (vector)", 
    "name": "CMEQ (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    endif\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMEQ <V><d>, <V><n>, #0"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100000100110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMEQ <Vd>.<T>, <Vn>.<T>, #0"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000100110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare bitwise Equal to zero (vector)", 
    "name": "CMEQ (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGE <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 001111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare signed Greater than or Equal (vector)", 
    "name": "CMGE (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGE <V><d>, <V><n>, #0"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100000100010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGE <Vd>.<T>, <Vn>.<T>, #0"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare signed Greater than or Equal to zero (vector)", 
    "name": "CMGE (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGT <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 001101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare signed Greater than (vector)", 
    "name": "CMGT (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGT <V><d>, <V><n>, #0"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100000100010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMGT <Vd>.<T>, <Vn>.<T>, #0"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare signed Greater than zero (vector)", 
    "name": "CMGT (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMHI <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMHI <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 001101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare unsigned Higher (vector)", 
    "name": "CMHI (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMHS <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean cmp_eq = (eq == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMHS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 001111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare unsigned Higher or Same (vector)", 
    "name": "CMHS (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    test_passed = if cmp_eq then element1 >= element2 else element1 > element2;\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMLE <V><d>, <V><n>, #0"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100000100110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMLE <Vd>.<T>, <Vn>.<T>, #0"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000100110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare signed Less than or Equal to zero (vector)", 
    "name": "CMLE (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison = CompareOp_LT;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMLT <V><d>, <V><n>, #0"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100000101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison = CompareOp_LT;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMLT <Vd>.<T>, <Vn>.<T>, #0"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare signed Less than zero (vector)", 
    "name": "CMLT (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    case comparison of\n        when CompareOp_GT test_passed = element > 0;\n        when CompareOp_GE test_passed = element >= 0;\n        when CompareOp_EQ test_passed = element == 0;\n        when CompareOp_LE test_passed = element <= 0;\n        when CompareOp_LT test_passed = element < 0;\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean and_test = (U == '0');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMTST <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 100011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean and_test = (U == '0');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CMTST <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 100011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Compare bitwise Test bits nonzero (vector)", 
    "name": "CMTST", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if and_test then\n        test_passed = !IsZero(element1 AND element2);\n    else\n        test_passed = (element1 == element2);\n    endif\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '00' then ReservedValue();\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "CNT <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000010110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Population Count per byte", 
    "name": "CNT", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger count;\nfor e = 0 to elements-1\n    count = BitCount(Elem[operand, e, esize]);\n    Elem[result, e, esize] = count<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UnallocatedEncoding();\nif sf == '0' && sz == '11' then UnallocatedEncoding();\ninteger size = 8 << UInt(sz);   \nboolean crc32c = (C == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0 && sz == 00", 
            "format": "CRC32B <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 0 && sz == 01", 
            "format": "CRC32H <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 0 && sz == 10", 
            "format": "CRC32W <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1 && sz == 11", 
            "format": "CRC32X <Wd>, <Wn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 sz#2 0100 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "CRC32 checksum", 
    "name": "CRC32B, CRC32H, CRC32W, CRC32X", 
    "operation": "if !HaveCRCExt() then\n    UnallocatedEncoding();\nendif\nbits(32)      acc     = X[n];   \nbits(size)    val     = X[m];   \nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sf == '1' && sz != '11' then UnallocatedEncoding();\nif sf == '0' && sz == '11' then UnallocatedEncoding();\ninteger size = 8 << UInt(sz);   \nboolean crc32c = (C == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0 && sz == 00", 
            "format": "CRC32CB <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 0 && sz == 01", 
            "format": "CRC32CH <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 0 && sz == 10", 
            "format": "CRC32CW <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1 && sz == 11", 
            "format": "CRC32CX <Wd>, <Wn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 sz#2 0101 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "CRC32C checksum", 
    "name": "CRC32CB, CRC32CH, CRC32CW, CRC32CX", 
    "operation": "if !HaveCRCExt() then\n    UnallocatedEncoding();\nendif\nbits(32)      acc     = X[n];   \nbits(size)    val     = X[m];   \nbits(32)      poly    = (if crc32c then 0x1EDC6F41 else 0x04C11DB7)<31:0>;\nbits(32+size) tempacc = BitReverse(acc) : Zeros(size);\nbits(size+32) tempval = BitReverse(val) : Zeros(32);\nX[d] = BitReverse(Poly32Mod2(tempacc EOR tempval, poly));\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CSEL <Wd>, <Wn>, <Wm>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CSEL <Xd>, <Xn>, <Xm>, <cond>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010100 cond#4 Rn#5 00 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Select", 
    "name": "CSEL", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CSINC <Wd>, <Wn>, <Wm>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CSINC <Xd>, <Xn>, <Xm>, <cond>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010100 cond#4 Rn#5 01 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Select Increment", 
    "name": "CSINC", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CSINV <Wd>, <Wn>, <Wm>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CSINV <Xd>, <Xn>, <Xm>, <cond>"
          }
        ], 
        "pattern": "sf#1 Rm#5 1011010100 cond#4 Rn#5 00 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Select Invert", 
    "name": "CSINV", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(4) condition = cond;\nboolean else_inv = (op == '1');\nboolean else_inc = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "CSNEG <Wd>, <Wn>, <Wm>, <cond>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "CSNEG <Xd>, <Xn>, <Xm>, <cond>"
          }
        ], 
        "pattern": "sf#1 Rm#5 1011010100 cond#4 Rn#5 01 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Conditional Select Negation", 
    "name": "CSNEG", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nif ConditionHolds(condition) then\n    result = operand1;\nelse\n    result = operand2;\n    if else_inv then result = NOT(result);\n    if else_inc then result = result + 1;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DCPS1 {#<imm>}"
          }
        ], 
        "pattern": "imm16#16 11010100101 00001", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Debug Change PE State to EL1.", 
    "name": "DCPS1", 
    "operation": "DCPSInstruction(target_level);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DCPS2 {#<imm>}"
          }
        ], 
        "pattern": "imm16#16 11010100101 00010", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Debug Change PE State to EL2.", 
    "name": "DCPS2", 
    "operation": "DCPSInstruction(target_level);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(2) target_level = LL;\nif LL == '00' then UnallocatedEncoding();\nif !Halted() then AArch64.UndefinedFault();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DCPS3 {#<imm>}"
          }
        ], 
        "pattern": "imm16#16 11010100101 00011", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Debug Change PE State to EL3", 
    "name": "DCPS3", 
    "operation": "DCPSInstruction(target_level);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\nendcase\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\nendcase\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DMB <option>|#<imm>"
          }
        ], 
        "pattern": "CRm#4 11010101000000110011 10111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Data Memory Barrier", 
    "name": "DMB", 
    "operation": "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !Halted() || PSTATE.EL == EL0 then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DRPS"
          }
        ], 
        "pattern": "11010110101111110000001111100000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Debug restore process state", 
    "name": "DRPS", 
    "operation": "DRPSInstruction();\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\nendcase\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\nendcase\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DSB <option>|#<imm>"
          }
        ], 
        "pattern": "CRm#4 11010101000000110011 10011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Data Synchronization Barrier", 
    "name": "DSB", 
    "operation": "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\ninteger index = UInt(imm5<4:size+1>);\ninteger idxdsize = if imm5<4> == '1' then 128 else 64; \ninteger esize = 8 << size;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DUP <V><d>, <Vn>.<T>[<index>]"
          }
        ], 
        "pattern": "imm5#5 01011110000 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\ninteger index = UInt(imm5<4:size+1>);\ninteger idxdsize = if imm5<4> == '1' then 128 else 64; \nif size == 3 && Q == '0' then ReservedValue();\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DUP <Vd>.<T>, <Vn>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 imm5#5 001110000 Rn#5 000001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Duplicate vector element to vector or scalar", 
    "name": "DUP (element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nelement = Elem[operand, index, esize];\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\nif size == 3 && Q == '0' then ReservedValue();\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "DUP <Vd>.<T>, <R><n>"
          }
        ], 
        "pattern": "Q#1 0 imm5#5 001110000 Rn#5 000011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Duplicate general-purpose register to vector", 
    "name": "DUP (general)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = element;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "EON <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "EON <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1001010 Rm#5 1 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Exclusive OR NOT (shifted register)", 
    "name": "EON (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "EOR3 <Vd>.16B, <Vn>.16B, <Vm>.16B, <Va>.16B"
          }
        ], 
        "pattern": "Rm#5 11001110000 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Three-way Exclusive OR", 
    "name": "EOR3", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Va = V[a];\nV[d] = Vn EOR Vm EOR Va;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nVBitOp op;\ncase opc2 of\n    when '00' op = VBitOp_VEOR;\n    when '01' op = VBitOp_VBSL;\n    when '10' op = VBitOp_VBIT;\n    when '11' op = VBitOp_VBIF;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "EOR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110001 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Exclusive OR (vector)", 
    "name": "EOR (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1;\nbits(datasize) operand2;\nbits(datasize) operand3;\nbits(datasize) operand4 = V[n];\ncase op of\n    when VBitOp_VEOR\n        operand1 = V[m];\n        operand2 = Zeros();\n        operand3 = Ones();\n    when VBitOp_VBSL\n        operand1 = V[m];\n        operand2 = operand1;\n        operand3 = V[d];\n    when VBitOp_VBIT\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = V[m];\n    when VBitOp_VBIF\n        operand1 = V[d];\n        operand2 = operand1;\n        operand3 = NOT(V[m]);\nendcase\nV[d] = operand1 EOR ((operand2 EOR operand4) AND operand3);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "EOR <Wd|WSP>, <Wn>, #<imm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "EOR <Xd|SP>, <Xn>, #<imm>"
          }
        ], 
        "pattern": "sf#1 N#1 10100100 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Exclusive OR (immediate)", 
    "name": "EOR (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "EOR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "EOR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1001010 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise Exclusive OR (shifted register)", 
    "name": "EOR (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if PSTATE.EL == EL0 then UnallocatedEncoding();\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nif !pac && op4 != '00000' then\n    UnallocatedEncoding();\nelsif pac && (!HavePACExt() || op4 != '11111') then\n    UnallocatedEncoding();\nendif\nif Rn != '11111' then \n    UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ERET"
          }
        ], 
        "pattern": "11010110100111110000001111100000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Exception Return", 
    "name": "ERET", 
    "operation": "AArch64.CheckForERetTrap(pac, use_key_a);\nbits(64) target = ELR[];\nif pac then\n    if use_key_a then\n        target = AuthIA(ELR[], SP[]);\n    else\n        target = AuthIB(ELR[], SP[]);\n    endif\nendif\nAArch64.ExceptionReturn(target, SPSR[]);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if PSTATE.EL == EL0 then UnallocatedEncoding();\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nif !pac && op4 != '00000' then\n    UnallocatedEncoding();\nelsif pac && (!HavePACExt() || op4 != '11111') then\n    UnallocatedEncoding();\nendif\nif Rn != '11111' then \n    UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "M == 0", 
            "format": "ERETAA"
          }, 
          {
            "condition": "M == 1", 
            "format": "ERETAB"
          }
        ], 
        "pattern": "M#1 110101101001111100001 1111111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Exception Return, with pointer authentication", 
    "name": "ERETAA, ERETAB", 
    "operation": "AArch64.CheckForERetTrap(pac, use_key_a);\nbits(64) target = ELR[];\nif pac then\n    if use_key_a then\n        target = AuthIA(ELR[], SP[]);\n    else\n        target = AuthIB(ELR[], SP[]);\n    endif\nendif\nAArch64.ExceptionReturn(target, SPSR[]);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ESB"
          }
        ], 
        "pattern": "11010101000000110010001000011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Error Synchronization Barrier", 
    "name": "ESB", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif Q == '0' && imm4<3> == '1' then UnallocatedEncoding();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger position = UInt(imm4) << 3;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "EXT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<index>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110000 imm4#4 0 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Extract vector from pair of vectors", 
    "name": "EXT", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) hi = V[m];\nbits(datasize) lo = V[n];\nbits(datasize*2) concat = hi : lo;\nV[d] = concat<position+datasize-1:position>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger lsb;\nif N != sf then UnallocatedEncoding();\nif sf == '0' && imms<5> == '1' then ReservedValue();\nlsb = UInt(imms);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0 && imms == 0xxxxx", 
            "format": "EXTR <Wd>, <Wn>, <Wm>, #<lsb>"
          }, 
          {
            "condition": "sf == 1 && N == 1", 
            "format": "EXTR <Xd>, <Xn>, <Xm>, #<lsb>"
          }
        ], 
        "pattern": "sf#1 N#1 00100111 Rm#5 0 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Extract register", 
    "name": "EXTR", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(2*datasize) concat = operand1:operand2;\nresult = concat<lsb+datasize-1:lsb>;\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean abs = TRUE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FABD <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01111110110 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean abs = TRUE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FABD <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 011111101 Rm#5 1 Rn#5 110101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110110 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rm#5 1 Rn#5 110101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Absolute Difference (vector)", 
    "name": "FABD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FABS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111000111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FABS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100000111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Absolute value (vector)", 
    "name": "FABS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    endif\n    Elem[result, e, esize] = element;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FABS <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FABS <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FABS <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100000110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Absolute value (scalar)", 
    "name": "FABS (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGE <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01111110010 Rn#5 001011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGE <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 011111100 Rm#5 1 Rn#5 111011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 001011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 111011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Absolute Compare Greater than or Equal (vector)", 
    "name": "FACGE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    endif\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGT <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01111110110 Rn#5 001011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGT <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 011111101 Rm#5 1 Rn#5 111011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110110 Rn#5 001011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FACGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rm#5 1 Rn#5 111011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Absolute Compare Greater than (vector)", 
    "name": "FACGT", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    endif\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 110101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Add (vector)", 
    "name": "FADD (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean sub_op = (op == '1');\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FADD <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FADD <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FADD <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Add (scalar)", 
    "name": "FADD (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = ReduceOp_FADD;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FADDP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Rn#5 0101111000110000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = ReduceOp_FADD;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FADDP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 110000110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Add Pair of elements (scalar)", 
    "name": "FADDP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FADDP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 110101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Add Pairwise (vector)", 
    "name": "FADDP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    Elem[result, e, esize] = FPAdd(element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFCADDExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' then ReservedValue();\nif Q == '0' && size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then ReservedValue();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 0 rot#1 111 Rn#5 01 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Complex Add", 
    "name": "FCADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element3;\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '0'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element3 = Elem[operand2, e*2, esize];\n        when '1'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element3 = FPNeg(Elem[operand2, e*2, esize]);   \n    endcase\n    Elem[result, e*2,   esize] = FPAdd(Elem[operand1, e*2, esize], element1, FPCR);\n    Elem[result, e*2+1, esize] = FPAdd(Elem[operand1, e*2+1, esize], element3, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FCCMP <Hn>, <Hm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FCCMP <Sn>, <Sm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FCCMP <Dn>, <Dm>, #<nzcv>, <cond>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 cond#4 Rn#5 01 nzcv#4 0", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Conditional quiet Compare (scalar)", 
    "name": "FCCMP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\noperand2 = V[m];\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nendif\nPSTATE.<N,Z,C,V> = flags;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean signal_all_nans = (op == '1');\nbits(4) condition = cond;\nbits(4) flags = nzcv;\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FCCMPE <Hn>, <Hm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FCCMPE <Sn>, <Sm>, #<nzcv>, <cond>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FCCMPE <Dn>, <Dm>, #<nzcv>, <cond>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 cond#4 Rn#5 01 nzcv#4 1", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Conditional signaling Compare (scalar)", 
    "name": "FCCMPE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\noperand2 = V[m];\nif ConditionHolds(condition) then\n    flags = FPCompare(operand1, operand2, signal_all_nans, FPCR);\nendif\nPSTATE.<N,Z,C,V> = flags;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01011110010 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 010111100 Rm#5 1 Rn#5 111001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 111001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Equal (vector)", 
    "name": "FCMEQ (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    endif\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <Hd>, <Hn>, #0.0"
          }
        ], 
        "pattern": "Rn#5 0101111011111000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <V><d>, <V><n>, #0.0"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMEQ <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100000110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Equal to zero (vector)", 
    "name": "FCMEQ (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01111110010 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 011111100 Rm#5 1 Rn#5 111001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 111001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Greater than or Equal (vector)", 
    "name": "FCMGE (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    endif\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <Hd>, <Hn>, #0.0"
          }
        ], 
        "pattern": "Rn#5 0111111011111000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <V><d>, <V><n>, #0.0"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 100000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGE <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100000110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Greater than or Equal to zero (vector)", 
    "name": "FCMGE (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01111110110 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 011111101 Rm#5 1 Rn#5 111001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110110 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp cmp;\nboolean abs;\ncase E:U:ac of\n    when '000' cmp = CompareOp_EQ; abs = FALSE;\n    when '010' cmp = CompareOp_GE; abs = FALSE;\n    when '011' cmp = CompareOp_GE; abs = TRUE;\n    when '110' cmp = CompareOp_GT; abs = FALSE;\n    when '111' cmp = CompareOp_GT; abs = TRUE;\n    otherwise  UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rm#5 1 Rn#5 111001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Greater than (vector)", 
    "name": "FCMGT (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nboolean test_passed;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if abs then\n        element1 = FPAbs(element1);\n        element2 = FPAbs(element2);\n    endif\n    case cmp of\n        when CompareOp_EQ test_passed = FPCompareEQ(element1, element2, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element1, element2, FPCR);\n        when CompareOp_GT test_passed = FPCompareGT(element1, element2, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <Hd>, <Hn>, #0.0"
          }
        ], 
        "pattern": "Rn#5 0101111011111000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <V><d>, <V><n>, #0.0"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMGT <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100000110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Greater than zero (vector)", 
    "name": "FCMGT (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFCADDExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\nif size == '00' || size == '11' then ReservedValue();\nif size == '01' then index = UInt(H:L);\nif size == '10' then index = UInt(H);\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then ReservedValue();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nif size == '10' && (L == '1' || Q == '0') then ReservedValue(); \nif size == '01' && H == '1' && Q=='0' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "size == 01", 
            "format": "FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
          }, 
          {
            "condition": "size == 10", 
            "format": "FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>], #<rotate>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 rot#2 0 H#1 1 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Complex Multiply Accumulate (by element)", 
    "name": "FCMLA (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[m];\nbits(datasize) operand2 = V[n];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '00'\n            element1 = Elem[operand1, index*2, esize]; \n            element2 = Elem[operand2, e*2, esize];\n            element3 = Elem[operand1, index*2+1, esize];\n            element4 = Elem[operand2, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand1, index*2+1, esize]); \n            element2 = Elem[operand2, e*2+1, esize];\n            element3 = Elem[operand1, index*2, esize];\n            element4 = Elem[operand2, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand1, index*2,esize]); \n            element2 = Elem[operand2, e*2, esize];\n            element3 = FPNeg(Elem[operand1, index*2+1, esize]);\n            element4 = Elem[operand2, e*2, esize];\n        when '11'\n            element1 = Elem[operand1, index*2+1, esize]; \n            element2 = Elem[operand2, e*2+1, esize];\n            element3 = FPNeg(Elem[operand1, index*2, esize]);\n            element4 = Elem[operand2, e*2+1, esize];\n    endcase\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2, esize], element2, element1, FPCR);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFCADDExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' then ReservedValue();\nif Q == '0' && size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\nif !HaveFP16Ext() && esize == 16 then ReservedValue();\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>, #<rotate>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 0 rot#2 110 Rn#5 1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Complex Multiply Accumulate", 
    "name": "FCMLA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) element3;\nbits(esize) element4;\nfor e = 0 to (elements DIV 2) -1 \n    case rot of \n        when '00'\n            element1 = Elem[operand2, e*2, esize]; \n            element2 = Elem[operand1, e*2, esize];\n            element3 = Elem[operand2, e*2+1, esize];\n            element4 = Elem[operand1, e*2, esize];\n        when '01'\n            element1 = FPNeg(Elem[operand2, e*2+1, esize]); \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = Elem[operand2, e*2, esize];\n            element4 = Elem[operand1, e*2+1, esize];\n        when '10'\n            element1 = FPNeg(Elem[operand2, e*2, esize]); \n            element2 = Elem[operand1, e*2, esize];\n            element3 = FPNeg(Elem[operand2, e*2+1, esize]);\n            element4 = Elem[operand1, e*2, esize];\n        when '11'\n            element1 = Elem[operand2, e*2+1, esize]; \n            element2 = Elem[operand1, e*2+1, esize];\n            element3 = FPNeg(Elem[operand2, e*2, esize]);\n            element4 = Elem[operand1, e*2+1, esize];\n    endcase\n    Elem[result, e*2,   esize] = FPMulAdd(Elem[operand3, e*2,   esize], element2, element1, FPCR);\n    Elem[result, e*2+1, esize] = FPMulAdd(Elem[operand3, e*2+1, esize], element4, element3, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLE <Hd>, <Hn>, #0.0"
          }
        ], 
        "pattern": "Rn#5 0111111011111000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLE <V><d>, <V><n>, #0.0"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 100000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLE <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111000110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison;\ncase op:U of\n    when '00' comparison = CompareOp_GT;\n    when '01' comparison = CompareOp_GE;\n    when '10' comparison = CompareOp_EQ;\n    when '11' comparison = CompareOp_LE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLE <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100000110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Less than or Equal to zero (vector)", 
    "name": "FCMLE (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison = CompareOp_LT;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLT <Hd>, <Hn>, #0.0"
          }
        ], 
        "pattern": "Rn#5 0101111011111000111010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nCompareOp comparison = CompareOp_LT;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLT <V><d>, <V><n>, #0.0"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100000111010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison = CompareOp_LT;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLT <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111000111010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nCompareOp comparison = CompareOp_LT;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCMLT <Vd>.<T>, <Vn>.<T>, #0.0"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100000111010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Compare Less than zero (vector)", 
    "name": "FCMLT (zero)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) zero = FPZero('0');\nbits(esize) element;\nboolean test_passed;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    case comparison of\n        when CompareOp_GT test_passed = FPCompareGT(element, zero, FPCR);\n        when CompareOp_GE test_passed = FPCompareGE(element, zero, FPCR);\n        when CompareOp_EQ test_passed = FPCompareEQ(element, zero, FPCR);\n        when CompareOp_LE test_passed = FPCompareGE(zero, element, FPCR);\n        when CompareOp_LT test_passed = FPCompareGT(zero, element, FPCR);\n    endcase\n    Elem[result, e, esize] = if test_passed then Ones() else Zeros();\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "0x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger m = UInt(Rm);   \ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');\n", 
        "encodings": [
          {
            "condition": "type == 11 && opc == 00", 
            "format": "FCMP <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 11 && Rm == (00000) && opc == 01", 
            "format": "FCMP <Hn>, #0.0"
          }, 
          {
            "condition": "type == 00 && opc == 00", 
            "format": "FCMP <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 00 && Rm == (00000) && opc == 01", 
            "format": "FCMP <Sn>, #0.0"
          }, 
          {
            "condition": "type == 01 && opc == 00", 
            "format": "FCMP <Dn>, <Dm>"
          }, 
          {
            "condition": "type == 01 && Rm == (00000) && opc == 01", 
            "format": "FCMP <Dn>, #0.0"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 001000 opc#2 000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point quiet Compare (scalar)", 
    "name": "FCMP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger m = UInt(Rm);   \ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean signal_all_nans = (opc<1> == '1');\nboolean cmp_with_zero = (opc<0> == '1');\n", 
        "encodings": [
          {
            "condition": "type == 11 && opc == 10", 
            "format": "FCMPE <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 11 && Rm == (00000) && opc == 11", 
            "format": "FCMPE <Hn>, #0.0"
          }, 
          {
            "condition": "type == 00 && opc == 10", 
            "format": "FCMPE <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 00 && Rm == (00000) && opc == 11", 
            "format": "FCMPE <Sn>, #0.0"
          }, 
          {
            "condition": "type == 01 && opc == 10", 
            "format": "FCMPE <Dn>, <Dm>"
          }, 
          {
            "condition": "type == 01 && Rm == (00000) && opc == 11", 
            "format": "FCMPE <Dn>, #0.0"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 001000 opc#2 000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point signaling Compare (scalar)", 
    "name": "FCMPE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2;\noperand2 = if cmp_with_zero then FPZero('0') else V[m];\nPSTATE.<N,Z,C,V> = FPCompare(operand1, operand2, signal_all_nans, FPCR);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nbits(4) condition = cond;\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FCSEL <Hd>, <Hn>, <Hm>, <cond>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FCSEL <Sd>, <Sn>, <Sm>, <cond>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FCSEL <Dd>, <Dn>, <Dm>, <cond>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 cond#4 Rn#5 11 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Conditional Select (scalar)", 
    "name": "FCSEL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nresult = if ConditionHolds(condition) then V[n] else V[m];\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif type == opc then UnallocatedEncoding();\ninteger srcsize;\ncase type of\n    when '00' srcsize = 32;\n    when '01' srcsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11' srcsize = 16;\nendcase\ninteger dstsize;\ncase opc of\n    when '00' dstsize = 32;\n    when '01' dstsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11' dstsize = 16;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11 && opc == 00", 
            "format": "FCVT <Sd>, <Hn>"
          }, 
          {
            "condition": "type == 11 && opc == 01", 
            "format": "FCVT <Dd>, <Hn>"
          }, 
          {
            "condition": "type == 00 && opc == 11", 
            "format": "FCVT <Hd>, <Sn>"
          }, 
          {
            "condition": "type == 00 && opc == 01", 
            "format": "FCVT <Dd>, <Sn>"
          }, 
          {
            "condition": "type == 01 && opc == 11", 
            "format": "FCVT <Hd>, <Dn>"
          }, 
          {
            "condition": "type == 01 && opc == 00", 
            "format": "FCVT <Sd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 opc#2 10001 Rn#5 10000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert precision (scalar)", 
    "name": "FCVT", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(dstsize) result;\nbits(srcsize) operand = V[n];\nresult = FPConvert(operand, FPCR);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAS <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111001111001110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAS <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111100 Rn#5 100001110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111001111001110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (vector)", 
    "name": "FCVTAS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTAS <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTAS <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTAS <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTAS <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTAS <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTAS <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 100100000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to Away (scalar)", 
    "name": "FCVTAS (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAU <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111001111001110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAU <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 100001110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001111001110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPRounding_TIEAWAY;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTAU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (vector)", 
    "name": "FCVTAU (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTAU <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTAU <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTAU <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTAU <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTAU <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTAU <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 100101000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to Away (scalar)", 
    "name": "FCVTAU (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTL{2} <Vd>.<Ta>, <Vn>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001011110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to higher precision Long (vector)", 
    "name": "FCVTL, FCVTL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\nfor e = 0 to elements-1\n    Elem[result, e, 2*esize] = FPConvert(Elem[operand, e, esize], FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMS <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111001111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMS <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111100 Rn#5 100001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111001111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding toward Minus infinity (vector)", 
    "name": "FCVTMS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTMS <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTMS <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTMS <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTMS <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTMS <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTMS <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 110000000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding toward Minus infinity (scalar)", 
    "name": "FCVTMS (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMU <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111001111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMU <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 100001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTMU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (vector)", 
    "name": "FCVTMU (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTMU <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTMU <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTMU <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTMU <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTMU <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTMU <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 110001000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding toward Minus infinity (scalar)", 
    "name": "FCVTMU (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16 << UInt(sz);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTN{2} <Vd>.<Tb>, <Vn>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to lower precision Narrow (vector)", 
    "name": "FCVTN, FCVTN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR);\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNS <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111001111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNS <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111100 Rn#5 100001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111001111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (vector)", 
    "name": "FCVTNS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTNS <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTNS <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTNS <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTNS <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTNS <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTNS <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 100000000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding to nearest with ties to even (scalar)", 
    "name": "FCVTNS (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNU <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111001111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNU <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 100001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTNU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (vector)", 
    "name": "FCVTNU (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTNU <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTNU <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTNU <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTNU <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTNU <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTNU <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 100001000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding to nearest with ties to even (scalar)", 
    "name": "FCVTNU (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPS <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111011111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPS <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100001101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding toward Plus infinity (vector)", 
    "name": "FCVTPS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTPS <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTPS <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTPS <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTPS <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTPS <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTPS <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 101000000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding toward Plus infinity (scalar)", 
    "name": "FCVTPS (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPU <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111011111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPU <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 100001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111001101010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTPU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100001101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (vector)", 
    "name": "FCVTPU (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTPU <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTPU <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTPU <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTPU <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTPU <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTPU <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 101001000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding toward Plus infinity (scalar)", 
    "name": "FCVTPU (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz == '0' then ReservedValue();\ninteger esize = 32;\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTXN <Vb><d>, <Va><n>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 100001011010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz == '0' then ReservedValue();\ninteger esize = 32;\ninteger datasize = 64;\ninteger elements = 2;\ninteger part = UInt(Q);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTXN{2} <Vd>.<Tb>, <Vn>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to lower precision Narrow, rounding to odd (vector)", 
    "name": "FCVTXN, FCVTXN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = FPConvert(Elem[operand, e, 2*esize], FPCR, FPRounding_ODD);\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZS <V><d>, <V><n>, #<fbits>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 111111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZS <Vd>.<T>, <Vn>.<T>, #<fbits>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 111111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed fixed-point, rounding toward Zero (vector)", 
    "name": "FCVTZS (vector, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZS <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111011111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZS <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100001101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding toward Zero (vector)", 
    "name": "FCVTZS (vector, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\ncase opcode<2:1>:rmode of\n    when '0011'        \n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTZS <Wd>, <Hn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTZS <Xd>, <Hn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTZS <Wd>, <Sn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTZS <Xd>, <Sn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTZS <Wd>, <Dn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTZS <Xd>, <Dn>, #<fbits>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 scale#6 011000 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed fixed-point, rounding toward Zero (scalar)", 
    "name": "FCVTZS (scalar, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTZS <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTZS <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTZS <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTZS <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTZS <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTZS <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 111000000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Signed integer, rounding toward Zero (scalar)", 
    "name": "FCVTZS (scalar, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZU <V><d>, <V><n>, #<fbits>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 111111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRounding_ZERO;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZU <Vd>.<T>, <Vn>.<T>, #<fbits>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 111111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (vector)", 
    "name": "FCVTZU (vector, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, fracbits, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZU <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111011111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZU <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 100001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111001101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nFPRounding rounding = FPDecodeRounding(o1:o2);\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FCVTZU <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100001101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding toward Zero (vector)", 
    "name": "FCVTZU (vector, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPToFixed(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\ncase opcode<2:1>:rmode of\n    when '0011'        \n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTZU <Wd>, <Hn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTZU <Xd>, <Hn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTZU <Wd>, <Sn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTZU <Xd>, <Sn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTZU <Wd>, <Dn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTZU <Xd>, <Dn>, #<fbits>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 scale#6 011001 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned fixed-point, rounding toward Zero (scalar)", 
    "name": "FCVTZU (scalar, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "FCVTZU <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "FCVTZU <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "FCVTZU <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "FCVTZU <Xd>, <Sn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "FCVTZU <Wd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "FCVTZU <Xd>, <Dn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 111001000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Convert to Unsigned integer, rounding toward Zero (scalar)", 
    "name": "FCVTZU (scalar, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FDIV <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FDIV <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 111111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Divide (vector)", 
    "name": "FDIV (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPDiv(element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FDIV <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FDIV <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FDIV <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 000110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Divide (scalar)", 
    "name": "FDIV (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nresult = FPDiv(operand1, operand2, FPCR);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FJCVTZS <Wd>, <Dn>"
          }
        ], 
        "pattern": "Rn#5 0001111001111110000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero", 
    "name": "FJCVTZS", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMADD <Hd>, <Hn>, <Hm>, <Ha>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMADD <Sd>, <Sn>, <Sm>, <Sa>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMADD <Dd>, <Dn>, <Dm>, <Da>"
          }
        ], 
        "pattern": "type#2 00011111 Rm#5 0 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point fused Multiply-Add (scalar)", 
    "name": "FMADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 111101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum (vector)", 
    "name": "FMAX (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMAX <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMAX <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMAX <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 010010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum (scalar)", 
    "name": "FMAX (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (a == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 110001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum Number (vector)", 
    "name": "FMAXNM (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMAXNM <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMAXNM <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMAXNM <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum Number (scalar)", 
    "name": "FMAXNM (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNMP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Rn#5 0101111000110000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNMP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 110000110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum Number of Pair of elements (scalar)", 
    "name": "FMAXNMP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (a == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 110001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum Number Pairwise (vector)", 
    "name": "FMAXNMP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNMV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111000110000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q != '01' then ReservedValue();   \ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXNMV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 110000110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum Number across Vector", 
    "name": "FMAXNMV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Rn#5 0101111000110000111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 110000111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum of Pair of elements (scalar)", 
    "name": "FMAXP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 111101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum Pairwise (vector)", 
    "name": "FMAXP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111000110000111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q != '01' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMAXV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 110000111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Maximum across Vector", 
    "name": "FMAXV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110110 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rm#5 1 Rn#5 111101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point minimum (vector)", 
    "name": "FMIN (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMIN <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMIN <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMIN <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 010110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum (scalar)", 
    "name": "FMIN (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (a == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110110 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNM <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rm#5 1 Rn#5 110001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum Number (vector)", 
    "name": "FMINNM (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPMaxMinOp operation;\ncase op of\n    when '00' operation = FPMaxMinOp_MAX;\n    when '01' operation = FPMaxMinOp_MIN;\n    when '10' operation = FPMaxMinOp_MAXNUM;\n    when '11' operation = FPMaxMinOp_MINNUM;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMINNM <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMINNM <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMINNM <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 011110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum Number (scalar)", 
    "name": "FMINNM (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\ncase operation of\n    when FPMaxMinOp_MAX    result = FPMax(operand1, operand2, FPCR);\n    when FPMaxMinOp_MIN    result = FPMin(operand1, operand2, FPCR);\n    when FPMaxMinOp_MAXNUM result = FPMaxNum(operand1, operand2, FPCR);\n    when FPMaxMinOp_MINNUM result = FPMinNum(operand1, operand2, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNMP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Rn#5 0101111010110000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNMP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 110000110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum Number of Pair of elements (scalar)", 
    "name": "FMINNMP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (a == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110110 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNMP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rm#5 1 Rn#5 110001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum Number Pairwise (vector)", 
    "name": "FMINNMP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMinNum(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMaxNum(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNMV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111010110000110010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q != '01' then ReservedValue();   \ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMINNUM else ReduceOp_FMAXNUM;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINNMV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 110000110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum Number across Vector", 
    "name": "FMINNMV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\nif sz == '1' then ReservedValue();\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Rn#5 0101111010110000111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize * 2;\ninteger elements = 2;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINP <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 110000111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum of Pair of elements (scalar)", 
    "name": "FMINP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110110 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean pair = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rm#5 1 Rn#5 111101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum Pairwise (vector)", 
    "name": "FMINP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    if pair then\n        element1 = Elem[concat, 2*e, esize];\n        element2 = Elem[concat, (2*e)+1, esize];\n    else\n        element1 = Elem[operand1, e, esize];\n        element2 = Elem[operand2, e, esize];\n    endif\n    if minimum then\n        Elem[result, e, esize] = FPMin(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMax(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111010110000111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q != '01' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nReduceOp op = if o1 == '1' then ReduceOp_FMIN else ReduceOp_FMAX;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMINV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 110000111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Minimum across Vector", 
    "name": "FMINV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nV[d] = Reduce(op, operand, esize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLA <Hd>, <Hn>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "L#1 0101111100 M#1 Rm#4 H#1 0001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLA <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "sz#1 010111111 L#1 M#1 Rm#4 H#1 0001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "Q#1 0 L#1 00111100 M#1 Rm#4 H#1 0001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011111 L#1 M#1 Rm#4 H#1 0001 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point fused Multiply-Add to accumulator (by element)", 
    "name": "FMLA (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (a == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 000011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 110011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point fused Multiply-Add to accumulator (vector)", 
    "name": "FMLA (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLS <Hd>, <Hn>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "L#1 0101111100 M#1 Rm#4 H#1 0101 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLS <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "sz#1 010111111 L#1 M#1 Rm#4 H#1 0101 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "Q#1 0 L#1 00111100 M#1 Rm#4 H#1 0101 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011111 L#1 M#1 Rm#4 H#1 0101 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point fused Multiply-Subtract from accumulator (by element)", 
    "name": "FMLS (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (a == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110110 Rn#5 000011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rm#5 1 Rn#5 110011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point fused Multiply-Subtract from accumulator (vector)", 
    "name": "FMLS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then element1 = FPNeg(element1);\n    Elem[result, e, esize] = FPMulAdd(Elem[operand3, e, esize], element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger rd = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nimm8 = a:b:c:d:e:f:g:h;\nimm16 = imm8<7>:NOT(imm8<6>):Replicate(imm8<6>,2):imm8<5:0>:Zeros(6);\nimm = Replicate(imm16, datasize DIV 16);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMOV <Vd>.<T>, #<imm>"
          }
        ], 
        "pattern": "Q#1 0 a#1 00111100000 b#1 c#1 d#1 111111 e#1 f#1 g#1 h#1 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer rd = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\nendcase\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);\n", 
        "encodings": [
          {
            "condition": "op == 0", 
            "format": "FMOV <Vd>.<T>, #<imm>"
          }, 
          {
            "condition": "Q == 1 && op == 1", 
            "format": "FMOV <Vd>.2D, #<imm>"
          }
        ], 
        "pattern": "Q#1 0 op#1 a#1 0111100000 b#1 c#1 d#1 111101 e#1 f#1 g#1 h#1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point move immediate (vector)", 
    "name": "FMOV (vector, immediate)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nV[rd] = imm;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMOV <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMOV <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMOV <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100000010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Move register without conversion", 
    "name": "FMOV (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "rmode", 
            "==", 
            "0x"
          ], 
          [
            "opcode_", 
            "==", 
            "11x"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11 && rmode == 00 && opcode_ == 110", 
            "format": "FMOV <Wd>, <Hn>"
          }, 
          {
            "condition": "sf == 1 && type == 11 && rmode == 00 && opcode_ == 110", 
            "format": "FMOV <Xd>, <Hn>"
          }, 
          {
            "condition": "sf == 0 && type == 11 && rmode == 00 && opcode_ == 111", 
            "format": "FMOV <Hd>, <Wn>"
          }, 
          {
            "condition": "sf == 0 && type == 00 && rmode == 00 && opcode_ == 111", 
            "format": "FMOV <Sd>, <Wn>"
          }, 
          {
            "condition": "sf == 0 && type == 00 && rmode == 00 && opcode_ == 110", 
            "format": "FMOV <Wd>, <Sn>"
          }, 
          {
            "condition": "sf == 1 && type == 11 && rmode == 00 && opcode_ == 111", 
            "format": "FMOV <Hd>, <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 01 && rmode == 00 && opcode_ == 111", 
            "format": "FMOV <Dd>, <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 10 && rmode == 01 && opcode_ == 111", 
            "format": "FMOV <Vd>.D[1], <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 01 && rmode == 00 && opcode_ == 110", 
            "format": "FMOV <Xd>, <Dn>"
          }, 
          {
            "condition": "sf == 1 && type == 10 && rmode == 01 && opcode_ == 110", 
            "format": "FMOV <Xd>, <Vn>.D[1]"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 rmode#2 1 opcode_#3 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Move to or from general-purpose register without conversion", 
    "name": "FMOV (general)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nbits(datasize) imm = VFPExpandImm(imm8);\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMOV <Hd>, #<imm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMOV <Sd>, #<imm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMOV <Dd>, #<imm>"
          }
        ], 
        "pattern": "type#2 00011110 imm8#8 1 Rd#5 10000000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point move immediate (scalar)", 
    "name": "FMOV (scalar, immediate)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nV[d] = imm;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMSUB <Hd>, <Hn>, <Hm>, <Ha>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMSUB <Sd>, <Sn>, <Sm>, <Sa>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMSUB <Dd>, <Dn>, <Dm>, <Da>"
          }
        ], 
        "pattern": "type#2 00011111 Rm#5 0 Ra#5 1 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Fused Multiply-Subtract (scalar)", 
    "name": "FMSUB", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMUL <Hd>, <Hn>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "L#1 0101111100 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMUL <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "sz#1 010111111 L#1 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "Q#1 0 L#1 00111100 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011111 L#1 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Multiply (by element)", 
    "name": "FMUL (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 101110010 Rn#5 000111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rm#5 1 Rn#5 110111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Multiply (vector)", 
    "name": "FMUL (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMul(element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean negated = (op == '1');\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FMUL <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FMUL <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FMUL <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 000010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Multiply (scalar)", 
    "name": "FMUL (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nresult = FPMul(operand1, operand2, FPCR);\nif negated then result = FPNeg(result);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <Hd>, <Hn>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "L#1 0111111100 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "sz#1 011111111 L#1 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64;\ninteger index;\nindex = UInt(H:L:M);\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.H[<index>]"
          }
        ], 
        "pattern": "Q#1 0 L#1 10111100 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi = M;\ncase sz:L of\n    when '0x' index = UInt(H:L);\n    when '10' index = UInt(H);\n    when '11' UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean mulx_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011111 L#1 M#1 Rm#4 H#1 1001 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Multiply extended (by element)", 
    "name": "FMULX (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2 = Elem[operand2, index, esize];\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    if mulx_op then\n        Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\n    else\n        Elem[result, e, esize] = FPMul(element1, element2, FPCR);\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01011110010 Rn#5 000111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 010111100 Rm#5 1 Rn#5 110111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 000111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FMULX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 110111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Multiply extended", 
    "name": "FMULX", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPMulX(element1, element2, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FNEG <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111000111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FNEG <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100000111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Negate (vector)", 
    "name": "FNEG (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    if neg then\n        element = FPNeg(element);\n    else\n        element = FPAbs(element);\n    endif\n    Elem[result, e, esize] = element;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FNEG <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FNEG <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FNEG <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100001010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Negate (scalar)", 
    "name": "FNEG (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FNMADD <Hd>, <Hn>, <Hm>, <Ha>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FNMADD <Sd>, <Sn>, <Sm>, <Sa>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FNMADD <Dd>, <Dn>, <Dm>, <Da>"
          }
        ], 
        "pattern": "type#2 00011111 Rm#5 1 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Negated fused Multiply-Add (scalar)", 
    "name": "FNMADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger a = UInt(Ra);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean opa_neg = (o1 == '1');\nboolean op1_neg = (o0 != o1);\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FNMSUB <Hd>, <Hn>, <Hm>, <Ha>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FNMSUB <Sd>, <Sn>, <Sm>, <Sa>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FNMSUB <Dd>, <Dn>, <Dm>, <Da>"
          }
        ], 
        "pattern": "type#2 00011111 Rm#5 1 Ra#5 1 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Negated fused Multiply-Subtract (scalar)", 
    "name": "FNMSUB", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operanda = V[a];\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nif opa_neg then operanda = FPNeg(operanda);\nif op1_neg then operand1 = FPNeg(operand1);\nresult = FPMulAdd(operanda, operand1, operand2, FPCR);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean negated = (op == '1');\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FNMUL <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FNMUL <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FNMUL <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Multiply-Negate (scalar)", 
    "name": "FNMUL (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nresult = FPMul(operand1, operand2, FPCR);\nif negated then result = FPNeg(result);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPE <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111011111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPE <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPE <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPE <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100001110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Reciprocal Estimate", 
    "name": "FRECPE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecipEstimate(element, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPS <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01011110010 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPS <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 010111100 Rm#5 1 Rn#5 111111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110010 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rm#5 1 Rn#5 111111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Reciprocal Step", 
    "name": "FRECPS", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRecipStepFused(element1, element2);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPX <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111011111001111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRECPX <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111101 Rn#5 100001111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Reciprocal exponent (scalar)", 
    "name": "FRECPX", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRecpX(element, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTA <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001111001100010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTA <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, to nearest with ties to Away (vector)", 
    "name": "FRINTA (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTA <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTA <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTA <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100110010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, to nearest with ties to Away (scalar)", 
    "name": "FRINTA (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTI <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111001100110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTI <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100001100110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, using current rounding mode (vector)", 
    "name": "FRINTI (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTI <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTI <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTI <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100111110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, using current rounding mode (scalar)", 
    "name": "FRINTI (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTM <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111001111001100110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTM <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001100110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, toward Minus infinity (vector)", 
    "name": "FRINTM (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTM <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTM <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTM <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100101010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, toward Minus infinity (scalar)", 
    "name": "FRINTM (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTN <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111001111001100010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTN <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, to nearest with ties to even (vector)", 
    "name": "FRINTN (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTN <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTN <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTN <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100100010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, to nearest with ties to even (scalar)", 
    "name": "FRINTN (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTP <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111001100010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTP <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100001100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, toward Plus infinity (vector)", 
    "name": "FRINTP (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTP <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTP <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTP <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100100110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, toward Plus infinity (scalar)", 
    "name": "FRINTP (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTX <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001111001100110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTX <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001100110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral exact, using current rounding mode (vector)", 
    "name": "FRINTX (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTX <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTX <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTX <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100111010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral exact, using current rounding mode (scalar)", 
    "name": "FRINTX (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTZ <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111011111001100110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean exact = FALSE;\nFPRounding rounding;\ncase U:o1:o2 of\n    when '0xx' rounding = FPDecodeRounding(o1:o2);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRINTZ <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100001100110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, toward Zero (vector)", 
    "name": "FRINTZ (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRoundInt(element, FPCR, rounding, exact);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean exact = FALSE;\nFPRounding rounding;\ncase rmode of\n    when '0xx' rounding = FPDecodeRounding(rmode<1:0>);\n    when '100' rounding = FPRounding_TIEAWAY;\n    when '101' UnallocatedEncoding();\n    when '110' rounding = FPRoundingMode(FPCR); exact = TRUE;\n    when '111' rounding = FPRoundingMode(FPCR);\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FRINTZ <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FRINTZ <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FRINTZ <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100101110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Round to Integral, toward Zero (scalar)", 
    "name": "FRINTZ (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\nresult = FPRoundInt(operand, FPCR, rounding, exact);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTE <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111011111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTE <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111101 Rn#5 100001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTE <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTE <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100001110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Reciprocal Square Root Estimate", 
    "name": "FRSQRTE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPRSqrtEstimate(element, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTS <Hd>, <Hn>, <Hm>"
          }
        ], 
        "pattern": "Rm#5 01011110110 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTS <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "sz#1 010111101 Rm#5 1 Rn#5 111111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110110 Rn#5 001111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FRSQRTS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rm#5 1 Rn#5 111111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Reciprocal Square Root Step", 
    "name": "FRSQRTS", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, esize] = FPRSqrtStepFused(element1, element2);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FSQRT <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111011111001111110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FSQRT <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100001111110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Square Root (vector)", 
    "name": "FSQRT (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FPSqrt(element, FPCR);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nFPUnaryOp fpop;\ncase opc of\n    when '00' fpop = FPUnaryOp_MOV;\n    when '01' fpop = FPUnaryOp_ABS;\n    when '10' fpop = FPUnaryOp_NEG;\n    when '11' fpop = FPUnaryOp_SQRT;\nendcase\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FSQRT <Hd>, <Hn>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FSQRT <Sd>, <Sn>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FSQRT <Dd>, <Dn>"
          }
        ], 
        "pattern": "type#2 00011110 Rn#5 100001110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Square Root (scalar)", 
    "name": "FSQRT (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand = V[n];\ncase fpop of\n    when FPUnaryOp_MOV  result = operand;\n    when FPUnaryOp_ABS  result = FPAbs(operand);\n    when FPUnaryOp_NEG  result = FPNeg(operand);\n    when FPUnaryOp_SQRT result = FPSqrt(operand, FPCR);\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110110 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean abs = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "FSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rm#5 1 Rn#5 110101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Subtract (vector)", 
    "name": "FSUB (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) diff;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    diff = FPSub(element1, element2, FPCR);\n    Elem[result, e, esize] = if abs then FPAbs(diff) else diff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize;\ncase type of\n    when '00' datasize = 32;\n    when '01' datasize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            datasize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nboolean sub_op = (op == '1');\n", 
        "encodings": [
          {
            "condition": "type == 11", 
            "format": "FSUB <Hd>, <Hn>, <Hm>"
          }, 
          {
            "condition": "type == 00", 
            "format": "FSUB <Sd>, <Sn>, <Sm>"
          }, 
          {
            "condition": "type == 01", 
            "format": "FSUB <Dd>, <Dn>, <Dm>"
          }
        ], 
        "pattern": "type#2 00011110 Rm#5 1 Rn#5 001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Floating-point Subtract (scalar)", 
    "name": "FSUB (scalar)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) result;\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nif sub_op then\n    result = FPSub(operand1, operand2, FPCR);\nelse\n    result = FPAdd(operand1, operand2, FPCR);\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "CRm == 0000 && op2 == 11x", 
            "format": "HINT #<imm>"
          }, 
          {
            "condition": "CRm != 00x0", 
            "format": "HINT #<imm>"
          }, 
          {
            "condition": "CRm == 0010 && op2 != 00x", 
            "format": "HINT #<imm>"
          }
        ], 
        "pattern": "CRm#4 11010101000000110010 op2#3 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Hint instruction", 
    "name": "HINT", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if EDSCR.HDE == '0' || !HaltingAllowed() then UndefinedFault();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "HLT #<imm>"
          }
        ], 
        "pattern": "imm16#16 11010100010 00000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Halt instruction", 
    "name": "HLT", 
    "operation": "Halt(DebugHalt_HaltInstruction);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(16) imm = imm16;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "HVC #<imm>"
          }
        ], 
        "pattern": "imm16#16 11010100000 00010", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Hypervisor Call", 
    "name": "HVC", 
    "operation": "if !HaveEL(EL2) || PSTATE.EL == EL0 || (PSTATE.EL == EL1 && IsSecure()) then\n    UnallocatedEncoding();\nendif\nhvc_enable = if HaveEL(EL3) then SCR_EL3.HCE else NOT(HCR_EL2.HCD);\nif hvc_enable == '0' then\n    AArch64.UndefinedFault();\nelse\n    AArch64.CallHypervisor(imm);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\ninteger dst_index = UInt(imm5<4:size+1>);\ninteger src_index = UInt(imm4<3:size>);\ninteger idxdsize = if imm4<3> == '1' then 128 else 64; \ninteger esize = 8 << size;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "INS <Vd>.<Ts>[<index1>], <Vn>.<Ts>[<index2>]"
          }
        ], 
        "pattern": "imm5#5 01101110000 imm4#4 0 Rn#5 1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Insert vector element from another vector element", 
    "name": "INS (element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nbits(128) result;\nresult = V[d];\nElem[result, dst_index, esize] = Elem[operand, src_index, esize];\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size = LowestSetBit(imm5);\nif size > 3 then UnallocatedEncoding();\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = 128;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "INS <Vd>.<Ts>[<index>], <R><n>"
          }
        ], 
        "pattern": "imm5#5 01001110000 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Insert vector element from general-purpose register", 
    "name": "INS (general)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(esize) element = X[n];\nbits(datasize) result;\nresult = V[d];\nElem[result, index, esize] = element;\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "MemBarrierOp op;\nMBReqDomain domain;\nMBReqTypes types;\ncase opc of\n    when '00' op = MemBarrierOp_DSB;\n    when '01' op = MemBarrierOp_DMB;\n    when '10' op = MemBarrierOp_ISB;\n    otherwise UnallocatedEncoding();\nendcase\ncase CRm<3:2> of\n    when '00' domain = MBReqDomain_OuterShareable;\n    when '01' domain = MBReqDomain_Nonshareable;\n    when '10' domain = MBReqDomain_InnerShareable;\n    when '11' domain = MBReqDomain_FullSystem;\nendcase\ncase CRm<1:0> of\n    when '01' types = MBReqTypes_Reads;\n    when '10' types = MBReqTypes_Writes;\n    when '11' types = MBReqTypes_All;\n    otherwise\n        types = MBReqTypes_All;\n        domain = MBReqDomain_FullSystem;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ISB {<option>|#<imm>}"
          }
        ], 
        "pattern": "CRm#4 11010101000000110011 11011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Instruction Synchronization Barrier", 
    "name": "ISB", 
    "operation": "case op of\n    when MemBarrierOp_DSB\n        DataSynchronizationBarrier(domain, types);\n    when MemBarrierOp_DMB\n        DataMemoryBarrier(domain, types);\n    when MemBarrierOp_ISB\n        InstructionSynchronizationBarrier();\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1x"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 0111", 
            "format": "LD1 { <Vt>.<T> }, [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 1010", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 0110", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 0010", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#4 00110001000000 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1x"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 0111", 
            "format": "LD1 { <Vt>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 0111", 
            "format": "LD1 { <Vt>.<T> }, [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 1010", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 1010", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 0110", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 0110", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 0010", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 0010", 
            "format": "LD1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100110 opcode_#4 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Load multiple single-element structures to one, two, three, or four registers", 
    "name": "LD1 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 000", 
            "format": "LD1 { <Vt>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 010 && size == x0", 
            "format": "LD1 { <Vt>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && size == 00", 
            "format": "LD1 { <Vt>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && S == 0 && size == 01", 
            "format": "LD1 { <Vt>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110101000000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 000", 
            "format": "LD1 { <Vt>.B }[<index>], [<Xn|SP>], #1"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 000", 
            "format": "LD1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 010 && size == x0", 
            "format": "LD1 { <Vt>.H }[<index>], [<Xn|SP>], #2"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 010 && size == x0", 
            "format": "LD1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && size == 00", 
            "format": "LD1 { <Vt>.S }[<index>], [<Xn|SP>], #4"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && size == 00", 
            "format": "LD1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "LD1 { <Vt>.D }[<index>], [<Xn|SP>], #8"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "LD1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101110 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load one single-element structure to one lane of one register", 
    "name": "LD1 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD1R { <Vt>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001101010000001100 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD1R { <Vt>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD1R { <Vt>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101110 size#2 1100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load one single-element structure and Replicate to all lanes (of one register)", 
    "name": "LD1R", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001100010000001000 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100110 size#2 1000 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Load multiple 2-element structures to two registers", 
    "name": "LD2 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 000", 
            "format": "LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 010 && size == x0", 
            "format": "LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && size == 00", 
            "format": "LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && S == 0 && size == 01", 
            "format": "LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110101100000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 000", 
            "format": "LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 000", 
            "format": "LD2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 010 && size == x0", 
            "format": "LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 010 && size == x0", 
            "format": "LD2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && size == 00", 
            "format": "LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && size == 00", 
            "format": "LD2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "LD2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101111 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load single 2-element structure to one lane of two registers", 
    "name": "LD2 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001101011000001100 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD2R { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101111 size#2 1100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load single 2-element structure and Replicate to all lanes of two registers", 
    "name": "LD2R", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001100010000000100 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100110 size#2 0100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Load multiple 3-element structures to three registers", 
    "name": "LD3 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 001", 
            "format": "LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 011 && size == x0", 
            "format": "LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && size == 00", 
            "format": "LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && S == 0 && size == 01", 
            "format": "LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110101000000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 001", 
            "format": "LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 001", 
            "format": "LD3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 011 && size == x0", 
            "format": "LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 011 && size == x0", 
            "format": "LD3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && size == 00", 
            "format": "LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && size == 00", 
            "format": "LD3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "LD3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101110 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load single 3-element structure to one lane of three registers)", 
    "name": "LD3 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001101010000001110 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD3R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101110 size#2 1110 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load single 3-element structure and Replicate to all lanes of three registers", 
    "name": "LD3R", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001100010000000000 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100110 size#2 0000 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Load multiple 4-element structures to four registers", 
    "name": "LD4 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 001", 
            "format": "LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 011 && size == x0", 
            "format": "LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && size == 00", 
            "format": "LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && S == 0 && size == 01", 
            "format": "LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110101100000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 001", 
            "format": "LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 001", 
            "format": "LD4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 011 && size == x0", 
            "format": "LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 011 && size == x0", 
            "format": "LD4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && size == 00", 
            "format": "LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && size == 00", 
            "format": "LD4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "LD4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101111 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load single 4-element structure to one lane of four registers", 
    "name": "LD4 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001101011000001110 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "LD4R { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101111 size#2 1110 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Load single 4-element structure and Replicate to all lanes of four registers", 
    "name": "LD4R", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDADDA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDADDAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDADD <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDADDL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDADDA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDADDAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDADD <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDADDL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 000000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic add on word or doubleword in memory", 
    "name": "LDADD, LDADDA, LDADDAL, LDADDL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDADDAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDADDALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDADDB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDADDLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 000000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic add on byte in memory", 
    "name": "LDADDB, LDADDAB, LDADDALB, LDADDLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDADDAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDADDALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDADDH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDADDLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 000000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic add on halfword in memory", 
    "name": "LDADDH, LDADDAH, LDADDALH, LDADDLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   \nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDAPR <Wt>, [<Xn|SP> {,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDAPR <Xt>, [<Xn|SP> {,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 11100010111111110000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire RCpc Register", 
    "name": "LDAPR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   \nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDAPRB <Wt>, [<Xn|SP> {,#0}]"
          }
        ], 
        "pattern": "Rn#5 0011100010111111110000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire RCpc Register Byte", 
    "name": "LDAPRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger s = UInt(Rs);   \nAccType acctype = AccType_ORDERED;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDAPRH <Wt>, [<Xn|SP> {,#0}]"
          }
        ], 
        "pattern": "Rn#5 0111100010111111110000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire RCpc Register Halfword", 
    "name": "LDAPRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata = Mem[address, dbytes, acctype];\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDAR <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDAR <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 00100011011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Register", 
    "name": "LDAR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDARB <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0000100011011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Register Byte", 
    "name": "LDARB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDARH <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0100100011011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Register Halfword", 
    "name": "LDARH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "sz == 0", 
            "format": "LDAXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1", 
            "format": "LDAXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "sz#1 1 Rt2#5 001000011111111 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Exclusive Pair of Registers", 
    "name": "LDAXP", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDAXR <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDAXR <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 00100001011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Exclusive Register", 
    "name": "LDAXR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDAXRB <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0000100001011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Exclusive Register Byte", 
    "name": "LDAXRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDAXRH <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0100100001011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load-Acquire Exclusive Register Halfword", 
    "name": "LDAXRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDCLRA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDCLRAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDCLR <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDCLRL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDCLRA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDCLRAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDCLR <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDCLRL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 000100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit clear on word or doubleword in memory", 
    "name": "LDCLR, LDCLRA, LDCLRAL, LDCLRL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDCLRAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDCLRALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDCLRB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDCLRLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 000100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit clear on byte in memory", 
    "name": "LDCLRB, LDCLRAB, LDCLRALB, LDCLRLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDCLRAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDCLRALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDCLRH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDCLRLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 000100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit clear on halfword in memory", 
    "name": "LDCLRH, LDCLRAH, LDCLRALH, LDCLRLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDEORA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDEORAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDEOR <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDEORL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDEORA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDEORAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDEOR <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDEORL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 001000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic exclusive OR on word or doubleword in memory", 
    "name": "LDEOR, LDEORA, LDEORAL, LDEORL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDEORAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDEORALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDEORB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDEORLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 001000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic exclusive OR on byte in memory", 
    "name": "LDEORB, LDEORAB, LDEORALB, LDEORLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDEORAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDEORALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDEORH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDEORLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 001000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic exclusive OR on halfword in memory", 
    "name": "LDEORH, LDEORAH, LDEORALH, LDEORLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDLAR <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDLAR <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 00100011011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load LOAcquire Register", 
    "name": "LDLAR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDLARB <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0000100011011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load LOAcquire Register Byte", 
    "name": "LDLARB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDLARH <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0100100011011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load LOAcquire Register Halfword", 
    "name": "LDLARH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 01", 
            "format": "LDNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110001 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VECSTREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Load Pair of SIMD&FP registers, with Non-temporal hint", 
    "name": "LDNP (SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        V[t]  = data1;\n        V[t2] = data2;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100001 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_STREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc<0> == '1' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Load Pair of Registers, with non-temporal hint", 
    "name": "LDNP", 
    "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        endif\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        endif\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        X[t]  = data1;\n        X[t2] = data2;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = TRUE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDP <St1>, <St2>, [<Xn|SP>], #<imm>"
          }, 
          {
            "condition": "opc == 01", 
            "format": "LDP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110011 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDP <St1>, <St2>, [<Xn|SP>, #<imm>]!"
          }, 
          {
            "condition": "opc == 01", 
            "format": "LDP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110111 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDP <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 01", 
            "format": "LDP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110101 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VEC;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Load Pair of SIMD&FP registers", 
    "name": "LDP (SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        V[t]  = data1;\n        V[t2] = data2;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = TRUE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100011 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDP <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100111 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100101 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Load Pair of Registers", 
    "name": "LDP", 
    "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        \n        when Constraint_UNKNOWN    wb_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   \n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        endif\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        endif\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n        endif\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = TRUE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDPSW <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          }
        ], 
        "pattern": "imm7#7 0110100011 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDPSW <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          }
        ], 
        "pattern": "imm7#7 0110100111 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDPSW <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "imm7#7 0110100101 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Load Pair of Registers Signed Word", 
    "name": "LDPSW", 
    "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        \n        when Constraint_UNKNOWN    wb_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   \n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        endif\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        endif\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n        endif\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x1"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 01", 
            "format": "LDR <Bt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 01 && opc == 01", 
            "format": "LDR <Ht>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 10 && opc == 01", 
            "format": "LDR <St>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 11 && opc == 01", 
            "format": "LDR <Dt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 00 && opc == 11", 
            "format": "LDR <Qt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "size#2 opc#2 111100 imm9#9 0 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x1"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 01", 
            "format": "LDR <Bt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 01 && opc == 01", 
            "format": "LDR <Ht>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 10 && opc == 01", 
            "format": "LDR <St>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 11 && opc == 01", 
            "format": "LDR <Dt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 00 && opc == 11", 
            "format": "LDR <Qt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "size#2 opc#2 111100 imm9#9 0 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x1"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 01", 
            "format": "LDR <Bt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 01 && opc == 01", 
            "format": "LDR <Ht>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 10 && opc == 01", 
            "format": "LDR <St>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 11 && opc == 01", 
            "format": "LDR <Dt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 00 && opc == 11", 
            "format": "LDR <Qt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "size#2 opc#2 111101 imm12#12 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\n", 
    "description": "Load SIMD&FP Register (immediate offset)", 
    "name": "LDR (immediate, SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDR <Wt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDR <Xt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "size#2 imm9#9 111000010 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDR <Wt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDR <Xt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "size#2 imm9#9 111000010 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDR <Wt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDR <Xt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "size#2 imm12#12 11100101 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register (immediate)", 
    "name": "LDR (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger size;\nbits(64) offset;\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 16;\n    when '11'\n        UnallocatedEncoding();\nendcase\noffset = SignExtend(imm19:'00', 64);\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDR <St>, <label>"
          }, 
          {
            "condition": "opc == 01", 
            "format": "LDR <Dt>, <label>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDR <Qt>, <label>"
          }
        ], 
        "pattern": "opc#2 imm19#19 011100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load SIMD&FP Register (PC-relative literal)", 
    "name": "LDR (literal, SIMD&FP)", 
    "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\nCheckFPAdvSIMDEnabled64();\ndata = Mem[address, size, AccType_VEC];\nV[t] = data;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "0x"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\nendcase\noffset = SignExtend(imm19:'00', 64);\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "LDR <Wt>, <label>"
          }, 
          {
            "condition": "opc == 01", 
            "format": "LDR <Xt>, <label>"
          }
        ], 
        "pattern": "opc#2 imm19#19 011000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Register (literal)", 
    "name": "LDR (literal)", 
    "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x1"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 01 && option != 011", 
            "format": "LDR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
          }, 
          {
            "condition": "size == 00 && opc == 01 && option == 011", 
            "format": "LDR <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          }, 
          {
            "condition": "size == 01 && opc == 01", 
            "format": "LDR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 10 && opc == 01", 
            "format": "LDR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 11 && opc == 01", 
            "format": "LDR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 00 && opc == 11", 
            "format": "LDR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "size#2 opc#2 111100 Rm#5 1 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\n", 
    "description": "Load SIMD&FP Register (register offset)", 
    "name": "LDR (register, SIMD&FP)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nCheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "size#2 Rm#5 111000011 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register (register)", 
    "name": "LDR (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HavePACExt() || size != '11' then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\nboolean wback = (W == '1');\nboolean use_key_a = (M == '0');\nbits(10) S10 = S:imm9;\ninteger scale = 3;\nbits(64) offset = LSL(SignExtend(S10, 64), scale);\n", 
        "encodings": [
          {
            "condition": "M == 0 && W == 0", 
            "format": "LDRAA <Xt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "M == 0 && W == 1", 
            "format": "LDRAA <Xt>, [<Xn|SP>{, #<simm>}]!"
          }, 
          {
            "condition": "M == 1 && W == 0", 
            "format": "LDRAB <Xt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "M == 1 && W == 1", 
            "format": "LDRAB <Xt>, [<Xn|SP>{, #<simm>}]!"
          }
        ], 
        "pattern": "M#1 11111000 S#1 imm9#9 1 W#1 Rn#5 1 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Register, with pointer authentication", 
    "name": "LDRAA, LDRAB", 
    "operation": "bits(64) address;\nbits(64) data;\nboolean wb_unknown = FALSE;\nif wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif use_key_a then\n    address = AuthDA(address, X[31]);\nelse\n    address = AuthDB(address, X[31]);\nendif\naddress = address + offset;\ndata = Mem[address, 8, AccType_NORMAL];\nX[t] = data;\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRB <Wt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "imm9#9 00111000010 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRB <Wt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "imm9#9 00111000010 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRB <Wt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "imm12#12 0011100101 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Byte (immediate)", 
    "name": "LDRB (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "option != 011", 
            "format": "LDRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
          }, 
          {
            "condition": "option == 011", 
            "format": "LDRB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          }
        ], 
        "pattern": "Rm#5 00111000011 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Byte (register)", 
    "name": "LDRB (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRH <Wt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "imm9#9 01111000010 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRH <Wt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "imm9#9 01111000010 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRH <Wt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "imm12#12 0111100101 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Halfword (immediate)", 
    "name": "LDRH (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "Rm#5 01111000011 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Halfword (register)", 
    "name": "LDRH (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSB <Wt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSB <Xt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "opc#2 00111000 imm9#9 0 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSB <Wt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSB <Xt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "opc#2 00111000 imm9#9 0 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSB <Wt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSB <Xt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "opc#2 00111001 imm12#12 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Byte (immediate)", 
    "name": "LDRSB (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "opc == 11 && option != 011", 
            "format": "LDRSB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
          }, 
          {
            "condition": "opc == 11 && option == 011", 
            "format": "LDRSB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          }, 
          {
            "condition": "opc == 10 && option != 011", 
            "format": "LDRSB <Xt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
          }, 
          {
            "condition": "opc == 10 && option == 011", 
            "format": "LDRSB <Xt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          }
        ], 
        "pattern": "opc#2 00111000 Rm#5 1 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Byte (register)", 
    "name": "LDRSB (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSH <Wt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSH <Xt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "opc#2 01111000 imm9#9 0 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSH <Wt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSH <Xt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "opc#2 01111000 imm9#9 0 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSH <Wt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSH <Xt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "opc#2 01111001 imm12#12 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Halfword (immediate)", 
    "name": "LDRSH (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDRSH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDRSH <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "opc#2 01111000 Rm#5 1 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Halfword (register)", 
    "name": "LDRSH (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRSW <Xt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "imm9#9 10111000100 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRSW <Xt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "imm9#9 10111000100 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRSW <Xt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "imm12#12 1011100110 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Word (immediate)", 
    "name": "LDRSW (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\nendcase\noffset = SignExtend(imm19:'00', 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRSW <Xt>, <label>"
          }
        ], 
        "pattern": "imm19#19 10011000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Register Signed Word (literal)", 
    "name": "LDRSW (literal)", 
    "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDRSW <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "Rm#5 10111000101 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Word (register)", 
    "name": "LDRSW (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDSETA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDSETAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSET <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSETL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDSETA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDSETAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSET <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSETL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 001100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit set on word or doubleword in memory", 
    "name": "LDSET, LDSETA, LDSETAL, LDSETL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDSETAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDSETALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSETB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSETLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 001100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit set on byte in memory", 
    "name": "LDSETB, LDSETAB, LDSETALB, LDSETLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDSETAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDSETALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSETH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSETLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 001100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit set on halfword in memory", 
    "name": "LDSETH, LDSETAH, LDSETALH, LDSETLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDSMAXA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDSMAXAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMAX <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMAXL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDSMAXA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDSMAXAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMAX <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMAXL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 010000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed maximum on word or doubleword in memory", 
    "name": "LDSMAX, LDSMAXA, LDSMAXAL, LDSMAXL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDSMAXAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDSMAXALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMAXB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMAXLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 010000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed maximum on byte in memory", 
    "name": "LDSMAXB, LDSMAXAB, LDSMAXALB, LDSMAXLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDSMAXAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDSMAXALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMAXH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMAXLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 010000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed maximum on halfword in memory", 
    "name": "LDSMAXH, LDSMAXAH, LDSMAXALH, LDSMAXLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDSMINA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDSMINAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMIN <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMINL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDSMINA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDSMINAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMIN <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMINL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 010100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed minimum on word or doubleword in memory", 
    "name": "LDSMIN, LDSMINA, LDSMINAL, LDSMINL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDSMINAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDSMINALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMINB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMINLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 010100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed minimum on byte in memory", 
    "name": "LDSMINB, LDSMINAB, LDSMINALB, LDSMINLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDSMINAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDSMINALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDSMINH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDSMINLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 010100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed minimum on halfword in memory", 
    "name": "LDSMINH, LDSMINAH, LDSMINALH, LDSMINLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDTR <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDTR <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "size#2 imm9#9 111000010 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register (unprivileged)", 
    "name": "LDTR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDTRB <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 00111000010 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Byte (unprivileged)", 
    "name": "LDTRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDTRH <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 01111000010 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Halfword (unprivileged)", 
    "name": "LDTRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDTRSB <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDTRSB <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "opc#2 00111000 imm9#9 0 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Byte (unprivileged)", 
    "name": "LDTRSB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDTRSH <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDTRSH <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "opc#2 01111000 imm9#9 0 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Halfword (unprivileged)", 
    "name": "LDTRSH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDTRSW <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 10111000100 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Word (unprivileged)", 
    "name": "LDTRSW", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDUMAXA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDUMAXAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMAX <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMAXL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDUMAXA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDUMAXAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMAX <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMAXL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 011000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned maximum on word or doubleword in memory", 
    "name": "LDUMAX, LDUMAXA, LDUMAXAL, LDUMAXL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDUMAXAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDUMAXALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMAXB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMAXLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 011000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned maximum on byte in memory", 
    "name": "LDUMAXB, LDUMAXAB, LDUMAXALB, LDUMAXLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDUMAXAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDUMAXALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMAXH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMAXLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 011000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned maximum on halfword in memory", 
    "name": "LDUMAXH, LDUMAXAH, LDUMAXALH, LDUMAXLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "LDUMINA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "LDUMINAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMIN <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMINL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "LDUMINA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "LDUMINAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMIN <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMINL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 011100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned minimum on word or doubleword in memory", 
    "name": "LDUMIN, LDUMINA, LDUMINAL, LDUMINL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDUMINAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDUMINALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMINB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMINLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 011100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned minimum on byte in memory", 
    "name": "LDUMINB, LDUMINAB, LDUMINALB, LDUMINLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "LDUMINAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "LDUMINALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0 && Rt != 11111", 
            "format": "LDUMINH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1 && Rt != 11111", 
            "format": "LDUMINLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 011100 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned minimum on halfword in memory", 
    "name": "LDUMINH, LDUMINAH, LDUMINALH, LDUMINLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x1"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 01", 
            "format": "LDUR <Bt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 01 && opc == 01", 
            "format": "LDUR <Ht>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 10 && opc == 01", 
            "format": "LDUR <St>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 11 && opc == 01", 
            "format": "LDUR <Dt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 00 && opc == 11", 
            "format": "LDUR <Qt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "size#2 opc#2 111100 imm9#9 0 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\n", 
    "description": "Load SIMD&FP Register (unscaled offset)", 
    "name": "LDUR (SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDUR <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDUR <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "size#2 imm9#9 111000010 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register (unscaled)", 
    "name": "LDUR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDURB <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 00111000010 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Byte (unscaled)", 
    "name": "LDURB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDURH <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 01111000010 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Halfword (unscaled)", 
    "name": "LDURH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDURSB <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDURSB <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "opc#2 00111000 imm9#9 0 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Byte (unscaled)", 
    "name": "LDURSB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "opc == 11", 
            "format": "LDURSH <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "LDURSH <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "opc#2 01111000 imm9#9 0 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Halfword (unscaled)", 
    "name": "LDURSH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDURSW <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 10111000100 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Load Register Signed Word (unscaled)", 
    "name": "LDURSW", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "sz == 0", 
            "format": "LDXP <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1", 
            "format": "LDXP <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "sz#1 1 Rt2#5 001000011111110 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Exclusive Pair of Registers", 
    "name": "LDXP", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "LDXR <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "LDXR <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 00100001011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Exclusive Register", 
    "name": "LDXR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDXRB <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0000100001011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Exclusive Register Byte", 
    "name": "LDXRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "LDXRH <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0100100001011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Load Exclusive Register Halfword", 
    "name": "LDXRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "LSLV <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "LSLV <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 Rn#5 001000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Logical Shift Left Variable", 
    "name": "LSLV", 
    "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "LSRV <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "LSRV <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 Rn#5 001001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Logical Shift Right Variable", 
    "name": "LSRV", 
    "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "MADD <Wd>, <Wn>, <Wm>, <Wa>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "MADD <Xd>, <Xn>, <Xm>, <Xa>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011011000 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply-Add", 
    "name": "MADD", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\ninteger result;\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\nendif\nX[d] = result<destsize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 0000 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply-Add to accumulator (vector, by element)", 
    "name": "MLA (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MLA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 100101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply-Add to accumulator (vector)", 
    "name": "MLA (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 0100 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply-Subtract from accumulator (vector, by element)", 
    "name": "MLS (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MLS <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 100101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply-Subtract from accumulator (vector)", 
    "name": "MLS (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    if sub_op then\n        Elem[result, e, esize] = Elem[operand3, e, esize] - product;\n    else\n        Elem[result, e, esize] = Elem[operand3, e, esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer rd = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\nendcase\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);\n", 
        "encodings": [
          {
            "condition": "op == 0 && cmode == 1110", 
            "format": "MOVI <Vd>.<T>, #<imm8>{, LSL #0}"
          }, 
          {
            "condition": "op == 0 && cmode == 10x0", 
            "format": "MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }, 
          {
            "condition": "op == 0 && cmode == 0xx0", 
            "format": "MOVI <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }, 
          {
            "condition": "op == 0 && cmode == 110x", 
            "format": "MOVI <Vd>.<T>, #<imm8>, MSL #<amount>"
          }, 
          {
            "condition": "Q == 0 && op == 1 && cmode == 1110", 
            "format": "MOVI <Dd>, #<imm>"
          }, 
          {
            "condition": "Q == 1 && op == 1 && cmode == 1110", 
            "format": "MOVI <Vd>.2D, #<imm>"
          }
        ], 
        "pattern": "Q#1 0 op#1 a#1 0111100000 b#1 c#1 cmode#4 d#1 01 e#1 f#1 g#1 h#1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move Immediate (vector)", 
    "name": "MOVI", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\nendcase\nV[rd] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\nendcase\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "MOVK <Wd>, #<imm>{, LSL #<shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "MOVK <Xd>, #<imm>{, LSL #<shift>}"
          }
        ], 
        "pattern": "sf#1 hw#2 11100101 imm16#16 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move wide with keep", 
    "name": "MOVK", 
    "operation": "bits(datasize) result;\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\nendif\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\nendcase\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "MOVN <Wd>, #<imm>{, LSL #<shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "MOVN <Xd>, #<imm>{, LSL #<shift>}"
          }
        ], 
        "pattern": "sf#1 hw#2 00100101 imm16#16 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move wide with NOT", 
    "name": "MOVN", 
    "operation": "bits(datasize) result;\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\nendif\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger datasize = if sf == '1' then 64 else 32;\nbits(16) imm = imm16;\ninteger pos;\nMoveWideOp opcode;\ncase opc of\n    when '00' opcode = MoveWideOp_N;\n    when '10' opcode = MoveWideOp_Z;\n    when '11' opcode = MoveWideOp_K;\n    otherwise UnallocatedEncoding();\nendcase\nif sf == '0' && hw<1> == '1' then UnallocatedEncoding();\npos = UInt(hw:'0000');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "MOVZ <Wd>, #<imm>{, LSL #<shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "MOVZ <Xd>, #<imm>{, LSL #<shift>}"
          }
        ], 
        "pattern": "sf#1 hw#2 10100101 imm16#16 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move wide with zero", 
    "name": "MOVZ", 
    "operation": "bits(datasize) result;\nif opcode == MoveWideOp_K then\n    result = X[d];\nelse\n    result = Zeros();\nendif\nresult<pos+15:pos> = imm;\nif opcode == MoveWideOp_N then\n    result = NOT(result);\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\ninteger t = UInt(Rt);\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MRS <Xt>, (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>)"
          }
        ], 
        "pattern": "o0#1 110101010011 op1#3 CRn#4 CRm#4 op2#3 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move System Register", 
    "name": "MRS", 
    "operation": "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "AArch64.CheckSystemAccess('00', op1, '0100', CRm, op2, '11111', '0');\nbits(4) operand = CRm;\nPSTATEField field;\ncase op1:op2 of\n    when '000011' \n        if !HaveUAOExt() then\n            UnallocatedEncoding();\n        endif\n        field = PSTATEField_UAO;\n    when '000100' \n        if !HavePANExt() then\n            UnallocatedEncoding();\n        endif\n        field = PSTATEField_PAN;\n    when '000101' field = PSTATEField_SP;\n    when '011110' field = PSTATEField_DAIFSet;\n    when '011111' field = PSTATEField_DAIFClr;\n    otherwise      UnallocatedEncoding();\nendcase\nif op1 == '011' && PSTATE.EL == EL0 && (IsInHost() || SCTLR_EL1.UMA == '0') then\n    AArch64.SystemRegisterTrap(EL1, '00', op2, op1, '0100', '11111', CRm, '0');\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MSR <pstatefield>, #<imm>"
          }
        ], 
        "pattern": "op1#3 1101010100000 CRm#4 0100 op2#3 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move immediate value to Special Register", 
    "name": "MSR (immediate)", 
    "operation": "case field of\n    when PSTATEField_SP    \n        PSTATE.SP = operand<0>;\n    when PSTATEField_DAIFSet\n        PSTATE.D = PSTATE.D OR operand<3>;\n        PSTATE.A = PSTATE.A OR operand<2>;\n        PSTATE.I = PSTATE.I OR operand<1>;\n        PSTATE.F = PSTATE.F OR operand<0>;\n    when PSTATEField_DAIFClr\n        PSTATE.D = PSTATE.D AND NOT(operand<3>);\n        PSTATE.A = PSTATE.A AND NOT(operand<2>);\n        PSTATE.I = PSTATE.I AND NOT(operand<1>);\n        PSTATE.F = PSTATE.F AND NOT(operand<0>);\n    when PSTATEField_PAN\n        PSTATE.PAN = operand<0>;\n    when PSTATEField_UAO\n        PSTATE.UAO = operand<0>;\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "AArch64.CheckSystemAccess('1':o0, op1, CRn, CRm, op2, Rt, L);\ninteger t = UInt(Rt);\ninteger sys_op0 = 2 + UInt(o0);\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean read = (L == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MSR (<systemreg>|S<op0>_<op1>_<Cn>_<Cm>_<op2>), <Xt>"
          }
        ], 
        "pattern": "o0#1 110101010001 op1#3 CRn#4 CRm#4 op2#3 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move general-purpose register to System Register", 
    "name": "MSR (register)", 
    "operation": "if read then\n    X[t] = AArch64.SysRegRead(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysRegWrite(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = if sf == '1' then 64 else 32;\ninteger datasize = destsize;\nboolean sub_op = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "MSUB <Wd>, <Wn>, <Wm>, <Wa>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "MSUB <Xd>, <Xn>, <Xm>, <Xa>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011011000 Ra#5 1 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply-Subtract", 
    "name": "MSUB", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\ninteger result;\nif sub_op then\n    result = UInt(operand3) - (UInt(operand1) * UInt(operand2));\nelse\n    result = UInt(operand3) + (UInt(operand1) * UInt(operand2));\nendif\nX[d] = result<destsize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 1000 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply (vector, by element)", 
    "name": "MUL (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) product;\nelement2 = UInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = UInt(Elem[operand1, e, esize]);\n    product = (element1 * element2)<esize-1:0>;\n    Elem[result, e, esize] = product;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean poly = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "MUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 100111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Multiply (vector)", 
    "name": "MUL (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    endif\n    Elem[result, e, esize] = product;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer rd = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\nendcase\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);\n", 
        "encodings": [
          {
            "condition": "cmode == 10x0", 
            "format": "MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }, 
          {
            "condition": "cmode == 0xx0", 
            "format": "MVNI <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }, 
          {
            "condition": "cmode == 110x", 
            "format": "MVNI <Vd>.<T>, #<imm8>, MSL #<amount>"
          }
        ], 
        "pattern": "Q#1 0 a#1 10111100000 b#1 c#1 cmode#4 d#1 01 e#1 f#1 g#1 h#1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Move inverted Immediate (vector)", 
    "name": "MVNI", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\nendcase\nV[rd] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "NEG <V><d>, <V><n>"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100000101110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "NEG <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000101110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Negate (vector)", 
    "name": "NEG (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    endif\n    Elem[result, e, esize] = element<esize-1:0>;                \nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "NOP"
          }
        ], 
        "pattern": "11010101000000110010000000011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "No Operation", 
    "name": "NOP", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "NOT <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111000100000010110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise NOT (vector)", 
    "name": "NOT", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = NOT(element);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ORN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110111 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise inclusive OR NOT (vector)", 
    "name": "ORN (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ORN <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ORN <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0101010 Rm#5 1 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise OR NOT (shifted register)", 
    "name": "ORN (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "cmode", 
            "==", 
            "xxx1"
          ]
        ], 
        "decoder_pre": "integer rd = UInt(Rd);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(datasize) imm;\nbits(64) imm64;\nImmediateOp operation;\ncase cmode:op of\n    when '0xx00' operation = ImmediateOp_MOVI;\n    when '0xx01' operation = ImmediateOp_MVNI;\n    when '0xx10' operation = ImmediateOp_ORR;\n    when '0xx11' operation = ImmediateOp_BIC;\n    when '10x00' operation = ImmediateOp_MOVI;\n    when '10x01' operation = ImmediateOp_MVNI;\n    when '10x10' operation = ImmediateOp_ORR;\n    when '10x11' operation = ImmediateOp_BIC;\n    when '110x0' operation = ImmediateOp_MOVI;\n    when '110x1' operation = ImmediateOp_MVNI;\n    when '1110x' operation = ImmediateOp_MOVI;\n    when '11110' operation = ImmediateOp_MOVI;\n    when '11111' \n        if Q == '0' then UnallocatedEncoding();\n        operation = ImmediateOp_MOVI;\nendcase\nimm64 = AdvSIMDExpandImm(op, cmode, a:b:c:d:e:f:g:h);\nimm = Replicate(imm64, datasize DIV 64);\n", 
        "encodings": [
          {
            "condition": "cmode == 10x1", 
            "format": "ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }, 
          {
            "condition": "cmode == 0xx1", 
            "format": "ORR <Vd>.<T>, #<imm8>{, LSL #<amount>}"
          }
        ], 
        "pattern": "Q#1 0 a#1 00111100000 b#1 c#1 cmode#4 d#1 01 e#1 f#1 g#1 h#1 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise inclusive OR (vector, immediate)", 
    "name": "ORR (vector, immediate)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand;\nbits(datasize) result;\ncase operation of\n    when ImmediateOp_MOVI\n        result = imm;\n    when ImmediateOp_MVNI\n        result = NOT(imm);\n    when ImmediateOp_ORR\n        operand = V[rd];\n        result = operand OR imm;\n    when ImmediateOp_BIC\n        operand = V[rd];\n        result = operand AND NOT(imm);\nendcase\nV[rd] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean invert = (size<0> == '1');\nLogicalOp op = if size<1> == '1' then LogicalOp_ORR else LogicalOp_AND;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ORR <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110101 Rn#5 000111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise inclusive OR (vector, register)", 
    "name": "ORR (vector, register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND\n        result = operand1 AND operand2;\n    when LogicalOp_ORR\n        result = operand1 OR operand2;\nendcase\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nbits(datasize) imm;\nif sf == '0' && N != '0' then ReservedValue();\n(imm, -) = DecodeBitMasks(N, imms, immr, TRUE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "ORR <Wd|WSP>, <Wn>, #<imm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ORR <Xd|SP>, <Xn>, #<imm>"
          }
        ], 
        "pattern": "sf#1 N#1 01100100 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise OR (immediate)", 
    "name": "ORR (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = imm;\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean setflags;\nLogicalOp op;\ncase opc of\n    when '00' op = LogicalOp_AND; setflags = FALSE;\n    when '01' op = LogicalOp_ORR; setflags = FALSE;\n    when '10' op = LogicalOp_EOR; setflags = FALSE;\n    when '11' op = LogicalOp_AND; setflags = TRUE;\nendcase\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\nboolean invert = (N == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "ORR <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "ORR <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 0101010 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Bitwise OR (shifted register)", 
    "name": "ORR (shifted register)", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nif invert then operand2 = NOT(operand2);\ncase op of\n    when LogicalOp_AND result = operand1 AND operand2;\n    when LogicalOp_ORR result = operand1 OR  operand2;\n    when LogicalOp_EOR result = operand1 EOR operand2;\nendcase\nif setflags then\n    PSTATE.<N,Z,C,V> = result<datasize-1>:IsZeroBit(result):'00';\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "PACDA <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "PACDZA <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Pointer Authentication Code for Data address, using key A", 
    "name": "PACDA, PACDZA", 
    "operation": "if source_is_sp then\n    X[d] = AddPACDA(X[d], SP[]);\nelse\n    X[d] = AddPACDA(X[d], X[n]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "PACDB <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "PACDZB <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Pointer Authentication Code for Data address, using key B", 
    "name": "PACDB, PACDZB", 
    "operation": "if source_is_sp then\n    X[d] = AddPACDB(X[d], SP[]);\nelse\n    X[d] = AddPACDB(X[d], X[n]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif m == 31 then source_is_sp = TRUE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PACGA <Xd>, <Xn>, <Xm|SP>"
          }
        ], 
        "pattern": "Rm#5 10011010110 Rn#5 001100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Pointer Authentication Code, using Generic key", 
    "name": "PACGA", 
    "operation": "if source_is_sp then\n    X[d] = AddPACGA(X[n], SP[]);\nelse\n    X[d] = AddPACGA(X[n], X[m]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "PACIA <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "PACIZA <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 000 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "CRm", 
            "==", 
            "00x1"
          ], 
          [
            "op2", 
            "==", 
            "00x"
          ]
        ], 
        "decoder_pre": "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\ncase CRm:op2 of\n    when '0011000' \n        d = 30;\n        n = 31;\n    when '0011001' \n        d = 30;\n        source_is_sp = TRUE;\n    when '0001000' \n        d = 17;\n        n = 16;\n    when '0001010' SEE \"PACIB\";\n    when '0001100' SEE \"AUTIA\";\n    when '0001110' SEE \"AUTIB\";\n    when '001101x' SEE \"PACIB\";\n    when '001110x' SEE \"AUTIA\";\n    when '001111x' SEE \"AUTIB\";\n    when '0000111' SEE \"XPACLRI\";\nendcase\n", 
        "encodings": [
          {
            "condition": "CRm == 0001 && op2 == 000", 
            "format": "PACIA1716"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 001", 
            "format": "PACIASP"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 000", 
            "format": "PACIAZ"
          }
        ], 
        "pattern": "CRm#4 11010101000000110010 op2#3 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Pointer Authentication Code for Instruction address, using key A", 
    "name": "PACIA, PACIA1716, PACIASP, PACIAZ, PACIZA", 
    "operation": "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AddPACIA(X[d], SP[]);\n    else\n        X[d] = AddPACIA(X[d], X[n]);\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean source_is_sp = FALSE;\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif Z == '0' then \n    if n == 31 then source_is_sp = TRUE;\nelse \n    if n != 31 then UnallocatedEncoding();\nendif\n", 
        "encodings": [
          {
            "condition": "Z == 0", 
            "format": "PACIB <Xd>, <Xn|SP>"
          }, 
          {
            "condition": "Z == 1 && Rn == 11111", 
            "format": "PACIZB <Xd>"
          }
        ], 
        "pattern": "Z#1 110110101100000100 Rn#5 001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "CRm", 
            "==", 
            "00x1"
          ], 
          [
            "op2", 
            "==", 
            "01x"
          ]
        ], 
        "decoder_pre": "integer d;\ninteger n;\nboolean source_is_sp = FALSE;\ncase CRm:op2 of\n    when '0011010' \n        d = 30;\n        n = 31;\n    when '0011011' \n        d = 30;\n        source_is_sp = TRUE;\n    when '0001010' \n        d = 17;\n        n = 16;\n    when '0001000' SEE \"PACIA\";\n    when '0001100' SEE \"AUTIA\";\n    when '0001110' SEE \"AUTIB\";\n    when '001100x' SEE \"PACIA\";\n    when '001110x' SEE \"AUTIA\";\n    when '001111x' SEE \"AUTIB\";\n    when '0000111' SEE \"XPACLRI\";\nendcase\n", 
        "encodings": [
          {
            "condition": "CRm == 0001 && op2 == 010", 
            "format": "PACIB1716"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 011", 
            "format": "PACIBSP"
          }, 
          {
            "condition": "CRm == 0011 && op2 == 010", 
            "format": "PACIBZ"
          }
        ], 
        "pattern": "CRm#4 11010101000000110010 op2#3 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Pointer Authentication Code for Instruction address, using key B", 
    "name": "PACIB, PACIB1716, PACIBSP, PACIBZ, PACIZB", 
    "operation": "if HavePACExt() then\n    if source_is_sp then\n        X[d] = AddPACIB(X[d], SP[]);\n    else\n        X[d] = AddPACIB(X[d], X[n]);\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif U == '1' && size != '00' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean poly = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PMUL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 100111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Polynomial Multiply", 
    "name": "PMUL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nbits(esize) product;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if poly then\n        product = PolynomialMult(element1, element2)<esize-1:0>;\n    else\n        product = (UInt(element1) * UInt(element2))<esize-1:0>;\n    endif\n    Elem[result, e, esize] = product;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '01' || size == '10' then ReservedValue();\nif size == '11' && ! HaveCryptoExt() then UnallocatedEncoding();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 111000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Polynomial Multiply Long", 
    "name": "PMULL, PMULL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    Elem[result, e, 2*esize] = PolynomialMult(element1, element2);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PRFM (<prfop>|#<imm5>), [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "imm12#12 1111100110 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Prefetch Memory (immediate)", 
    "name": "PRFM (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\nMemOp memop = MemOp_LOAD;\nboolean signed = FALSE;\ninteger size;\nbits(64) offset;\ncase opc of\n    when '00'\n        size = 4;\n    when '01'\n        size = 8;\n    when '10'\n        size = 4;\n        signed = TRUE;\n    when '11'\n        memop = MemOp_PREFETCH;\nendcase\noffset = SignExtend(imm19:'00', 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PRFM (<prfop>|#<imm5>), <label>"
          }
        ], 
        "pattern": "imm19#19 11011000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Prefetch Memory (literal)", 
    "name": "PRFM (literal)", 
    "operation": "bits(64) address = PC[] + offset;\nbits(size*8) data;\ncase memop of\n    when MemOp_LOAD\n        data = Mem[address, size, AccType_NORMAL];\n        if signed then\n            X[t] = SignExtend(data, 64);\n        else\n            X[t] = data;\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PRFM (<prfop>|#<imm5>), [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "Rm#5 11111000101 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Prefetch Memory (register)", 
    "name": "PRFM (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PRFUM (<prfop>|#<imm5>), [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 11111000100 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Prefetch Memory (unscaled offset)", 
    "name": "PRFM (unscaled offset)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "PSB CSYNC"
          }
        ], 
        "pattern": "11010101000000110010001000111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Profiling Synchronization Barrier", 
    "name": "PSB CSYNC", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "RADDHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Rounding Add returning High Narrow", 
    "name": "RADDHN, RADDHN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "RAX1 <Vd>.2D, <Vn>.2D, <Vm>.2D"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 100011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Rotate and Exclusive OR", 
    "name": "RAX1", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nV[d] = Vn EOR (ROL(Vm<127:64>,1):ROL(Vm<63:0>, 1));\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "RBIT <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001100000010110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse Bit order (vector)", 
    "name": "RBIT (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(esize) element;\nbits(esize) rev;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    for i = 0 to esize-1\n        rev<esize-1-i> = element<i>;\n    endfor\n    Elem[result, e, esize] = rev;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "RBIT <Wd>, <Wn>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "RBIT <Xd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 Rn#5 101101011000000000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse Bits", 
    "name": "RBIT", 
    "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\nfor i = 0 to datasize-1\n    result<datasize-1-i> = operand<i>;\nendfor\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\nendif\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\nendcase\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n    endif\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;\n    endif\nendif\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "RET {<Xn>}"
          }
        ], 
        "pattern": "Rn#5 1101011001011111000000 00000", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Return from subroutine", 
    "name": "RET", 
    "operation": "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n    endif\nendif\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\nBranchType branch_type;\ninteger m = UInt(Rm);\nboolean pac = (A == '1');\nboolean use_key_a = (M == '0');\nboolean source_is_sp = ((Z == '1') && (m == 31));\nif !pac && m != 0 then \n    UnallocatedEncoding();\nelsif pac && !HavePACExt() then \n    UnallocatedEncoding();\nendif\ncase op of\n    when '00' branch_type = BranchType_JMP;\n    when '01' branch_type = BranchType_CALL;\n    when '10' branch_type = BranchType_RET;\n    otherwise UnallocatedEncoding();\nendcase\nif pac then\n    if Z == '0' && m != 31 then\n        UnallocatedEncoding();\n    endif\n    if branch_type == BranchType_RET then\n        if n !=31 then UnallocatedEncoding();\n        n = 30;\n        source_is_sp = TRUE;\n    endif\nendif\n", 
        "encodings": [
          {
            "condition": "M == 0", 
            "format": "RETAA"
          }, 
          {
            "condition": "M == 1", 
            "format": "RETAB"
          }
        ], 
        "pattern": "M#1 110101100101111100001 1111111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Return from subroutine, with pointer authentication", 
    "name": "RETAA, RETAB", 
    "operation": "bits(64) target = X[n];\nif pac then\n    bits(64) modifier = if source_is_sp then SP[] else X[m];\n    if use_key_a then\n        target = AuthIA(target, modifier);\n    else\n        target = AuthIB(target, modifier);\n    endif\nendif\nif branch_type == BranchType_CALL then X[30] = PC[] + 4;\nBranchTo(target, branch_type);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && opc == 10", 
            "format": "REV <Wd>, <Wn>"
          }, 
          {
            "condition": "sf == 1 && opc == 11", 
            "format": "REV <Xd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 opc#2 1011010110000000000 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse Bytes", 
    "name": "REV", 
    "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n    endfor\nendfor\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(2) op = o0:U; \nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\nendcase\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "REV16 <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000000110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse elements in 16-bit halfwords (vector)", 
    "name": "REV16 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n    endfor\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "REV16 <Wd>, <Wn>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "REV16 <Xd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 Rn#5 101101011000000000001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse bytes in 16-bit halfwords", 
    "name": "REV16", 
    "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n    endfor\nendfor\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(2) op = o0:U; \nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\nendcase\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "REV32 <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000000010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse elements in 32-bit words (vector)", 
    "name": "REV32 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n    endfor\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\ninteger container_size;\ncase opc of\n    when '00'\n        Unreachable();\n    when '01'\n        container_size = 16;\n    when '10'\n        container_size = 32;\n    when '11'\n        if sf == '0' then UnallocatedEncoding();\n        container_size = 64;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "REV32 <Xd>, <Xn>"
          }
        ], 
        "pattern": "Rn#5 1101101011000000000010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse bytes in 32-bit words", 
    "name": "REV32", 
    "operation": "bits(datasize) operand = X[n];\nbits(datasize) result;\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV 8;\ninteger index = 0;\ninteger rev_index;\nfor c = 0 to containers-1\n    rev_index = index + ((elements_per_container - 1) * 8);\n    for e = 0 to elements_per_container-1\n        result<rev_index + 7:rev_index> = operand<index + 7:index>;\n        index = index + 8;\n        rev_index = rev_index - 8;\n    endfor\nendfor\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\nbits(2) op = o0:U; \nif UInt(op)+UInt(size) >= 3 then UnallocatedEncoding();\ninteger container_size;\ncase op of\n    when '10' container_size = 16;\n    when '01' container_size = 32;\n    when '00' container_size = 64;\nendcase\ninteger containers = datasize DIV container_size;\ninteger elements_per_container = container_size DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "REV64 <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000000010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Reverse elements in 64-bit doublewords (vector)", 
    "name": "REV64", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element = 0;\ninteger rev_element;\nfor c = 0 to containers-1\n    rev_element = element + elements_per_container - 1;\n    for e = 0 to elements_per_container-1\n        Elem[result, rev_element, esize] = Elem[operand, element, esize];\n        element = element + 1;\n        rev_element = rev_element - 1;\n    endfor\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nShiftType shift_type = DecodeShift(op2);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "RORV <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "RORV <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 Rn#5 001011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Rotate Right Variable", 
    "name": "RORV", 
    "operation": "bits(datasize) result;\nbits(datasize) operand2 = X[m];\nresult = ShiftReg(n, shift_type, UInt(operand2) MOD datasize);\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "RSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 100011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Rounding Shift Right Narrow (immediate)", 
    "name": "RSHRN, RSHRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "RSUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 011000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Rounding Subtract returning High Narrow", 
    "name": "RSUBHN, RSUBHN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 011111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Absolute difference and Accumulate", 
    "name": "SABA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 010100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Absolute difference and Accumulate Long", 
    "name": "SABAL, SABAL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 011101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Absolute Difference", 
    "name": "SABD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 011100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Absolute Difference Long", 
    "name": "SABDL, SABDL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SADALP <Vd>.<Ta>, <Vn>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Add and Accumulate Long Pairwise", 
    "name": "SADALP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Add Long (vector)", 
    "name": "SADDL, SADDL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SADDLP <Vd>.<Ta>, <Vn>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Add Long Pairwise", 
    "name": "SADDLP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SADDLV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 110000001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Add Long across Vector", 
    "name": "SADDLV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\nendfor\nV[d] = sum<2*esize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 000100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Add Wide", 
    "name": "SADDW, SADDW2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SBC <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SBC <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 1011010000 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract with Carry", 
    "name": "SBC", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\nif sub_op then\n    operand2 = NOT(operand2);\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SBCS <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SBCS <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 1111010000 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract with Carry, setting flags", 
    "name": "SBCS", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(4) nzcv;\nif sub_op then\n    operand2 = NOT(operand2);\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, PSTATE.C);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    \n    when '01' inzero = FALSE; extend = FALSE;   \n    when '10' inzero = TRUE;  extend = FALSE;   \n    when '11' UnallocatedEncoding();\nendcase\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "SBFM <Wd>, <Wn>, #<immr>, #<imms>"
          }, 
          {
            "condition": "sf == 1 && N == 1", 
            "format": "SBFM <Xd>, <Xn>, #<immr>, #<imms>"
          }
        ], 
        "pattern": "sf#1 N#1 00100110 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Bitfield Move", 
    "name": "SBFM", 
    "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SCVTF <V><d>, <V><n>, #<fbits>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 111001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 111001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed fixed-point Convert to Floating-point (vector)", 
    "name": "SCVTF (vector, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SCVTF <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0101111001111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SCVTF <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 010111100 Rn#5 100001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SCVTF <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 00111001111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SCVTF <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011100 Rn#5 100001110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed integer Convert to Floating-point (vector)", 
    "name": "SCVTF (vector, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\ncase opcode<2:1>:rmode of\n    when '0011'        \n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "SCVTF <Hd>, <Wn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "SCVTF <Sd>, <Wn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "SCVTF <Dd>, <Wn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "SCVTF <Hd>, <Xn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "SCVTF <Sd>, <Xn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "SCVTF <Dd>, <Xn>, #<fbits>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 scale#6 000010 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed fixed-point Convert to Floating-point (scalar)", 
    "name": "SCVTF (scalar, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "SCVTF <Hd>, <Wn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "SCVTF <Sd>, <Wn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "SCVTF <Dd>, <Wn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "SCVTF <Hd>, <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "SCVTF <Sd>, <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "SCVTF <Dd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 100010000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed integer Convert to Floating-point (scalar)", 
    "name": "SCVTF (scalar, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SDIV <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SDIV <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 Rn#5 000011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Divide", 
    "name": "SDIV", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\nendif\nX[d] = result<datasize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveDOTPExt() then UNDEFINED;\nif size  != '10' then ReservedValue();\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger index = UInt(H:L);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 1110 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Dot Product signed arithmetic (vector, by element)", 
    "name": "SDOT (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(datasize) result = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3\n        if signed then  \n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        endif\n        res = res + element1 * element2; \n    endfor\n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveDOTPExt() then UNDEFINED;\nif size!= '10' then ReservedValue();\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 100101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Dot Product signed arithmetic (vector)", 
    "name": "SDOT (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        endif\n        res = res + element1 * element2; \n    endfor\n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SEV"
          }
        ], 
        "pattern": "11010101000000110010000010011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Send Event", 
    "name": "SEV", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SEVL"
          }
        ], 
        "pattern": "11010101000000110010000010111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Send Event Local", 
    "name": "SEVL", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA1C <Qd>, <Sn>, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA1 hash update (choose)", 
    "name": "SHA1C", 
    "operation": "CheckCryptoEnabled64();\nbits(128) X = V[d];\nbits(32)  Y = V[n];     \nbits(128) W = V[m];\nbits(32)  t;\nfor e = 0 to 3\n    t = SHAchoose(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nendfor\nV[d] = X;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA1H <Sd>, <Sn>"
          }
        ], 
        "pattern": "Rn#5 0101111000101000000010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA1 fixed rotate", 
    "name": "SHA1H", 
    "operation": "CheckCryptoEnabled64();\nbits(32) operand = V[n];        \nV[d] = ROL(operand, 30);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA1M <Qd>, <Sn>, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 001000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA1 hash update (majority)", 
    "name": "SHA1M", 
    "operation": "CheckCryptoEnabled64();\nbits(128) X = V[d];\nbits(32)  Y = V[n];     \nbits(128) W = V[m];\nbits(32)  t;\nfor e = 0 to 3\n    t = SHAmajority(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nendfor\nV[d] = X;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA1P <Qd>, <Sn>, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 000100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA1 hash update (parity)", 
    "name": "SHA1P", 
    "operation": "CheckCryptoEnabled64();\nbits(128) X = V[d];\nbits(32)  Y = V[n];     \nbits(128) W = V[m];\nbits(32)  t;\nfor e = 0 to 3\n    t = SHAparity(X<63:32>, X<95:64>, X<127:96>);\n    Y = Y + ROL(X<31:0>, 5) + t + Elem[W, e, 32];\n    X<63:32> = ROL(X<63:32>, 30);\n    <Y, X> = ROL(Y : X, 32);\nendfor\nV[d] = X;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA1SU0 <Vd>.4S, <Vn>.4S, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 001100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA1 schedule update 0", 
    "name": "SHA1SU0", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\nresult = operand2<63:0> : operand1<127:64>;\nresult = result EOR operand1 EOR operand3;\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA1SU1 <Vd>.4S, <Vn>.4S"
          }
        ], 
        "pattern": "Rn#5 0101111000101000000110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA1 schedule update 1", 
    "name": "SHA1SU1", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand1 EOR LSR(operand2, 32);\nresult<31:0>   = ROL(T<31:0>,   1);\nresult<63:32>  = ROL(T<63:32>,  1);\nresult<95:64>  = ROL(T<95:64>,  1);\nresult<127:96> = ROL(T<127:96>, 1) EOR ROL(T<31:0>, 2);\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean part1 = (P == '0');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA256H2 <Qd>, <Qn>, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 010100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA256 hash update (part 2)", 
    "name": "SHA256H2", 
    "operation": "CheckCryptoEnabled64();\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\nboolean part1 = (P == '0');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA256H <Qd>, <Qn>, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 010000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA256 hash update (part 1)", 
    "name": "SHA256H", 
    "operation": "CheckCryptoEnabled64();\nbits(128) result;\nif part1 then\n    result = SHA256hash(V[d], V[n], V[m], TRUE);\nelse\n    result = SHA256hash(V[n], V[d], V[m], FALSE);\nendif\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA256SU0 <Vd>.4S, <Vn>.4S"
          }
        ], 
        "pattern": "Rn#5 0101111000101000001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA256 schedule update 0", 
    "name": "SHA256SU0", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) result;\nbits(128) T = operand2<31:0> : operand1<127:32>;\nbits(32) elt;\nfor e = 0 to 3\n    elt = Elem[T, e, 32];\n    elt = ROR(elt, 7) EOR ROR(elt, 18) EOR LSR(elt, 3);\n    Elem[result, e, 32] = elt + Elem[operand1, e, 32];\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif ! HaveCryptoExt() then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA256SU1 <Vd>.4S, <Vn>.4S, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 01011110000 Rn#5 011000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA256 schedule update 1", 
    "name": "SHA256SU1", 
    "operation": "CheckCryptoEnabled64();\nbits(128) operand1 = V[d];\nbits(128) operand2 = V[n];\nbits(128) operand3 = V[m];\nbits(128) result;\nbits(128) T0 = operand3<31:0> : operand2<127:32>;\nbits(64) T1;\nbits(32) elt;\nT1 = operand3<127:64>;\nfor e = 0 to 1\n    elt = Elem[T1, e, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\nendfor\nT1 = result<63:0>;\nfor e = 2 to 3\n    elt = Elem[T1, e - 2, 32];\n    elt = ROR(elt, 17) EOR ROR(elt, 19) EOR LSR(elt, 10);\n    elt = elt + Elem[operand1, e, 32] + Elem[T0, e, 32];\n    Elem[result, e, 32] = elt;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA512H2 <Qd>, <Qn>, <Vm>.2D"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA512 Hash update part 2", 
    "name": "SHA512H2", 
    "operation": "bits(128) Vtmp;  \nbits(64) NSigma0;\nbits(64) tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\nNSigma0 =  ROR(Y<63:0>, 28) EOR ROR(Y<63:0>,34) EOR ROR(Y<63:0>,39);\nVtmp<127:64> = (X<63:0> AND Y<127:64>) EOR (X<63:0> AND Y<63:0>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<127:64> = (Vtmp<127:64> + NSigma0 +  W<127:64>);\nNSigma0 =  ROR(Vtmp<127:64>, 28) EOR ROR(Vtmp<127:64>,34) EOR ROR(Vtmp<127:64>,39);\nVtmp<63:0> =   (Vtmp<127:64> AND Y<63:0>) EOR (Vtmp<127:64> AND Y<127:64>) EOR (Y<127:64> AND Y<63:0>);\nVtmp<63:0> =   (Vtmp<63:0> + NSigma0 + W<63:0>);\nV[d] = Vtmp;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA512H <Qd>, <Qn>, <Vm>.2D"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 100000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA512 Hash update part 1", 
    "name": "SHA512H", 
    "operation": "bits(128) Vtmp;  \nbits(64)  MSigma1;\nbits(64)  tmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\nMSigma1 =  ROR(Y<127:64>, 14) EOR ROR(Y<127:64>,18) EOR ROR(Y<127:64>,41);\nVtmp<127:64> =  (Y<127:64> AND X<63:0>) EOR (NOT(Y<127:64>) AND X<127:64>);\nVtmp<127:64> = (Vtmp<127:64> + MSigma1 +  W<127:64>);\ntmp = Vtmp<127:64> + Y<63:0>;\nMSigma1 = ROR(tmp, 14) EOR ROR(tmp,18) EOR ROR(tmp,41);\nVtmp<63:0> = (tmp AND Y<127:64>) EOR (NOT(tmp) AND X<63:0>);\nVtmp<63:0> = (Vtmp<63:0> + MSigma1 + W<63:0>);\nV[d] =  Vtmp;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA512SU0 <Vd>.2D, <Vn>.2D"
          }
        ], 
        "pattern": "Rn#5 1100111011000000100000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA512 Schedule Update 0", 
    "name": "SHA512SU0", 
    "operation": "bits(64) sig0;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) W = V[d]; \nsig0 = ROR(W<127:64>, 1) EOR ROR(W<127:64>, 8) EOR '0000000':W<127:71>; \nVtmp<63:0> = W<63:0> + sig0;\nsig0 = ROR(X<63:0>, 1) EOR ROR(X<63:0>, 8) EOR '0000000':X<63:7>; \nVtmp<127:64> = W<127:64> + sig0;\nV[d] = Vtmp;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHA512SU1 <Vd>.2D, <Vn>.2D, <Vm>.2D"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 100010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SHA512 Schedule Update 1", 
    "name": "SHA512SU1", 
    "operation": "bits(64) sig1;\nbits(128) Vtmp;\nbits(128) X = V[n];\nbits(128) Y = V[m];\nbits(128) W = V[d];\nsig1 = ROR(X<127:64>, 19) EOR ROR(X<127:64>,61) EOR '000000':X<127:70>; \nVtmp<127:64> = W<127:64> + sig1 + Y<127:64>;\nsig1 = ROR(X<63:0>, 19) EOR ROR(X<63:0>,61) EOR '000000':X<63:6>; \nVtmp<63:0> = W<63:0> + sig1 + Y<63:0>;\nV[d] = Vtmp;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 000001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Halving Add", 
    "name": "SHADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = UInt(immh:immb) - esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHL <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 010101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHL <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 010101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Shift Left (immediate)", 
    "name": "SHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = LSL(Elem[operand, e, esize], shift);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = esize;\nboolean unsigned = FALSE; \n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100001001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Shift Left Long (by element size)", 
    "name": "SHLL, SHLL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(2*datasize) result;\ninteger element;\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Shift Right Narrow (immediate)", 
    "name": "SHRN, SHRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nfor e = 0 to elements-1\n    element = (UInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    Elem[result, e, esize] = element<esize-1:0>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 001001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Halving Subtract", 
    "name": "SHSUB", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = UInt(immh:immb) - esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SLI <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 010101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SLI <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 010101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Shift Left and Insert (immediate)", 
    "name": "SLI", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSL(Ones(esize), shift);\nbits(esize) shifted;\nfor e = 0 to elements-1\n    shifted = LSL(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3PARTW1 <Vd>.4S, <Vn>.4S, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3PARTW1", 
    "name": "SM3PARTW1", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \nresult<95:0> = (Vd EOR Vn)<95:0> EOR (ROL(Vm<127:96>,15):ROL(Vm<95:64>,15):ROL(Vm<63:32>,15));\nfor i = 0 to 3\n    if i == 3 then \n        result<127:96> = (Vd EOR Vn)<127:96> EOR (ROL(result<31:0>,15));\n    endif\n    result<(32*i)+31:(32*i)> = result<(32*i)+31:(32*i)> EOR ROL(result<(32*i)+31:(32*i)>,15) EOR ROL(result<(32*i)+31:(32*i)>,23);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3PARTW2 <Vd>.4S, <Vn>.4S, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 110001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3PARTW2", 
    "name": "SM3PARTW2", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) result; \nbits(128) tmp;\nbits(32) tmp2;\ntmp<127:0> = Vn EOR (ROL(Vm<127:96>,7):ROL(Vm<95:64>,7):ROL(Vm<63:32>,7):ROL(Vm<31:0>,7)); \nresult<127:0> = Vd<127:0> EOR tmp<127:0>;\ntmp2 = ROL(tmp<31:0>,15);\ntmp2 = tmp2 EOR ROL(tmp2,15) EOR ROL(tmp2,23);\nresult<127:96> = result<127:96> EOR tmp2;\nV[d]= result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3SS1 <Vd>.4S, <Vn>.4S, <Vm>.4S, <Va>.4S"
          }
        ], 
        "pattern": "Rm#5 11001110010 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3SS1", 
    "name": "SM3SS1", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(128) Va = V[a];\nVd<127:96> = ROL((ROL(Vn<127:96>,12) + Vm<127:96> + Va<127:96>) , 7);\nVd<95:0> = Zeros();\nV[d] = Vd;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger i = UInt(imm2);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3TT1A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          }
        ], 
        "pattern": "Rm#5 11001110010 imm2#2 10 Rn#5 00 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3TT1A", 
    "name": "SM3TT1A", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger i = UInt(imm2);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3TT1B <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          }
        ], 
        "pattern": "Rm#5 11001110010 imm2#2 10 Rn#5 01 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3TT1B", 
    "name": "SM3TT1B", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) WjPrime;\nbits(128) result; \nbits(32) TT1;\nbits(32) SS2;\nWjPrime = Elem[Vm,i,32];\nSS2 = Vn<127:96> EOR ROL(Vd<127:96>,12); \nTT1 = (Vd<127:96> AND Vd<63:32>) OR (Vd<127:96> AND Vd<95:64>) OR (Vd<63:32> AND Vd<95:64>); \nTT1 = (TT1 + Vd<31:0> + SS2 + WjPrime)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,9); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT1; \nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger i = UInt(imm2);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3TT2A <Vd>.4S, <Vn>.4S, <Vm>.S[<imm2>]"
          }
        ], 
        "pattern": "Rm#5 11001110010 imm2#2 10 Rn#5 10 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3TT2A", 
    "name": "SM3TT2A", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT1;\nWj = Elem[Vm,i,32];\nTT2 = Vd<63:32> EOR (Vd<127:96> EOR Vd<95:64>);\nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger i = UInt(imm2);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM3TT2B <Vd>.S, <Vn>.S, <Vm>.S[<imm2>]"
          }
        ], 
        "pattern": "Rm#5 11001110010 imm2#2 10 Rn#5 11 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM3TT2B", 
    "name": "SM3TT2B", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) Vd = V[d];\nbits(32) Wj;\nbits(128) result; \nbits(32) TT2;\nWj = Elem[Vm,i,32];\nTT2 = (Vd<127:96> AND Vd<95:64>) OR (NOT(Vd<127:96>) AND Vd<63:32>); \nTT2 = (TT2 + Vd<31:0> + Vn<127:96> + Wj)<31:0>;\nresult<31:0> = Vd<63:32>;\nresult<63:32> = ROL(Vd<95:64>,19); \nresult<95:64> = Vd<127:96>; \nresult<127:96> = TT2 EOR ROL(TT2,9) EOR ROL(TT2,17); \nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM4E <Vd>.4S, <Vn>.4S"
          }
        ], 
        "pattern": "Rn#5 1100111011000000100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM4 Encode", 
    "name": "SM4E", 
    "operation": "bits(128) Vn = V[n];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) roundresult;\nbits(32) roundkey;\ninteger index;\nroundresult=V[d];\nfor index = 0 to 3\n    roundkey = Elem[Vn,index,32];\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR roundkey; \n    for i = 0 to 3  \n        Elem[intval,i,8]  = Sbox(Elem[intval,i,8]); \n    endfor\n    intval = intval EOR ROL(intval,2) EOR ROL(intval,10) EOR ROL(intval,18) EOR ROL(intval,24);\n    intval = intval EOR roundresult<31:0>; \n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nendfor\nV[d] = roundresult;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveChCryptoExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SM4EKEY <Vd>.4S, <Vn>.4S, <Vm>.4S"
          }
        ], 
        "pattern": "Rm#5 11001110011 Rn#5 110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "SM4 Key", 
    "name": "SM4EKEY", 
    "operation": "bits(128) Vm = V[m];\nbits(32) intval; \nbits(8) sboxout;\nbits(128) result;\nbits(32) const;\nbits(128) roundresult;\ninteger index;\nroundresult = V[n];\nfor index = 0 to 3 \n    const = Elem[Vm,index,32];\n    intval = roundresult<127:96> EOR roundresult<95:64> EOR roundresult<63:32> EOR const; \n    for i = 0 to 3  \n        Elem[intval,i,8] = Sbox(Elem[intval,i,8]); \n    endfor\n    intval = intval EOR ROL(intval,13) EOR ROL(intval,23);\n    intval = intval EOR roundresult<31:0>; \n    roundresult<31:0> = roundresult<63:32>;\n    roundresult<63:32> = roundresult<95:64>;\n    roundresult<95:64> = roundresult<127:96>;\n    roundresult<127:96> = intval; \nendfor\nV[d] = roundresult;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMADDL <Xd>, <Wn>, <Wm>, <Xa>"
          }
        ], 
        "pattern": "Rm#5 10011011001 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply-Add Long", 
    "name": "SMADDL", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\ninteger result;\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\nendif\nX[d] = result<63:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 011001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Maximum (vector)", 
    "name": "SMAX", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 101001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Maximum Pairwise", 
    "name": "SMAXP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean min = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMAXV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 110000101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Maximum across Vector", 
    "name": "SMAXV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\nendfor\nV[d] = maxmin<esize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(16) imm = imm16;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMC #<imm>"
          }
        ], 
        "pattern": "imm16#16 11010100000 00011", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Secure Monitor Call", 
    "name": "SMC", 
    "operation": "AArch64.CheckForSMCUndefOrTrap(imm);\nif SCR_EL3.SMD == '1' then\n    AArch64.UndefinedFault();\nelse\n    AArch64.CallSecureMonitor(imm);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 011011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Minimum (vector)", 
    "name": "SMIN", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 101011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Minimum Pairwise", 
    "name": "SMINP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean min = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMINV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 110001101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Minimum across Vector", 
    "name": "SMINV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\nendfor\nV[d] = maxmin<esize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 0010 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply-Add Long (vector, by element)", 
    "name": "SMLAL, SMLAL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 100000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply-Add Long (vector)", 
    "name": "SMLAL, SMLAL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    endif\n    Elem[result, e, 2*esize] = accum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 0110 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply-Subtract Long (vector, by element)", 
    "name": "SMLSL, SMLSL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 101000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply-Subtract Long (vector)", 
    "name": "SMLSL, SMLSL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    endif\n    Elem[result, e, 2*esize] = accum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size;\ncase Q:imm5 of\n    when 'xxxxx1' size = 0;     \n    when 'xxxx10' size = 1;     \n    when '1xx100' size = 2;     \n    otherwise     UnallocatedEncoding();\nendcase\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;\n", 
        "encodings": [
          {
            "condition": "Q == 0", 
            "format": "SMOV <Wd>, <Vn>.<Ts>[<index>]"
          }, 
          {
            "condition": "Q == 1", 
            "format": "SMOV <Xd>, <Vn>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 imm5#5 001110000 Rn#5 001011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Move vector element to general-purpose register", 
    "name": "SMOV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nX[d] = SignExtend(Elem[operand, index, esize], datasize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMSUBL <Xd>, <Wn>, <Wm>, <Xa>"
          }
        ], 
        "pattern": "Rm#5 10011011001 Ra#5 1 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply-Subtract Long", 
    "name": "SMSUBL", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\ninteger result;\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\nendif\nX[d] = result<63:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           \ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMULH <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "Rm#5 10011011010 Rn#5 011111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply High", 
    "name": "SMULH", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\nX[d] = result<127:64>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 1010 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply Long (vector, by element)", 
    "name": "SMULL, SMULL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Multiply Long (vector)", 
    "name": "SMULL, SMULL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQABS <V><d>, <V><n>"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100000011110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQABS <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000011110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Absolute value", 
    "name": "SQABS", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    endif\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQADD <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 000011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 000011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Add", 
    "name": "SQADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLAL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01011111 L#1 M#1 Rm#4 H#1 0011 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 0011 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply-Add Long (by element)", 
    "name": "SQDMLAL, SQDMLAL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    endif\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\nboolean sub_op = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLAL <Va><d>, <Vb><n>, <Vb><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 100100 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 100100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply-Add Long", 
    "name": "SQDMLAL, SQDMLAL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    endif\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLSL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01011111 L#1 M#1 Rm#4 H#1 0111 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 0111 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply-Subtract Long (by element)", 
    "name": "SQDMLSL, SQDMLSL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    endif\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\nboolean sub_op = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLSL <Va><d>, <Vb><n>, <Vb><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 101100 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 101100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply-Subtract Long", 
    "name": "SQDMLSL, SQDMLSL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\ninteger accum;\nboolean sat1;\nboolean sat2;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat1) = SignedSatQ(2 * element1 * element2, 2*esize);\n    if sub_op then\n        accum = SInt(Elem[operand3, e, 2*esize]) - SInt(product);\n    else\n        accum = SInt(Elem[operand3, e, 2*esize]) + SInt(product);\n    endif\n    (Elem[result, e, 2*esize], sat2) = SignedSatQ(accum, 2*esize);\n    if sat1 || sat2 then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01011111 L#1 M#1 Rm#4 H#1 1100 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 1100 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply returning High half (by element)", 
    "name": "SQDMULH (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULH <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 101101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 101101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply returning High half", 
    "name": "SQDMULH (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01011111 L#1 M#1 Rm#4 H#1 1011 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 1011 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply Long (by element)", 
    "name": "SQDMULL, SQDMULL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULL <Va><d>, <Vb><n>, <Vb><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 110100 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '00' || size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQDMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 110100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Doubling Multiply Long", 
    "name": "SQDMULL, SQDMULL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    (product, sat) = SignedSatQ(2 * element1 * element2, 2*esize);\n    Elem[result, e, 2*esize] = product;\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQNEG <V><d>, <V><n>"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100000011110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean neg = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQNEG <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000011110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Negate", 
    "name": "SQNEG", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = SInt(Elem[operand, e, esize]);\n    if neg then\n        element = -element;\n    else\n        element = Abs(element);\n    endif\n    (Elem[result, e, esize], sat) = SignedSatQ(element, esize);         \n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLAH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01111111 L#1 M#1 Rm#4 H#1 1101 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLAH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 1101 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (by element)", 
    "name": "SQRDMLAH (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    endif\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLAH <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 0 Rn#5 100001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLAH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 0 Rn#5 100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Saturating Rounding Doubling Multiply Accumulate returning High Half (vector)", 
    "name": "SQRDMLAH (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    endif\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLSH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01111111 L#1 M#1 Rm#4 H#1 1111 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = TRUE;\nboolean sub_op = (S  == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLSH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 1111 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (by element)", 
    "name": "SQRDMLSH (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    endif\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLSH <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 0 Rn#5 100011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveQRDMLAHExt() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = TRUE;\nboolean sub_op = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMLSH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 0 Rn#5 100011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Saturating Rounding Doubling Multiply Subtract returning High Half (vector)", 
    "name": "SQRDMLSH (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) operand3 = V[d];\nbits(datasize) result;\ninteger rounding_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger element3;\ninteger product;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    element3 = SInt(Elem[operand3, e, esize]);\n    if sub_op then\n        accum = ((element3 << esize) - 2 * (element1 * element2) + rounding_const);\n    else\n        accum = ((element3 << esize) + 2 * (element1 * element2) + rounding_const);\n    endif\n    (Elem[result, e, esize], sat) = SignedSatQ(accum >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMULH <V><d>, <V><n>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "size#2 01011111 L#1 M#1 Rm#4 H#1 1101 Rn#5 0 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001111 L#1 M#1 Rm#4 H#1 1101 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Rounding Doubling Multiply returning High half (by element)", 
    "name": "SQRDMULH (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(idxdsize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\nelement2 = SInt(Elem[operand2, index, esize]);\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean rounding = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMULH <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 101101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' || size == '00' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean rounding = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRDMULH <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 101101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Rounding Doubling Multiply returning High half", 
    "name": "SQRDMULH (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = if rounding then 1 << (esize - 1) else 0;\ninteger element1;\ninteger element2;\ninteger product;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = SInt(Elem[operand1, e, esize]);\n    element2 = SInt(Elem[operand2, e, esize]);\n    product = (2 * element1 * element2) + round_const;\n    (Elem[result, e, esize], sat) = SignedSatQ(product >> esize, esize);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 010111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 010111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Rounding Shift Left (register)", 
    "name": "SQRSHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRSHRN <Vb><d>, <Va><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 100111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 100111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Rounded Shift Right Narrow (immediate)", 
    "name": "SQRSHRN, SQRSHRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRSHRUN <Vb><d>, <Va><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 100011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQRSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 100011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Rounded Shift Right Unsigned Narrow (immediate)", 
    "name": "SQRSHRUN, SQRSHRUN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = UInt(immh:immb) - esize;\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHL <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 011101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHL <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 011101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Shift Left (immediate)", 
    "name": "SQSHL (immediate)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 010011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 010011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Shift Left (register)", 
    "name": "SQSHL (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = UInt(immh:immb) - esize;\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHLU <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 011001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHLU <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 011001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Shift Left Unsigned (immediate)", 
    "name": "SQSHLU", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHRN <Vb><d>, <Va><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 100101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 100101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Shift Right Narrow (immediate)", 
    "name": "SQSHRN, SQSHRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHRUN <Vb><d>, <Va><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 100001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSHRUN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Shift Right Unsigned Narrow (immediate)", 
    "name": "SQSHRUN, SQSHRUN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = (SInt(Elem[operand, e, 2*esize]) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = UnsignedSatQ(element, esize);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSUB <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 001011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 001011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Subtract", 
    "name": "SQSUB", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQXTN <Vb><d>, <Va><n>"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100001010010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQXTN{2} <Vd>.<Tb>, <Vn>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100001010010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating extract Narrow", 
    "name": "SQXTN, SQXTN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQXTUN <Vb><d>, <Va><n>"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100001001010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SQXTUN{2} <Vd>.<Tb>, <Vn>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100001001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating extract Unsigned Narrow", 
    "name": "SQXTUN, SQXTUN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = UnsignedSatQ(SInt(element), esize);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 000101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Rounding Halving Add", 
    "name": "SRHADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRI <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 010001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRI <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 010001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Shift Right and Insert (immediate)", 
    "name": "SRI", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2 = V[d];\nbits(datasize) result;\nbits(esize) mask = LSR(Ones(esize), shift);\nbits(esize) shifted;\nfor e = 0 to elements-1\n    shifted = LSR(Elem[operand, e, esize], shift);\n    Elem[result, e, esize] = (Elem[operand2, e, esize] AND NOT(mask)) OR shifted;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 010101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 010101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Rounding Shift Left (register)", 
    "name": "SRSHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRSHR <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRSHR <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 001001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Rounding Shift Right (immediate)", 
    "name": "SRSHR", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRSRA <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SRSRA <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 001101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Rounding Shift Right and Accumulate (immediate)", 
    "name": "SRSRA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01011110 Rm#5 1 Rn#5 010001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 010001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Shift Left (register)", 
    "name": "SSHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 101001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Shift Left Long (immediate)", 
    "name": "SSHLL, SSHLL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSHR <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSHR <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 000001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Shift Right (immediate)", 
    "name": "SSHR", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSRA <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 010111110 immb#3 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSRA <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 0011110 immb#3 Rn#5 000101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Shift Right and Accumulate (immediate)", 
    "name": "SSRA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 001000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Subtract Long", 
    "name": "SSUBL, SSUBL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SSUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 001100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed Subtract Wide", 
    "name": "SSUBW, SSUBW2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1x"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 0111", 
            "format": "ST1 { <Vt>.<T> }, [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 1010", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 0110", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 0010", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#4 00110000000000 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1x"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 0111", 
            "format": "ST1 { <Vt>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 0111", 
            "format": "ST1 { <Vt>.<T> }, [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 1010", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 1010", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 0110", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 0110", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 0010", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 0010", 
            "format": "ST1 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100100 opcode_#4 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Store multiple single-element structures from one, two, three, or four registers", 
    "name": "ST1 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 000", 
            "format": "ST1 { <Vt>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 010 && size == x0", 
            "format": "ST1 { <Vt>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && size == 00", 
            "format": "ST1 { <Vt>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && S == 0 && size == 01", 
            "format": "ST1 { <Vt>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110100000000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 000", 
            "format": "ST1 { <Vt>.B }[<index>], [<Xn|SP>], #1"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 000", 
            "format": "ST1 { <Vt>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 010 && size == x0", 
            "format": "ST1 { <Vt>.H }[<index>], [<Xn|SP>], #2"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 010 && size == x0", 
            "format": "ST1 { <Vt>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && size == 00", 
            "format": "ST1 { <Vt>.S }[<index>], [<Xn|SP>], #4"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && size == 00", 
            "format": "ST1 { <Vt>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "ST1 { <Vt>.D }[<index>], [<Xn|SP>], #8"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "ST1 { <Vt>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101100 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Store a single-element structure from one lane of one register", 
    "name": "ST1 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001100000000001000 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "ST2 { <Vt>.<T>, <Vt2>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100100 size#2 1000 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Store multiple 2-element structures from two registers", 
    "name": "ST2 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 000", 
            "format": "ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 010 && size == x0", 
            "format": "ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && size == 00", 
            "format": "ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 100 && S == 0 && size == 01", 
            "format": "ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110100100000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx0"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 000", 
            "format": "ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], #2"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 000", 
            "format": "ST2 { <Vt>.B, <Vt2>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 010 && size == x0", 
            "format": "ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], #4"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 010 && size == x0", 
            "format": "ST2 { <Vt>.H, <Vt2>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && size == 00", 
            "format": "ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], #8"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && size == 00", 
            "format": "ST2 { <Vt>.S, <Vt2>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], #16"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 100 && S == 0 && size == 01", 
            "format": "ST2 { <Vt>.D, <Vt2>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101101 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Store single 2-element structure from one lane of two registers", 
    "name": "ST2 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001100000000000100 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "ST3 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100100 size#2 0100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Store multiple 3-element structures from three registers", 
    "name": "ST3 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 001", 
            "format": "ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 011 && size == x0", 
            "format": "ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && size == 00", 
            "format": "ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && S == 0 && size == 01", 
            "format": "ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110100000000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 001", 
            "format": "ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], #3"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 001", 
            "format": "ST3 { <Vt>.B, <Vt2>.B, <Vt3>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 011 && size == x0", 
            "format": "ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], #6"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 011 && size == x0", 
            "format": "ST3 { <Vt>.H, <Vt2>.H, <Vt3>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && size == 00", 
            "format": "ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], #12"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && size == 00", 
            "format": "ST3 { <Vt>.S, <Vt2>.S, <Vt3>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], #24"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "ST3 { <Vt>.D, <Vt2>.D, <Vt3>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101100 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Store single 3-element structure from one lane of three registers", 
    "name": "ST3 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 001100000000000000 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111", 
            "format": "ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <imm>"
          }, 
          {
            "condition": "Rm != 11111", 
            "format": "ST4 { <Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>, <Vt4>.<T> }, [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001100100 size#2 0000 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "MemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << UInt(size);\ninteger elements = datasize DIV esize;\ninteger rpt;    \ninteger selem;  \ncase opcode of\n    when '0000' rpt = 1; selem = 4;     \n    when '0010' rpt = 4; selem = 1;     \n    when '0100' rpt = 1; selem = 3;     \n    when '0110' rpt = 3; selem = 1;     \n    when '0111' rpt = 1; selem = 1;     \n    when '1000' rpt = 1; selem = 2;     \n    when '1010' rpt = 2; selem = 1;     \n    otherwise UnallocatedEncoding();\nendcase\nif size:Q == '110' && selem != 1 then ReservedValue();\n", 
    "description": "Store multiple 4-element structures from four registers", 
    "name": "ST4 (multiple structures)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(datasize) rval;\ninteger e, r, s, tt;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nfor r = 0 to rpt-1\n    for e = 0 to elements-1\n        tt = (t + r) MOD 32;\n        for s = 0 to selem-1\n            rval = V[tt];\n            if memop == MemOp_LOAD then\n                Elem[rval, e, esize] = Mem[address + offs, ebytes, AccType_VEC];\n                V[tt] = rval;\n            else \n                Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, e, esize];\n            endif\n            offs = offs + ebytes;\n            tt = (tt + 1) MOD 32;\n        endfor\n    endfor\nendfor\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UNKNOWN;\nboolean wback = FALSE;\n", 
        "encodings": [
          {
            "condition": "opcode_ == 001", 
            "format": "ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 011 && size == x0", 
            "format": "ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && size == 00", 
            "format": "ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>]"
          }, 
          {
            "condition": "opcode_ == 101 && S == 0 && size == 01", 
            "format": "ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>]"
          }
        ], 
        "pattern": "Q#1 0 opcode_#3 00110100100000 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opcode_", 
            "==", 
            "xx1"
          ]
        ], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nboolean wback = TRUE;\n", 
        "encodings": [
          {
            "condition": "Rm == 11111 && opcode_ == 001", 
            "format": "ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], #4"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 001", 
            "format": "ST4 { <Vt>.B, <Vt2>.B, <Vt3>.B, <Vt4>.B }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 011 && size == x0", 
            "format": "ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], #8"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 011 && size == x0", 
            "format": "ST4 { <Vt>.H, <Vt2>.H, <Vt3>.H, <Vt4>.H }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && size == 00", 
            "format": "ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], #16"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && size == 00", 
            "format": "ST4 { <Vt>.S, <Vt2>.S, <Vt3>.S, <Vt4>.S }[<index>], [<Xn|SP>], <Xm>"
          }, 
          {
            "condition": "Rm == 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], #32"
          }, 
          {
            "condition": "Rm != 11111 && opcode_ == 101 && S == 0 && size == 01", 
            "format": "ST4 { <Vt>.D, <Vt2>.D, <Vt3>.D, <Vt4>.D }[<index>], [<Xn|SP>], <Xm>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001101101 opcode_#3 S#1 size#2 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer scale = UInt(opcode<2:1>);\ninteger selem = UInt(opcode<0>:R) + 1;\nboolean replicate = FALSE;\ninteger index;\ncase scale of\n    when 3\n        if L == '0' || S == '1' then UnallocatedEncoding();\n        scale = UInt(size);\n        replicate = TRUE;\n    when 0\n        index = UInt(Q:S:size);         \n    when 1\n        if size<0> == '1' then UnallocatedEncoding();\n        index = UInt(Q:S:size<1>);      \n    when 2\n        if size<1> == '1' then UnallocatedEncoding();\n        if size<0> == '0' then\n            index = UInt(Q:S);          \n        else\n            if S == '1' then UnallocatedEncoding();\n            index = UInt(Q);            \n            scale = 3;\n        endif\nendcase\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger esize = 8 << scale;\n", 
    "description": "Store single 4-element structure from one lane of four registers", 
    "name": "ST4 (single structure)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(64) offs;\nbits(128) rval;\nbits(esize) element;\ninteger s;\nconstant integer ebytes = esize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\noffs = Zeros();\nif replicate then\n    for s = 0 to selem-1\n        element = Mem[address + offs, ebytes, AccType_VEC];\n        V[t] = Replicate(element, datasize DIV esize);\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\nelse\n    endfor\n    for s = 0 to selem-1\n        rval = V[t];\n        if memop == MemOp_LOAD then\n            Elem[rval, index, esize] = Mem[address + offs, ebytes, AccType_VEC];\n            V[t] = rval;\n        else \n            Mem[address + offs, ebytes, AccType_VEC] = Elem[rval, index, esize];\n        endif\n        offs = offs + ebytes;\n        t = (t + 1) MOD 32;\n    endfor\nendif\nif wback then\n    if m != 31 then\n        offs = X[m];\n    endif\n    if n == 31 then\n        SP[] = address + offs;\n    else\n        X[n] = address + offs;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STADD <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STADDL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STADD <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STADDL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 000000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic add on word or doubleword in memory, without return", 
    "name": "STADD, STADDL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STADDB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STADDLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 000000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic add on byte in memory, without return", 
    "name": "STADDB, STADDLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STADDH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STADDLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 000000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic add on halfword in memory, without return", 
    "name": "STADDH, STADDLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STCLR <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STCLRL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STCLR <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STCLRL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 000100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit clear on word or doubleword in memory, without return", 
    "name": "STCLR, STCLRL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STCLRB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STCLRLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 000100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit clear on byte in memory, without return", 
    "name": "STCLRB, STCLRLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STCLRH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STCLRLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 000100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit clear on halfword in memory, without return", 
    "name": "STCLRH, STCLRLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STEOR <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STEORL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STEOR <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STEORL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 001000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic exclusive OR on word or doubleword in memory, without return", 
    "name": "STEOR, STEORL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STEORB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STEORLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 001000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic exclusive OR on byte in memory, without return", 
    "name": "STEORB, STEORLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STEORH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STEORLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 001000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic exclusive OR on halfword in memory, without return", 
    "name": "STEORH, STEORLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STLLR <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STLLR <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 00100010011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store LORelease Register", 
    "name": "STLLR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STLLRB <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0000100010011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store LORelease Register Byte", 
    "name": "STLLRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STLLRH <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0100100010011111011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store LORelease Register Halfword", 
    "name": "STLLRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STLR <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STLR <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rn#5 00100010011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Register", 
    "name": "STLR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STLRB <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0000100010011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Register Byte", 
    "name": "STLRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '0' then AccType_LIMITEDORDERED else AccType_ORDERED;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STLRH <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rn#5 0100100010011111111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Register Halfword", 
    "name": "STLRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        data = X[t];\n        Mem[address, dbytes, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, dbytes, acctype];\n        X[t] = ZeroExtend(data, regsize);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "sz == 0", 
            "format": "STLXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1", 
            "format": "STLXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "sz#1 1 Rs#5 001000001 Rt2#5 1 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Exclusive Pair of registers", 
    "name": "STLXP", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STLXR <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STLXR <Ws>, <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rs#5 001000000 Rn#5 111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Exclusive Register", 
    "name": "STLXR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STLXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rs#5 00001000000 Rn#5 111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Exclusive Register Byte", 
    "name": "STLXRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STLXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rs#5 01001000000 Rn#5 111111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store-Release Exclusive Register Halfword", 
    "name": "STLXRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STNP <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 01", 
            "format": "STNP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STNP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110000 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VECSTREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Store Pair of SIMD&FP registers, with Non-temporal hint", 
    "name": "STNP (SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        V[t]  = data1;\n        V[t2] = data2;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STNP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STNP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100000 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_STREAM;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc<0> == '1' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Store Pair of Registers, with non-temporal hint", 
    "name": "STNP", 
    "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        endif\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        endif\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        X[t]  = data1;\n        X[t2] = data2;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = TRUE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STP <St1>, <St2>, [<Xn|SP>], #<imm>"
          }, 
          {
            "condition": "opc == 01", 
            "format": "STP <Dt1>, <Dt2>, [<Xn|SP>], #<imm>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110010 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STP <St1>, <St2>, [<Xn|SP>, #<imm>]!"
          }, 
          {
            "condition": "opc == 01", 
            "format": "STP <Dt1>, <Dt2>, [<Xn|SP>, #<imm>]!"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STP <Qt1>, <Qt2>, [<Xn|SP>, #<imm>]!"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110110 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STP <St1>, <St2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 01", 
            "format": "STP <Dt1>, <Dt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STP <Qt1>, <Qt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10110100 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_VEC;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif opc == '11' then UnallocatedEncoding();\ninteger scale = 2 + UInt(opc);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Store Pair of SIMD&FP registers", 
    "name": "STP (SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data1 = V[t];\n        data2 = V[t2];\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        V[t]  = data1;\n        V[t2] = data2;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = TRUE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STP <Wt1>, <Wt2>, [<Xn|SP>], #<imm>"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STP <Xt1>, <Xt2>, [<Xn|SP>], #<imm>"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100010 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = TRUE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STP <Wt1>, <Wt2>, [<Xn|SP>, #<imm>]!"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STP <Xt1>, <Xt2>, [<Xn|SP>, #<imm>]!"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100110 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback  = FALSE;\nboolean postindex = FALSE;\n", 
        "encodings": [
          {
            "condition": "opc == 00", 
            "format": "STP <Wt1>, <Wt2>, [<Xn|SP>{, #<imm>}]"
          }, 
          {
            "condition": "opc == 10", 
            "format": "STP <Xt1>, <Xt2>, [<Xn|SP>{, #<imm>}]"
          }
        ], 
        "pattern": "opc#2 imm7#7 10100100 Rt2#5 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2);\nAccType acctype = AccType_NORMAL;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\nif L:opc<0> == '01' || opc == '11' then UnallocatedEncoding();\nboolean signed = (opc<0> != '0');\ninteger scale = 2 + UInt(opc<1>);\ninteger datasize = 8 << scale;\nbits(64) offset = LSL(SignExtend(imm7, 64), scale);\n", 
    "description": "Store Pair of Registers", 
    "name": "STP", 
    "operation": "bits(64) address;\nbits(datasize) data1;\nbits(datasize) data2;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean wb_unknown = FALSE;\nif memop == MemOp_LOAD && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;        \n        when Constraint_UNKNOWN    wb_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && (t == n || t2 == n) && n != 31 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;   \n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_LOAD && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown && t == n then\n            data1 = bits(datasize) UNKNOWN;\n        else\n            data1 = X[t];\n        endif\n        if rt_unknown && t2 == n then\n            data2 = bits(datasize) UNKNOWN;\n        else\n            data2 = X[t2];\n        endif\n        Mem[address + 0     , dbytes, acctype] = data1;\n        Mem[address + dbytes, dbytes, acctype] = data2;\n    when MemOp_LOAD\n        data1 = Mem[address + 0     , dbytes, acctype];\n        data2 = Mem[address + dbytes, dbytes, acctype];\n        if rt_unknown then\n            data1 = bits(datasize) UNKNOWN;\n            data2 = bits(datasize) UNKNOWN;\n        endif\n        if signed then\n            X[t]  = SignExtend(data1, 64);\n            X[t2] = SignExtend(data2, 64);\n        else\n            X[t]  = data1;\n            X[t2] = data2;\n        endif\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 00", 
            "format": "STR <Bt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 01 && opc == 00", 
            "format": "STR <Ht>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 10 && opc == 00", 
            "format": "STR <St>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 11 && opc == 00", 
            "format": "STR <Dt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 00 && opc == 10", 
            "format": "STR <Qt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "size#2 opc#2 111100 imm9#9 0 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 00", 
            "format": "STR <Bt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 01 && opc == 00", 
            "format": "STR <Ht>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 10 && opc == 00", 
            "format": "STR <St>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 11 && opc == 00", 
            "format": "STR <Dt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 00 && opc == 10", 
            "format": "STR <Qt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "size#2 opc#2 111100 imm9#9 0 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 00", 
            "format": "STR <Bt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 01 && opc == 00", 
            "format": "STR <Ht>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 10 && opc == 00", 
            "format": "STR <St>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 11 && opc == 00", 
            "format": "STR <Dt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 00 && opc == 10", 
            "format": "STR <Qt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "size#2 opc#2 111101 imm12#12 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\n", 
    "description": "Store SIMD&FP register (immediate offset)", 
    "name": "STR (immediate, SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STR <Wt>, [<Xn|SP>], #<simm>"
          }, 
          {
            "condition": "size == 11", 
            "format": "STR <Xt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "size#2 imm9#9 111000000 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STR <Wt>, [<Xn|SP>, #<simm>]!"
          }, 
          {
            "condition": "size == 11", 
            "format": "STR <Xt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "size#2 imm9#9 111000000 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STR <Wt>, [<Xn|SP>{, #<pimm>}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STR <Xt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "size#2 imm12#12 11100100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register (immediate)", 
    "name": "STR (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 00 && option != 011", 
            "format": "STR <Bt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
          }, 
          {
            "condition": "size == 00 && opc == 00 && option == 011", 
            "format": "STR <Bt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          }, 
          {
            "condition": "size == 01 && opc == 00", 
            "format": "STR <Ht>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 10 && opc == 00", 
            "format": "STR <St>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 11 && opc == 00", 
            "format": "STR <Dt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 00 && opc == 10", 
            "format": "STR <Qt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "size#2 opc#2 111100 Rm#5 1 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\n", 
    "description": "Store SIMD&FP register (register offset)", 
    "name": "STR (register, SIMD&FP)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nCheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STR <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STR <Xt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "size#2 Rm#5 111000001 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register (register)", 
    "name": "STR (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRB <Wt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "imm9#9 00111000000 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRB <Wt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "imm9#9 00111000000 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRB <Wt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "imm12#12 0011100100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Byte (immediate)", 
    "name": "STRB (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "option != 011", 
            "format": "STRB <Wt>, [<Xn|SP>, (<Wm>|<Xm>), <extend> {<amount>}]"
          }, 
          {
            "condition": "option == 011", 
            "format": "STRB <Wt>, [<Xn|SP>, <Xm>{, LSL <amount>}]"
          }
        ], 
        "pattern": "Rm#5 00111000001 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Byte (register)", 
    "name": "STRB (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = TRUE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRH <Wt>, [<Xn|SP>], #<simm>"
          }
        ], 
        "pattern": "imm9#9 01111000000 Rn#5 01 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = TRUE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRH <Wt>, [<Xn|SP>, #<simm>]!"
          }
        ], 
        "pattern": "imm9#9 01111000000 Rn#5 11 Rt#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = LSL(ZeroExtend(imm12, 64), scale);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRH <Wt>, [<Xn|SP>{, #<pimm>}]"
          }
        ], 
        "pattern": "imm12#12 0111100100 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Halfword (immediate)", 
    "name": "STRH (immediate)", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nif option<1> == '0' then UnallocatedEncoding(); \nExtendType extend_type = DecodeRegExtend(option);\ninteger shift = if S == '1' then scale else 0;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STRH <Wt>, [<Xn|SP>, (<Wm>|<Xm>){, <extend> {<amount>}}]"
          }
        ], 
        "pattern": "Rm#5 01111000001 option#3 S#1 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger m = UInt(Rm);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Halfword (register)", 
    "name": "STRH (register)", 
    "operation": "bits(64) offset = ExtendReg(m, extend_type, shift);\nbits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STSET <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STSETL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STSET <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STSETL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 001100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit set on word or doubleword in memory, without return", 
    "name": "STSET, STSETL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STSETB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STSETLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 001100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit set on byte in memory, without return", 
    "name": "STSETB, STSETLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STSETH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STSETLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 001100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic bit set on halfword in memory, without return", 
    "name": "STSETH, STSETLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STSMAX <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STSMAXL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STSMAX <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STSMAXL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 010000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed maximum on word or doubleword in memory, without return", 
    "name": "STSMAX, STSMAXL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STSMAXB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STSMAXLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 010000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed maximum on byte in memory, without return", 
    "name": "STSMAXB, STSMAXLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STSMAXH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STSMAXLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 010000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed maximum on halfword in memory, without return", 
    "name": "STSMAXH, STSMAXLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STSMIN <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STSMINL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STSMIN <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STSMINL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 010100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed minimum on word or doubleword in memory, without return", 
    "name": "STSMIN, STSMINL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STSMINB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STSMINLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 010100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed minimum on byte in memory, without return", 
    "name": "STSMINB, STSMINLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STSMINH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STSMINLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 010100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic signed minimum on halfword in memory, without return", 
    "name": "STSMINH, STSMINLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STTR <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STTR <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "size#2 imm9#9 111000000 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register (unprivileged)", 
    "name": "STTR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STTRB <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 00111000000 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Byte (unprivileged)", 
    "name": "STTRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STTRH <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 01111000000 Rn#5 10 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_UNPRIV;\nif (HaveNVExt() && HaveEL(EL2) && HCR_EL2.NV == 1 && HCR_EL2.NV1 == 1) then\n    acctype = AccType_NORMAL;\nendif\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Halfword (unprivileged)", 
    "name": "STTRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STUMAX <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STUMAXL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STUMAX <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STUMAXL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 011000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned maximum on word or doubleword in memory, without return", 
    "name": "STUMAX, STUMAXL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STUMAXB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STUMAXLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 011000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned maximum on byte in memory, without return", 
    "name": "STUMAXB, STUMAXLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STUMAXH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STUMAXLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 011000 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned maximum on halfword in memory, without return", 
    "name": "STUMAXH, STUMAXLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "size == 10 && R == 0", 
            "format": "STUMIN <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && R == 1", 
            "format": "STUMINL <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 0", 
            "format": "STUMIN <Xs>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && R == 1", 
            "format": "STUMINL <Xs>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 R#1 1110000 Rs#5 1 Rn#5 011100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned minimum on word or doubleword in memory, without return", 
    "name": "STUMIN, STUMINL", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STUMINB <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STUMINLB <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 001110000 Rs#5 1 Rn#5 011100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned minimum on byte in memory, without return", 
    "name": "STUMINB, STUMINLB", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\nMemAtomicOp op;\ncase opc of\n    when '000' op = MemAtomicOp_ADD;\n    when '001' op = MemAtomicOp_BIC;\n    when '010' op = MemAtomicOp_EOR;\n    when '011' op = MemAtomicOp_ORR;\n    when '100' op = MemAtomicOp_SMAX;\n    when '101' op = MemAtomicOp_SMIN;\n    when '110' op = MemAtomicOp_UMAX;\n    when '111' op = MemAtomicOp_UMIN;\nendcase\n", 
        "encodings": [
          {
            "condition": "R == 0", 
            "format": "STUMINH <Ws>, [<Xn|SP>]"
          }, 
          {
            "condition": "R == 1", 
            "format": "STUMINLH <Ws>, [<Xn|SP>]"
          }
        ], 
        "pattern": "R#1 011110000 Rs#5 1 Rn#5 011100 11111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Atomic unsigned minimum on halfword in memory, without return", 
    "name": "STUMINH, STUMINLH", 
    "operation": "bits(64) address;\nbits(datasize) value;\nbits(datasize) data;\nbits(datasize) result;\nvalue = X[s];\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\ncase op of\n    when MemAtomicOp_ADD   result = data + value;\n    when MemAtomicOp_BIC   result = data AND NOT(value);\n    when MemAtomicOp_EOR   result = data EOR value;\n    when MemAtomicOp_ORR   result = data OR value;\n    when MemAtomicOp_SMAX  result = if SInt(data) > SInt(value) then data else value;\n    when MemAtomicOp_SMIN  result = if SInt(data) > SInt(value) then value else data;\n    when MemAtomicOp_UMAX  result = if UInt(data) > UInt(value) then data else value;\n    when MemAtomicOp_UMIN  result = if UInt(data) > UInt(value) then value else data;\nendcase\nMem[address, datasize DIV 8, stacctype] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "opc", 
            "==", 
            "x0"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(opc<1>:size);\nif scale > 4 then UnallocatedEncoding();\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 00 && opc == 00", 
            "format": "STUR <Bt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 01 && opc == 00", 
            "format": "STUR <Ht>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 10 && opc == 00", 
            "format": "STUR <St>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 11 && opc == 00", 
            "format": "STUR <Dt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 00 && opc == 10", 
            "format": "STUR <Qt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "size#2 opc#2 111100 imm9#9 0 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_VEC;\nMemOp memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\ninteger datasize = 8 << scale;\n", 
    "description": "Store SIMD&FP register (unscaled offset)", 
    "name": "STUR (SIMD&FP)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        data = V[t];\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        V[t] = data;\nendcase\nif wback then\n    if postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STUR <Wt>, [<Xn|SP>{, #<simm>}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STUR <Xt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "size#2 imm9#9 111000000 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register (unscaled)", 
    "name": "STUR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STURB <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 00111000000 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Byte (unscaled)", 
    "name": "STURB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean wback = FALSE;\nboolean postindex = FALSE;\ninteger scale = UInt(size);\nbits(64) offset = SignExtend(imm9, 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STURH <Wt>, [<Xn|SP>{, #<simm>}]"
          }
        ], 
        "pattern": "imm9#9 01111000000 Rn#5 00 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\nAccType acctype = AccType_NORMAL;\nMemOp memop;\nboolean signed;\ninteger regsize;\nif opc<1> == '0' then\n    memop = if opc<0> == '1' then MemOp_LOAD else MemOp_STORE;\n    regsize = if size == '11' then 64 else 32;\n    signed = FALSE;\nelse\n    if size == '11' then\n        memop = MemOp_PREFETCH;\n        if opc<0> == '1' then UnallocatedEncoding();\n    else\n        memop = MemOp_LOAD;\n        if size == '10' && opc<0> == '1' then UnallocatedEncoding();\n        regsize = if opc<0> == '1' then 32 else 64;\n        signed = TRUE;\n    endif\nendif\ninteger datasize = 8 << scale;\n", 
    "description": "Store Register Halfword (unscaled)", 
    "name": "STURH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nboolean wb_unknown = FALSE;\nboolean rt_unknown = FALSE;\nif memop == MemOp_LOAD && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);\n    assert c IN {Constraint_WBSUPPRESS, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_WBSUPPRESS wback = FALSE;       \n        when Constraint_UNKNOWN    wb_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE && wback && n == t && n != 31 then\n    c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);\n    assert c IN {Constraint_NONE, Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_NONE       rt_unknown = FALSE;  \n        when Constraint_UNKNOWN    rt_unknown = TRUE;   \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif n == 31 then\n    if memop != MemOp_PREFETCH then CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\nif ! postindex then\n    address = address + offset;\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        else\n            data = X[t];\n        endif\n        Mem[address, datasize DIV 8, acctype] = data;\n    when MemOp_LOAD\n        data = Mem[address, datasize DIV 8, acctype];\n        if signed then\n            X[t] = SignExtend(data, regsize);\n        else\n            X[t] = ZeroExtend(data, regsize);\n        endif\n    when MemOp_PREFETCH\n        Prefetch(address, t<4:0>);\nendcase\nif wback then\n    if wb_unknown then\n        address = bits(64) UNKNOWN;\n    elsif postindex then\n        address = address + offset;\n    endif\n    if n == 31 then\n        SP[] = address;\n    else\n        X[n] = address;\n    endif\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = TRUE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 32 << UInt(sz);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "sz == 0", 
            "format": "STXP <Ws>, <Wt1>, <Wt2>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "sz == 1", 
            "format": "STXP <Ws>, <Xt1>, <Xt2>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "sz#1 1 Rs#5 001000001 Rt2#5 0 Rn#5 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store Exclusive Pair of registers", 
    "name": "STXP", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "size == 10", 
            "format": "STXR <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }, 
          {
            "condition": "size == 11", 
            "format": "STXR <Ws>, <Xt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "size#2 Rs#5 001000000 Rn#5 011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store Exclusive Register", 
    "name": "STXR", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STXRB <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rs#5 00001000000 Rn#5 011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store Exclusive Register Byte", 
    "name": "STXRB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer n = UInt(Rn);\ninteger t = UInt(Rt);\ninteger t2 = UInt(Rt2); \ninteger s = UInt(Rs);   \nAccType acctype = if o0 == '1' then AccType_ORDERED else AccType_ATOMIC;\nboolean pair = FALSE;\nMemOp memop = if L == '1' then MemOp_LOAD else MemOp_STORE;\ninteger elsize = 8 << UInt(size);\ninteger regsize = if elsize == 64 then 64 else 32;\ninteger datasize = if pair then elsize * 2 else elsize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "STXRH <Ws>, <Wt>, [<Xn|SP>{,#0}]"
          }
        ], 
        "pattern": "Rs#5 01001000000 Rn#5 011111 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Store Exclusive Register Halfword", 
    "name": "STXRH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nconstant integer dbytes = datasize DIV 8;\nboolean rt_unknown = FALSE;\nboolean rn_unknown = FALSE;\nif memop == MemOp_LOAD && pair && t == t2 then\n    Constraint c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);\n    assert c IN {Constraint_UNKNOWN, Constraint_UNDEF, Constraint_NOP};\n    case c of\n        when Constraint_UNKNOWN    rt_unknown = TRUE;    \n        when Constraint_UNDEF      UnallocatedEncoding();\n        when Constraint_NOP        EndOfInstruction();\n    endcase\nendif\nif memop == MemOp_STORE then\n    if s == t || (pair && s == t2) then\n        Constraint c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rt_unknown = TRUE;    \n            when Constraint_NONE       rt_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\n    if s == n && n != 31 then\n        Constraint c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);\n        assert c IN {Constraint_UNKNOWN, Constraint_NONE, Constraint_UNDEF, Constraint_NOP};\n        case c of\n            when Constraint_UNKNOWN    rn_unknown = TRUE;    \n            when Constraint_NONE       rn_unknown = FALSE;   \n            when Constraint_UNDEF      UnallocatedEncoding();\n            when Constraint_NOP        EndOfInstruction();\n        endcase\n    endif\nendif\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelsif rn_unknown then\n    address = bits(64) UNKNOWN;\nelse\n    address = X[n];\nendif\ncase memop of\n    when MemOp_STORE\n        if rt_unknown then\n            data = bits(datasize) UNKNOWN;\n        elsif pair then\n            bits(datasize DIV 2) el1 = X[t];\n            bits(datasize DIV 2) el2 = X[t2];\n            data = if BigEndian() then el1 : el2 else el2 : el1;\n        else\n            data = X[t];\n        endif\n        bit status = '1';\n        if AArch64.ExclusiveMonitorsPass(address, dbytes) then\n            Mem[address, dbytes, acctype] = data;\n            status = ExclusiveMonitorsStatus();\n        endif\n        X[s] = ZeroExtend(status, 32);\n    when MemOp_LOAD\n        AArch64.SetExclusiveMonitors(address, dbytes);\n        if pair then\n            if rt_unknown then\n                X[t]  = bits(datasize) UNKNOWN;\n            elsif elsize == 32 then\n                data = Mem[address, dbytes, acctype];\n                if BigEndian() then\n                    X[t]  = data<datasize-1:elsize>;\n                    X[t2] = data<elsize-1:0>;\n                else\n                    X[t]  = data<elsize-1:0>;\n                    X[t2] = data<datasize-1:elsize>;\n            else \n                endif\n                if address != Align(address, dbytes) then\n                    iswrite = FALSE;\n                    secondstage = FALSE;\n                    AArch64.Abort(address, AArch64.AlignmentFault(acctype, iswrite, secondstage));\n                endif\n                X[t]  = Mem[address + 0, 8, acctype];\n                X[t2] = Mem[address + 8, 8, acctype];\n        else\n            endif\n            data = Mem[address, dbytes, acctype];\n            X[t] = ZeroExtend(data, regsize);\n        endif\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SUB <Wd|WSP>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SUB <Xd|SP>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          }
        ], 
        "pattern": "sf#1 Rm#5 1001011001 option#3 imm3#3 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (extended register)", 
    "name": "SUB (extended register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SUB <Wd|WSP>, <Wn|WSP>, #<imm>{, <shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SUB <Xd|SP>, <Xn|SP>, #<imm>{, <shift>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1010001 imm12#12 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (immediate)", 
    "name": "SUB (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SUB <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SUB <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1001011 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (shifted register)", 
    "name": "SUB (shifted register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size != '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean sub_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SUB <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 100001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean sub_op = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 100001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (vector)", 
    "name": "SUB (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(esize) element1;\nbits(esize) element2;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, esize];\n    element2 = Elem[operand2, e, esize];\n    if sub_op then\n        Elem[result, e, esize] = element1 - element2;\n    else\n        Elem[result, e, esize] = element1 + element2;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean round = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SUBHN{2} <Vd>.<Tb>, <Vn>.<Ta>, <Vm>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 1 Rn#5 011000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract returning High Narrow", 
    "name": "SUBHN, SUBHN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(2*datasize) operand2 = V[m];\nbits(datasize)   result;\ninteger round_const = if round then 1 << (esize - 1) else 0;\nbits(2*esize) element1;\nbits(2*esize) element2;\nbits(2*esize) sum;\nfor e = 0 to elements-1\n    element1 = Elem[operand1, e, 2*esize];\n    element2 = Elem[operand2, e, 2*esize];\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    sum = sum + round_const;\n    Elem[result, e, esize] = sum<2*esize-1:esize>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nExtendType extend_type = DecodeRegExtend(option);       \ninteger shift = UInt(imm3);\nif shift > 4 then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SUBS <Wd>, <Wn|WSP>, <Wm>{, <extend> {#<amount>}}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SUBS <Xd>, <Xn|SP>, <R><m>{, <extend> {#<amount>}}"
          }
        ], 
        "pattern": "sf#1 Rm#5 1101011001 option#3 imm3#3 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (extended register), setting flags", 
    "name": "SUBS (extended register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = ExtendReg(m, extend_type, shift);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nbits(datasize) imm;\ncase shift of\n    when '00' imm = ZeroExtend(imm12, datasize);\n    when '01' imm = ZeroExtend(imm12 : Zeros(12), datasize);\n    when '1x' ReservedValue();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SUBS <Wd>, <Wn|WSP>, #<imm>{, <shift>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SUBS <Xd>, <Xn|SP>, #<imm>{, <shift>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1110001 imm12#12 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (immediate), setting flags", 
    "name": "SUBS (immediate)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = if n == 31 then SP[] else X[n];\nbits(datasize) operand2 = imm;\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nif d == 31 && !setflags then\n    SP[] = result;\nelse\n    X[d] = result;\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean sub_op = (op == '1');\nboolean setflags = (S == '1');\nif shift == '11' then ReservedValue();\nif sf == '0' && imm6<5> == '1' then ReservedValue();\nShiftType shift_type = DecodeShift(shift);\ninteger shift_amount = UInt(imm6);\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "SUBS <Wd>, <Wn>, <Wm>{, <shift> #<amount>}"
          }, 
          {
            "condition": "sf == 1", 
            "format": "SUBS <Xd>, <Xn>, <Xm>{, <shift> #<amount>}"
          }
        ], 
        "pattern": "sf#1 shift#2 1101011 Rm#5 0 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Subtract (shifted register), setting flags", 
    "name": "SUBS (shifted register)", 
    "operation": "bits(datasize) result;\nbits(datasize) operand1 = X[n];\nbits(datasize) operand2 = ShiftReg(m, shift_type, shift_amount);\nbits(4) nzcv;\nbit carry_in;\nif sub_op then\n    operand2 = NOT(operand2);\n    carry_in = '1';\nelse\n    carry_in = '0';\nendif\n(result, nzcv) = AddWithCarry(operand1, operand2, carry_in);\nif setflags then \n    PSTATE.<N,Z,C,V> = nzcv;\nendif\nX[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SUQADD <V><d>, <V><n>"
          }
        ], 
        "pattern": "size#2 01011110 Rn#5 100000001110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SUQADD <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100000001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Signed saturating Accumulate of Unsigned value", 
    "name": "SUQADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "bits(16) imm = imm16;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SVC #<imm>"
          }
        ], 
        "pattern": "imm16#16 11010100000 00001", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Supervisor Call", 
    "name": "SVC", 
    "operation": "AArch64.CallSupervisor(imm);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "size", 
            "==", 
            "1x"
          ]
        ], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "size == 10 && A == 1 && R == 0", 
            "format": "SWPA <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 1 && R == 1", 
            "format": "SWPAL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 0", 
            "format": "SWP <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 10 && A == 0 && R == 1", 
            "format": "SWPL <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 0", 
            "format": "SWPA <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 1 && R == 1", 
            "format": "SWPAL <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 0", 
            "format": "SWP <Xs>, <Xt>, [<Xn|SP>]"
          }, 
          {
            "condition": "size == 11 && A == 0 && R == 1", 
            "format": "SWPL <Xs>, <Xt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "size#2 A#1 111000 R#1 Rs#5 1 Rn#5 100000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Swap word or doubleword in memory", 
    "name": "SWP, SWPA, SWPAL, SWPL", 
    "operation": "bits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\nMem[address, datasize DIV 8, stacctype] = X[s];\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "SWPAB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "SWPALB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0", 
            "format": "SWPB <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1", 
            "format": "SWPLB <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 00111000 R#1 Rs#5 1 Rn#5 100000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Swap byte in memory", 
    "name": "SWPB, SWPAB, SWPALB, SWPLB", 
    "operation": "bits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\nMem[address, datasize DIV 8, stacctype] = X[s];\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveAtomicExt() then UnallocatedEncoding();\ninteger t = UInt(Rt);\ninteger n = UInt(Rn);\ninteger s = UInt(Rs);\ninteger datasize = 8 << UInt(size);\ninteger regsize = if datasize == 64 then 64 else 32;\nAccType ldacctype = if A == '1' && Rt != '11111' then AccType_ORDEREDRW else AccType_ATOMICRW;\nAccType stacctype = if R == '1' then AccType_ORDEREDRW else AccType_ATOMICRW;\n", 
        "encodings": [
          {
            "condition": "A == 1 && R == 0", 
            "format": "SWPAH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 1 && R == 1", 
            "format": "SWPALH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 0", 
            "format": "SWPH <Ws>, <Wt>, [<Xn|SP>]"
          }, 
          {
            "condition": "A == 0 && R == 1", 
            "format": "SWPLH <Ws>, <Wt>, [<Xn|SP>]"
          }
        ], 
        "pattern": "A#1 01111000 R#1 Rs#5 1 Rn#5 100000 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Swap halfword in memory", 
    "name": "SWPH, SWPAH, SWPALH, SWPLH", 
    "operation": "bits(64) address;\nbits(datasize) data;\nif n == 31 then\n    CheckSPAlignment();\n    address = SP[];\nelse\n    address = X[n];\nendif\ndata =  Mem[address, datasize DIV 8, ldacctype];\nMem[address, datasize DIV 8, stacctype] = X[s];\nX[t] = ZeroExtend(data, regsize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\ninteger t = UInt(Rt);\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SYS #<op1>, <Cn>, <Cm>, #<op2>{, <Xt>}"
          }
        ], 
        "pattern": "op1#3 1101010100001 CRn#4 CRm#4 op2#3 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "System instruction", 
    "name": "SYS", 
    "operation": "if has_result then\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "AArch64.CheckSystemAccess('01', op1, CRn, CRm, op2, Rt, L);\ninteger t = UInt(Rt);\ninteger sys_op0 = 1;\ninteger sys_op1 = UInt(op1);\ninteger sys_op2 = UInt(op2);\ninteger sys_crn = UInt(CRn);\ninteger sys_crm = UInt(CRm);\nboolean has_result = (L == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "SYSL <Xt>, #<op1>, <Cn>, <Cm>, #<op2>"
          }
        ], 
        "pattern": "op1#3 1101010100101 CRn#4 CRm#4 op2#3 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "System instruction with result", 
    "name": "SYSL", 
    "operation": "if has_result then\n    X[t] = AArch64.SysInstrWithResult(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2);\nelse\n    AArch64.SysInstr(sys_op0, sys_op1, sys_crn, sys_crm, sys_op2, X[t]);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');\n", 
        "encodings": [
          {
            "condition": "len == 01", 
            "format": "TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>"
          }, 
          {
            "condition": "len == 10", 
            "format": "TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>"
          }, 
          {
            "condition": "len == 11", 
            "format": "TBL <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>"
          }, 
          {
            "condition": "len == 00", 
            "format": "TBL <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110000 len#2 0 Rn#5 000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Table vector Lookup", 
    "name": "TBL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\ninteger i;\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\nendfor\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "TBNZ <R><t>, #<imm>, <label>"
          }
        ], 
        "pattern": "b5#1 b40#5 0110111 imm14#14 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Test bit and Branch if Nonzero", 
    "name": "TBNZ", 
    "operation": "bits(datasize) operand = X[t];\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_JMP);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV 8;\ninteger regs = UInt(len) + 1;\nboolean is_tbl = (op == '0');\n", 
        "encodings": [
          {
            "condition": "len == 01", 
            "format": "TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B }, <Vm>.<Ta>"
          }, 
          {
            "condition": "len == 10", 
            "format": "TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B }, <Vm>.<Ta>"
          }, 
          {
            "condition": "len == 11", 
            "format": "TBX <Vd>.<Ta>, { <Vn>.16B, <Vn+1>.16B, <Vn+2>.16B, <Vn+3>.16B }, <Vm>.<Ta>"
          }, 
          {
            "condition": "len == 00", 
            "format": "TBX <Vd>.<Ta>, { <Vn>.16B }, <Vm>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 Rm#5 001110000 len#2 0 Rn#5 100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Table vector lookup extension", 
    "name": "TBX", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) indices = V[m];\nbits(128*regs) table = Zeros();\nbits(datasize) result;\ninteger index;\ninteger i;\nfor i = 0 to regs - 1\n    table<128*i+127:128*i> = V[n];\n    n = (n + 1) MOD 32;\nendfor\nresult = if is_tbl then Zeros() else V[d];\nfor i = 0 to elements - 1\n    index = UInt(Elem[indices, i, 8]);\n    if index < 16 * regs then\n        Elem[result, i, 8] = Elem[table, index, 8];\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer t = UInt(Rt);\ninteger datasize = if b5 == '1' then 64 else 32;\ninteger bit_pos = UInt(b5:b40);\nbit bit_val = op;\nbits(64) offset = SignExtend(imm14:'00', 64);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "TBZ <R><t>, #<imm>, <label>"
          }
        ], 
        "pattern": "b5#1 b40#5 0110110 imm14#14 Rt#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Test bit and Branch if Zero", 
    "name": "TBZ", 
    "operation": "bits(datasize) operand = X[t];\nif operand<bit_pos> == bit_val then\n    BranchTo(PC[] + offset, BranchType_JMP);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "TRN1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Transpose vectors (primary)", 
    "name": "TRN1", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger p;\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "TRN2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Transpose vectors (secondary)", 
    "name": "TRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger p;\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, 2*p+part, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, 2*p+part, esize];\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UABA <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 011111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Absolute difference and Accumulate", 
    "name": "UABA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UABAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 010100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Absolute difference and Accumulate Long", 
    "name": "UABAL, UABAL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean accumulate = (ac == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UABD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 011101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Absolute Difference (vector)", 
    "name": "UABD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nbits(esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<esize-1:0>;\n    Elem[result, e, esize] = Elem[result, e, esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean accumulate = (op == '0');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UABDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 011100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Absolute Difference Long", 
    "name": "UABDL, UABDL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) absdiff;\nresult = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    absdiff = Abs(element1 - element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + absdiff;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UADALP <Vd>.<Ta>, <Vn>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000011010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Add and Accumulate Long Pairwise", 
    "name": "UADALP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UADDL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Add Long (vector)", 
    "name": "UADDL, UADDL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV (2*esize);\nboolean acc = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UADDLP <Vd>.<Ta>, <Vn>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Add Long Pairwise", 
    "name": "UADDLP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) sum;\ninteger op1;\ninteger op2;\nresult = if acc then V[d] else Zeros();\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, 2*e+0, esize], unsigned);\n    op2 = Int(Elem[operand, 2*e+1, esize], unsigned);\n    sum = (op1 + op2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = Elem[result, e, 2*esize] + sum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UADDLV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 110000001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned sum Long across Vector", 
    "name": "UADDLV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger sum;\nsum = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    sum = sum + Int(Elem[operand, e, esize], unsigned);\nendfor\nV[d] = sum<2*esize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UADDW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 000100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Add Wide", 
    "name": "UADDW, UADDW2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean inzero;\nboolean extend;\ninteger R;\ninteger S;\nbits(datasize) wmask;\nbits(datasize) tmask;\ncase opc of\n    when '00' inzero = TRUE;  extend = TRUE;    \n    when '01' inzero = FALSE; extend = FALSE;   \n    when '10' inzero = TRUE;  extend = FALSE;   \n    when '11' UnallocatedEncoding();\nendcase\nif sf == '1' && N != '1' then ReservedValue();\nif sf == '0' && (N != '0' || immr<5> != '0' || imms<5> != '0') then ReservedValue();\nR = UInt(immr);\nS = UInt(imms);\n(wmask, tmask) = DecodeBitMasks(N, imms, immr, FALSE);\n", 
        "encodings": [
          {
            "condition": "sf == 0 && N == 0", 
            "format": "UBFM <Wd>, <Wn>, #<immr>, #<imms>"
          }, 
          {
            "condition": "sf == 1 && N == 1", 
            "format": "UBFM <Xd>, <Xn>, #<immr>, #<imms>"
          }
        ], 
        "pattern": "sf#1 N#1 10100110 immr#6 imms#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Bitfield Move", 
    "name": "UBFM", 
    "operation": "bits(datasize) dst = if inzero then Zeros() else X[d];\nbits(datasize) src = X[n];\nbits(datasize) bot = (dst AND NOT(wmask)) OR (ROR(src, R) AND wmask);\nbits(datasize) top = if extend then Replicate(src<S>) else dst;\nX[d] = (top AND NOT(tmask)) OR (bot AND tmask);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = esize;\ninteger elements = 1;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UCVTF <V><d>, <V><n>, #<fbits>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 111001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh == '000x' || (immh == '001x' && !HaveFP16Ext()) then ReservedValue();\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = if immh == '1xxx' then 64 else if immh == '01xx' then 32 else 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger fracbits = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nFPRounding rounding = FPRoundingMode(FPCR);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UCVTF <Vd>.<T>, <Vn>.<T>, #<fbits>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 111001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned fixed-point Convert to Floating-point (vector)", 
    "name": "UCVTF (vector, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, fracbits, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UCVTF <Hd>, <Hn>"
          }
        ], 
        "pattern": "Rn#5 0111111001111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 32 << UInt(sz);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UCVTF <V><d>, <V><n>"
          }
        ], 
        "pattern": "sz#1 011111100 Rn#5 100001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "if !HaveFP16Ext() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 16;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UCVTF <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 Rn#5 10111001111001110110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz:Q == '10' then ReservedValue();\ninteger esize = 32 << UInt(sz);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UCVTF <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011100 Rn#5 100001110110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned integer Convert to Floating-point (vector)", 
    "name": "UCVTF (vector, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nFPRounding rounding = FPRoundingMode(FPCR);\nbits(esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, esize];\n    Elem[result, e, esize] = FixedToFP(element, 0, unsigned, FPCR, rounding);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ncase type of\n    when '00' fltsize = 32;\n    when '01' fltsize = 64;\n    when '10' UnallocatedEncoding();\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\nif sf == '0' && scale<5> == '0' then UnallocatedEncoding();\ninteger fracbits = 64 - UInt(scale);\ncase opcode<2:1>:rmode of\n    when '0011'        \n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    otherwise\n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "UCVTF <Hd>, <Wn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "UCVTF <Sd>, <Wn>, #<fbits>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "UCVTF <Dd>, <Wn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "UCVTF <Hd>, <Xn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "UCVTF <Sd>, <Xn>, #<fbits>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "UCVTF <Dd>, <Xn>, #<fbits>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 scale#6 000011 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned fixed-point Convert to Floating-point (scalar)", 
    "name": "UCVTF (scalar, fixed-point)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, fracbits, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, fracbits, unsigned, FPCR, rounding);\n        V[d] = fltval;\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger intsize = if sf == '1' then 64 else 32;\ninteger fltsize;\nFPConvOp op;\nFPRounding rounding;\nboolean unsigned;\ninteger part;\ncase type of\n    when '00'\n        fltsize = 32;\n    when '01'\n        fltsize = 64;\n    when '10'\n        if opcode<2:1>:rmode != '1101' then UnallocatedEncoding();\n        fltsize = 128;\n    when '11'\n        if HaveFP16Ext() then\n            fltsize = 16;\n        else\n            UnallocatedEncoding();\n        endif\nendcase\ncase opcode<2:1>:rmode of\n    when '00xx'        \n        rounding = FPDecodeRounding(rmode);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '0100'        \n        rounding = FPRoundingMode(FPCR);\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_ItoF;\n    when '1000'        \n        rounding = FPRounding_TIEAWAY;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI;\n    when '1100'        \n        if fltsize != 16 && fltsize != intsize then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 0;\n    when '1101'        \n        if intsize != 64 || fltsize != 128 then UnallocatedEncoding();\n        op = if opcode<0> == '1' then FPConvOp_MOV_ItoF else FPConvOp_MOV_FtoI;\n        part = 1;\n        fltsize = 64; \n    when '1111'       \n        if !HaveFJCVTZSExt() then UnallocatedEncoding();\n        rounding = FPRounding_ZERO;\n        unsigned = (opcode<0> == '1');\n        op = FPConvOp_CVT_FtoI_JS;\n    otherwise \n        UnallocatedEncoding();\nendcase\n", 
        "encodings": [
          {
            "condition": "sf == 0 && type == 11", 
            "format": "UCVTF <Hd>, <Wn>"
          }, 
          {
            "condition": "sf == 0 && type == 00", 
            "format": "UCVTF <Sd>, <Wn>"
          }, 
          {
            "condition": "sf == 0 && type == 01", 
            "format": "UCVTF <Dd>, <Wn>"
          }, 
          {
            "condition": "sf == 1 && type == 11", 
            "format": "UCVTF <Hd>, <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 00", 
            "format": "UCVTF <Sd>, <Xn>"
          }, 
          {
            "condition": "sf == 1 && type == 01", 
            "format": "UCVTF <Dd>, <Xn>"
          }
        ], 
        "pattern": "sf#1 type#2 0011110 Rn#5 100011000000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned integer Convert to Floating-point (scalar)", 
    "name": "UCVTF (scalar, integer)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(fltsize) fltval;\nbits(intsize) intval;\ncase op of\n    when FPConvOp_CVT_FtoI\n        fltval = V[n];\n        intval = FPToFixed(fltval, 0, unsigned, FPCR, rounding);\n        X[d] = intval;\n    when FPConvOp_CVT_ItoF\n        intval = X[n];\n        fltval = FixedToFP(intval, 0, unsigned, FPCR, rounding);\n        V[d] = fltval;\n    when FPConvOp_MOV_FtoI\n        fltval = Vpart[n,part];\n        intval = ZeroExtend(fltval, intsize);\n        X[d] = intval;\n    when FPConvOp_MOV_ItoF\n        intval = X[n];\n        fltval = intval<fltsize-1:0>;\n        Vpart[d,part] = fltval;\n    when FPConvOp_CVT_FtoI_JS\n        fltval = V[n];\n        intval = FPToFixedJS(fltval, FPCR, TRUE);\n        X[d] = ZeroExtend(intval<31:0>, 64);\nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger datasize = if sf == '1' then 64 else 32;\nboolean unsigned = (o1 == '0');\n", 
        "encodings": [
          {
            "condition": "sf == 0", 
            "format": "UDIV <Wd>, <Wn>, <Wm>"
          }, 
          {
            "condition": "sf == 1", 
            "format": "UDIV <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "sf#1 Rm#5 0011010110 Rn#5 000010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Divide", 
    "name": "UDIV", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\nif IsZero(operand2) then\n    result = 0;\nelse\n    result = RoundTowardsZero(Real(Int(operand1, unsigned)) / Real(Int(operand2, unsigned)));\nendif\nX[d] = result<datasize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveDOTPExt() then UNDEFINED;\nif size  != '10' then ReservedValue();\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(M:Rm);\ninteger index = UInt(H:L);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.4B[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 1110 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Dot Product unsigned arithmetic (vector, by element)", 
    "name": "UDOT (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(128) operand2 = V[m];\nbits(datasize) result = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3\n        if signed then  \n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * index + i, esize DIV 4]);\n        endif\n        res = res + element1 * element2; \n    endfor\n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveDOTPExt() then UNDEFINED;\nif size!= '10' then ReservedValue();\nboolean signed = (U=='0');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UDOT <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 0 Rn#5 100101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Dot Product unsigned arithmetic (vector)", 
    "name": "UDOT (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nresult = V[d];\nfor e = 0 to elements-1 \n    integer res = 0;\n    integer element1, element2;\n    for i = 0 to 3 \n        if signed then\n            element1 = SInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = SInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        else \n            element1 = UInt(Elem[operand1, 4 * e + i, esize DIV 4]); \n            element2 = UInt(Elem[operand2, 4 * e + i, esize DIV 4]);\n        endif\n        res = res + element1 * element2; \n    endfor\n    Elem[result, e, esize] = Elem[result, e, esize] + res;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 000001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Halving Add", 
    "name": "UHADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    Elem[result, e, esize] = sum<esize:1>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UHSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 001001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Halving Subtract", 
    "name": "UHSUB", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    Elem[result, e, esize] = diff<esize:1>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMADDL <Xd>, <Wn>, <Wm>, <Xa>"
          }
        ], 
        "pattern": "Rm#5 10011011101 Ra#5 0 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply-Add Long", 
    "name": "UMADDL", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\ninteger result;\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\nendif\nX[d] = result<63:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMAX <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 011001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Maximum (vector)", 
    "name": "UMAX", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMAXP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 101001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Maximum Pairwise", 
    "name": "UMAXP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean min = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMAXV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 110000101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Maximum across Vector", 
    "name": "UMAXV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\nendfor\nV[d] = maxmin<esize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMIN <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 011011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Minimum (vector)", 
    "name": "UMIN", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean minimum = (o1 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMINP <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 101011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Minimum Pairwise", 
    "name": "UMINP", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\nbits(2*datasize) concat = operand2:operand1;\ninteger element1;\ninteger element2;\ninteger maxmin;\nfor e = 0 to elements-1\n    element1 = Int(Elem[concat, 2*e, esize], unsigned);\n    element2 = Int(Elem[concat, (2*e)+1, esize], unsigned);\n    maxmin = if minimum then Min(element1, element2) else Max(element1, element2);\n    Elem[result, e, esize] = maxmin<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '100' then ReservedValue();\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean min = (op == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMINV <V><d>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 110001101010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Minimum across Vector", 
    "name": "UMINV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\ninteger maxmin;\ninteger element;\nmaxmin = Int(Elem[operand, 0, esize], unsigned);\nfor e = 1 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned);\n    maxmin = if min then Min(maxmin, element) else Max(maxmin, element);\nendfor\nV[d] = maxmin<esize-1:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 0010 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply-Add Long (vector, by element)", 
    "name": "UMLAL, UMLAL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMLAL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 100000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply-Add Long (vector)", 
    "name": "UMLAL, UMLAL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    endif\n    Elem[result, e, 2*esize] = accum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean sub_op = (o2 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 0110 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply-Subtract Long (vector, by element)", 
    "name": "UMLSL, UMLSL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] - product;\n    else\n        Elem[result, e, 2*esize] = Elem[operand3, e, 2*esize] + product;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMLSL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 101000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply-Subtract Long (vector)", 
    "name": "UMLSL, UMLSL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) operand3 = V[d];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nbits(2*esize) accum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    if sub_op then\n        accum = Elem[operand3, e, 2*esize] - product;\n    else\n        accum = Elem[operand3, e, 2*esize] + product;\n    endif\n    Elem[result, e, 2*esize] = accum;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger size;\ncase Q:imm5 of\n    when '0xxxx1' size = 0;     \n    when '0xxx10' size = 1;     \n    when '0xx100' size = 2;     \n    when '1x1000' size = 3;     \n    otherwise     UnallocatedEncoding();\nendcase\ninteger idxdsize = if imm5<4> == '1' then 128 else 64;\ninteger index = UInt(imm5<4:size+1>);\ninteger esize = 8 << size;\ninteger datasize = if Q == '1' then 64 else 32;\n", 
        "encodings": [
          {
            "condition": "Q == 0", 
            "format": "UMOV <Wd>, <Vn>.<Ts>[<index>]"
          }, 
          {
            "condition": "Q == 1 && imm5 == x1000", 
            "format": "UMOV <Xd>, <Vn>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 imm5#5 001110000 Rn#5 001111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Move vector element to general-purpose register", 
    "name": "UMOV", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(idxdsize) operand = V[n];\nX[d] = ZeroExtend(Elem[operand, index, esize], datasize);\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);\ninteger destsize = 64;\ninteger datasize = 32;\nboolean sub_op = (o0 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMSUBL <Xd>, <Wn>, <Wm>, <Xa>"
          }
        ], 
        "pattern": "Rm#5 10011011101 Ra#5 1 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply-Subtract Long", 
    "name": "UMSUBL", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\nbits(destsize) operand3 = X[a];\ninteger result;\nif sub_op then\n    result = Int(operand3, unsigned) - (Int(operand1, unsigned) * Int(operand2, unsigned));\nelse\n    result = Int(operand3, unsigned) + (Int(operand1, unsigned) * Int(operand2, unsigned));\nendif\nX[d] = result<63:0>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger a = UInt(Ra);           \ninteger destsize = 64;\ninteger datasize = destsize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMULH <Xd>, <Xn>, <Xm>"
          }
        ], 
        "pattern": "Rm#5 10011011110 Rn#5 011111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply High", 
    "name": "UMULH", 
    "operation": "bits(datasize) operand1 = X[n];\nbits(datasize) operand2 = X[m];\ninteger result;\nresult = Int(operand1, unsigned) * Int(operand2, unsigned);\nX[d] = result<127:64>;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer idxdsize = if H == '1' then 128 else 64; \ninteger index;\nbit Rmhi;\ncase size of\n    when '01' index = UInt(H:L:M); Rmhi = '0';\n    when '10' index = UInt(H:L);   Rmhi = M;\n    otherwise UnallocatedEncoding();\nendcase\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rmhi:Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Ts>[<index>]"
          }
        ], 
        "pattern": "Q#1 0 size#2 101111 L#1 M#1 Rm#4 H#1 1010 Rn#5 0 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply Long (vector, by element)", 
    "name": "UMULL, UMULL2 (by element)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(idxdsize)   operand2 = V[m];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nbits(2*esize) product;\nelement2 = Int(Elem[operand2, index, esize], unsigned);\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    product = (element1 * element2)<2*esize-1:0>;\n    Elem[result, e, 2*esize] = product;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UMULL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 110000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Multiply long (vector)", 
    "name": "UMULL, UMULL2 (vector)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, 2*esize] = (element1 * element2)<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQADD <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 000011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 000011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Add", 
    "name": "UQADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    sum = element1 + element2;\n    (Elem[result, e, esize], sat) = SatQ(sum, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQRSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 010111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQRSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 010111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Rounding Shift Left (register)", 
    "name": "UQRSHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQRSHRN <Vb><d>, <Va><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 100111 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQRSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 100111 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Rounded Shift Right Narrow (immediate)", 
    "name": "UQRSHRN, UQRSHRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = UInt(immh:immb) - esize;\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSHL <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 011101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\nboolean src_unsigned;\nboolean dst_unsigned;\ncase op:U of\n    when '00' UnallocatedEncoding();\n    when '01' src_unsigned = FALSE; dst_unsigned = TRUE;\n    when '10' src_unsigned = FALSE; dst_unsigned = FALSE;\n    when '11' src_unsigned = TRUE;  dst_unsigned = TRUE;\nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSHL <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 011101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Shift Left (immediate)", 
    "name": "UQSHL (immediate)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) result;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], src_unsigned) << shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, dst_unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 010011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 010011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Shift Left (register)", 
    "name": "UQSHL (register)", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then ReservedValue();\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = esize;\ninteger elements = 1;\ninteger part = 0;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSHRN <Vb><d>, <Va><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 100101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = (2 * esize) - UInt(immh:immb);\nboolean round = (op == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSHRN{2} <Vd>.<Tb>, <Vn>.<Ta>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 100101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Shift Right Narrow (immediate)", 
    "name": "UQSHRN, UQSHRN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize*2) operand = V[n];\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, 2*esize], unsigned) + round_const) >> shift;\n    (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSUB <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 001011 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQSUB <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 001011 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Subtract", 
    "name": "UQSUB", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\ninteger diff;\nboolean sat;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    diff = element1 - element2;\n    (Elem[result, e, esize], sat) = SatQ(diff, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger part = 0;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQXTN <Vb><d>, <Va><n>"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100001010010 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UQXTN{2} <Vd>.<Tb>, <Vn>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100001010010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating extract Narrow", 
    "name": "UQXTN, UQXTN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nboolean sat;\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    (Elem[result, e, esize], sat) = SatQ(Int(element, unsigned), esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz == '1' then ReservedValue();\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URECPE <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 0011101 Rn#5 100001110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Reciprocal Estimate", 
    "name": "URECPE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRecipEstimate(element);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URHADD <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 000101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Rounding Halving Add", 
    "name": "URHADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger element1;\ninteger element2;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    Elem[result, e, esize] = (element1 + element2 + 1)<esize:1>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 010101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 010101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Rounding Shift Left (register)", 
    "name": "URSHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSHR <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 001001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSHR <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 001001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Rounding Shift Right (immediate)", 
    "name": "URSHR", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif sz == '1' then ReservedValue();\ninteger esize = 32;\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSQRTE <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 sz#1 1011101 Rn#5 100001110010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Reciprocal Square Root Estimate", 
    "name": "URSQRTE", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(32) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, 32];\n    Elem[result, e, 32] = UnsignedRSqrtEstimate(element);\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSRA <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 001101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "URSRA <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 001101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Rounding Shift Right and Accumulate (immediate)", 
    "name": "URSRA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\nif S == '0' && size != '11' then ReservedValue();\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USHL <V><d>, <V><n>, <V><m>"
          }
        ], 
        "pattern": "size#2 01111110 Rm#5 1 Rn#5 010001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\nboolean rounding = (R == '1');\nboolean saturating = (S == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USHL <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 010001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Shift Left (register)", 
    "name": "USHL", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger round_const = 0;\ninteger shift;\ninteger element;\nboolean sat;\nfor e = 0 to elements-1\n    shift = SInt(Elem[operand2, e, esize]<7:0>);\n    if rounding then\n        round_const = 1 << (-shift - 1); \n    endif\n    element = (Int(Elem[operand1, e, esize], unsigned) + round_const) << shift;\n    if saturating then\n        (Elem[result, e, esize], sat) = SatQ(element, esize, unsigned);\n        if sat then FPSR.QC = '1';\n    else\n        Elem[result, e, esize] = element<esize-1:0>;\n    endif\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3> == '1' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\ninteger shift = UInt(immh:immb) - esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USHLL{2} <Vd>.<Ta>, <Vn>.<Tb>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 101001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Shift Left Long (immediate)", 
    "name": "USHLL, USHLL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = Vpart[n, part];\nbits(datasize*2) result;\ninteger element;\nfor e = 0 to elements-1\n    element = Int(Elem[operand, e, esize], unsigned) << shift;\n    Elem[result, e, 2*esize] = element<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USHR <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 000001 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USHR <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 000001 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Shift Right (immediate)", 
    "name": "USHR", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger esize = 8 << UInt(size);\ninteger datasize = esize;\ninteger elements = 1;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USQADD <V><d>, <V><n>"
          }
        ], 
        "pattern": "size#2 01111110 Rn#5 100000001110 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USQADD <Vd>.<T>, <Vn>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rn#5 100000001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned saturating Accumulate of Signed value", 
    "name": "USQADD", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand = V[n];\nbits(datasize) result;\nbits(datasize) operand2 = V[d];\ninteger op1;\ninteger op2;\nboolean sat;\nfor e = 0 to elements-1\n    op1 = Int(Elem[operand, e, esize], !unsigned);\n    op2 = Int(Elem[operand2, e, esize], unsigned);\n    (Elem[result, e, esize], sat) = SatQ(op1 + op2, esize, unsigned);\n    if sat then FPSR.QC = '1';\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh<3> != '1' then ReservedValue();\ninteger esize = 8 << 3;\ninteger datasize = esize;\ninteger elements = 1;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USRA <V><d>, <V><n>, #<shift>"
          }
        ], 
        "pattern": "immh#4 011111110 immb#3 Rn#5 000101 Rd#5", 
        "size": 32
      }, 
      {
        "constraints": [
          [
            "immh", 
            "!=", 
            "0000"
          ]
        ], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif immh == '0000' then SEE(asimdimm);\nif immh<3>:Q == '10' then ReservedValue();\ninteger esize = 8 << HighestSetBit(immh);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger shift = (esize * 2) - UInt(immh:immb);\nboolean unsigned = (U == '1');\nboolean round = (o1 == '1');\nboolean accumulate = (o0 == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USRA <Vd>.<T>, <Vn>.<T>, #<shift>"
          }
        ], 
        "pattern": "Q#1 0 immh#4 1011110 immb#3 Rn#5 000101 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Shift Right and Accumulate (immediate)", 
    "name": "USRA", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand  = V[n];\nbits(datasize) operand2;\nbits(datasize) result;\ninteger round_const = if round then (1 << (shift - 1)) else 0;\ninteger element;\noperand2 = if accumulate then V[d] else Zeros();\nfor e = 0 to elements-1\n    element = (Int(Elem[operand, e, esize], unsigned) + round_const) >> shift;\n    Elem[result, e, esize] = Elem[operand2, e, esize] + element<esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USUBL{2} <Vd>.<Ta>, <Vn>.<Tb>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 001000 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Subtract Long", 
    "name": "USUBL, USUBL2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize)   operand1 = Vpart[n, part];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\nboolean sub_op = (o1 == '1');\nboolean unsigned = (U == '1');\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "USUBW{2} <Vd>.<Ta>, <Vn>.<Ta>, <Vm>.<Tb>"
          }
        ], 
        "pattern": "Q#1 0 size#2 101110 Rm#5 1 Rn#5 001100 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unsigned Subtract Wide", 
    "name": "USUBW, USUBW2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand1 = V[n];\nbits(datasize)   operand2 = Vpart[m, part];\nbits(2*datasize) result;\ninteger element1;\ninteger element2;\ninteger sum;\nfor e = 0 to elements-1\n    element1 = Int(Elem[operand1, e, 2*esize], unsigned);\n    element2 = Int(Elem[operand2, e, esize], unsigned);\n    if sub_op then\n        sum = element1 - element2;\n    else\n        sum = element1 + element2;\n    endif\n    Elem[result, e, 2*esize] = sum<2*esize-1:0>;\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UZP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 000110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unzip vectors (primary)", 
    "name": "UZP1", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\ninteger e;\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "UZP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 010110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Unzip vectors (secondary)", 
    "name": "UZP2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operandl = V[n];\nbits(datasize) operandh = V[m];\nbits(datasize) result;\ninteger e;\nbits(datasize*2) zipped = operandh:operandl;\nfor e = 0 to elements-1\n    Elem[result, e, esize] = Elem[zipped, 2*e+part, esize];\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "WFE"
          }
        ], 
        "pattern": "11010101000000110010000001011111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Wait For Event", 
    "name": "WFE", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "WFI"
          }
        ], 
        "pattern": "11010101000000110010000001111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Wait For Interrupt", 
    "name": "WFI", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "if !HaveCryptoExt2() then UnallocatedEncoding();\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "XAR <Vd>.2D, <Vn>.2D, <Vm>.2D, #<imm6>"
          }
        ], 
        "pattern": "Rm#5 11001110100 imm6#6 Rn#5 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Exclusive OR and Rotate", 
    "name": "XAR", 
    "operation": "bits(128) Vm = V[m];\nbits(128) Vn = V[n];\nbits(128) tmp;\ntmp = Vn EOR Vm; \nV[d] = ROR(tmp<127:64>, UInt(imm6)):ROR(tmp<63:0>, UInt(imm6));\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "boolean data = (D == '1');\ninteger d = UInt(Rd);\ninteger n = UInt(Rn);\nif !HavePACExt() then\n    UnallocatedEncoding();\nendif\nif n != 31 then UnallocatedEncoding();\n", 
        "encodings": [
          {
            "condition": "D == 1", 
            "format": "XPACD <Xd>"
          }, 
          {
            "condition": "D == 0", 
            "format": "XPACI <Xd>"
          }
        ], 
        "pattern": "D#1 110110101100000101000 Rd#5 11111", 
        "size": 32
      }, 
      {
        "constraints": [], 
        "decoder_pre": "integer d = 30;\nboolean data = FALSE;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "XPACLRI"
          }
        ], 
        "pattern": "11010101000000110010000011111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Strip Pointer Authentication Code", 
    "name": "XPACD, XPACI, XPACLRI", 
    "operation": "if HavePACExt() then\n    X[d] = Strip(X[d], data);\nendif\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\nif size == '11' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = 64;\ninteger part = UInt(Q);\ninteger elements = datasize DIV esize;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "XTN{2} <Vd>.<Tb>, <Vn>.<Ta>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rn#5 100001001010 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Extract Narrow", 
    "name": "XTN, XTN2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(2*datasize) operand = V[n];\nbits(datasize) result;\nbits(2*esize) element;\nfor e = 0 to elements-1\n    element = Elem[operand, e, 2*esize];\n    Elem[result, e, esize] = element<esize-1:0>;\nendfor\nVpart[d, part] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "SystemHintOp op;\ncase CRm:op2 of\n    when '0000000' op = SystemHintOp_NOP;\n    when '0000001' op = SystemHintOp_YIELD;\n    when '0000010' op = SystemHintOp_WFE;\n    when '0000011' op = SystemHintOp_WFI;\n    when '0000100' op = SystemHintOp_SEV;\n    when '0000101' op = SystemHintOp_SEVL;\n    when '0000111'\n        SEE \"XPACLRI\";\n    when '0001xxx'\n        SEE \"PACIA1716, PACIB1716, AUTIA1716, AUTIB1716\";\n    when '0010000'\n        if !HaveRASExt() then EndOfInstruction();                  \n        op = SystemHintOp_ESB;\n    when '0010001'\n        if !HaveStatisticalProfiling() then EndOfInstruction();    \n        op = SystemHintOp_PSB;\n    when '0011xxx'\n        SEE \"PACIAZ, PACIASP, PACIBZ, PACIBSP, AUTIAZ, AUTIASP, AUTIBZ, AUTIBSP\";\n    otherwise  EndOfInstruction();                                \nendcase\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "YIELD"
          }
        ], 
        "pattern": "11010101000000110010000000111111", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "YIELD", 
    "name": "YIELD", 
    "operation": "case op of\n    when SystemHintOp_YIELD\n        Hint_Yield();\n    when SystemHintOp_WFE\n        if IsEventRegisterSet() then\n            ClearEventRegister();\n        else\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, TRUE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, TRUE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, TRUE);\n            endif\n            WaitForEvent();\n        endif\n    when SystemHintOp_WFI\n        if !InterruptPending() then\n            if PSTATE.EL == EL0 then\n                AArch64.CheckForWFxTrap(EL1, FALSE);\n            endif\n            if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} && !IsInHost() then\n                AArch64.CheckForWFxTrap(EL2, FALSE);\n            endif\n            if HaveEL(EL3) && PSTATE.EL != EL3 then\n                AArch64.CheckForWFxTrap(EL3, FALSE);\n            endif\n            WaitForInterrupt();\n        endif\n    when SystemHintOp_SEV\n        SendEvent();\n    when SystemHintOp_SEVL\n        SendEventLocal();\n    when SystemHintOp_ESB\n        ErrorSynchronizationBarrier(MBReqDomain_FullSystem, MBReqTypes_All);\n        AArch64.ESBOperation();\n        if HaveEL(EL2) && !IsSecure() && PSTATE.EL IN {EL0,EL1} then AArch64.vESBOperation();\n        TakeUnmaskedSErrorInterrupts();\n    when SystemHintOp_PSB\n        ProfilingSynchronizationBarrier();\n    otherwise \nendcase\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ZIP1 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 001110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Zip vectors (primary)", 
    "name": "ZIP1", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger base = part * pairs;\ninteger p;\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\nendfor\nV[d] = result;\n"
  }, 
  {
    "classes": [
      {
        "constraints": [], 
        "decoder_pre": "integer d = UInt(Rd);\ninteger n = UInt(Rn);\ninteger m = UInt(Rm);\nif size:Q == '110' then ReservedValue();\ninteger esize = 8 << UInt(size);\ninteger datasize = if Q == '1' then 128 else 64;\ninteger elements = datasize DIV esize;\ninteger part = UInt(op);\ninteger pairs = elements DIV 2;\n", 
        "encodings": [
          {
            "condition": "", 
            "format": "ZIP2 <Vd>.<T>, <Vn>.<T>, <Vm>.<T>"
          }
        ], 
        "pattern": "Q#1 0 size#2 001110 Rm#5 0 Rn#5 011110 Rd#5", 
        "size": 32
      }
    ], 
    "decoder_post": "", 
    "description": "Zip vectors (secondary)", 
    "name": "ZIP2", 
    "operation": "CheckFPAdvSIMDEnabled64();\nbits(datasize) operand1 = V[n];\nbits(datasize) operand2 = V[m];\nbits(datasize) result;\ninteger base = part * pairs;\ninteger p;\nfor p = 0 to pairs-1\n    Elem[result, 2*p+0, esize] = Elem[operand1, base+p, esize];\n    Elem[result, 2*p+1, esize] = Elem[operand2, base+p, esize];\nendfor\nV[d] = result;\n"
  }
]